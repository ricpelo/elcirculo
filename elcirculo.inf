!% -~S
!% -G
!% +language_name=Spanish
!% $MAX_STATIC_DATA=25000
!% $MAX_PROP_TABLE_SIZE=63840
!% $MAX_VERBS=200
!% $MAX_ZCODE_SIZE=45000
!% $MAX_VERBSPACE=4500

!
! EL CÍRCULO
!
! Copyright (c) 2012 Ricardo Pérez López (Alpha Aventuras)
!

! This program is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.


!===============================================================================
! (1) Constantes; Variables Globales; Replaces; Propertys; Incluir Parser.h
!-------------------------------------------------------------------------------


! ====================================================================
! CONSTANTES
! ====================================================================


Constant Story "@<<EL CÍRCULO@>>";
Constant Headline "^(c) 2012 Alpha Aventuras^^";
!                  Teclea CRÉDITOS si quieres saber más acerca de la aventura, o
!                  AYUDA cuando estés bloqueado.^";
Release 1;

! Queremos usar el comando 'Salidas'
Constant ADMITIR_COMANDO_SALIDAS;

! No queremos usar los comandos 'Lugares' y 'Objetos'
Constant NO_PLACES;

! No queremos usar puntuación
Constant NO_SCORE;

! Queremos que se muestren las deducciones del parser
!Constant IMPRIMIR_DEDUCCIONES;

! Hay curiosidades al final del juego
!Constant AMUSING_PROVIDED;

! Ancho de la ventana de acciones:
Constant ANCHO_ACCIONES  = 25;

! Canales y volúmenes para los sonidos:
Constant CANAL_FONDO     = 9; Constant VOLUMEN_FONDO     = 50;
Constant CANAL_TV_SALON  = 0; Constant VOLUMEN_TV_SALON  = 100;
Constant CANAL_TV_CUARTO = 1; Constant VOLUMEN_TV_CUARTO = 50;
Constant CANAL_TELEFONO  = 2; Constant VOLUMEN_TELEFONO  = 100;

! El color de fondo de la ventana gráfica es negro:
Constant CLR_GG_PERSBACK = CLR_GG_BLACK;

! Color de los hyperlinks al empezar la aventura:
Constant COLOR_HYPERLINK = $a1d0fc;

! Al acabar una partida (con éxito o fracaso) te da la opción de UNDO:
Constant DEATH_MENTION_UNDO;

! No queremos marcos en las cajas hechas con el comando box:
Constant GBOXQUOTE_NOFRAME;

! La roca de la ventana de menús de acciones:
Constant GG_MENUWIN_ROCK = 213;

! La roca de la ventana de conversaciones con personajes:
Constant GG_CONVERSAWIN_ROCK = 214;

! Alturas de los gráficos:
Constant GRAFICOS_MINUSCULOS = 200;
Constant GRAFICOS_PEQUENOS   = 250;
Constant GRAFICOS_MEDIANOS   = 350;
Constant GRAFICOS_GRANDES    = 450;

!Constantes de gtalk.h:
!Constant GT_SELECT       = "Selecciona una opción ";
!Constant GT_WOULDLIKE    = "^¿Qué vas a decir?^";
Constant GT_NOQUIP       = "^No se te ocurre nada más que decir.^";
Constant GT_NOSAY        = "^Prefieres no decir nada.^";
Constant GT_OPTIONPREFIX = "[";
Constant GT_OPTIONSUFFIX = "] ";
Constant GT_ZEROEXIT     = "No decir nada.";
![ GT_ZEROEXIT; ! La hacemos rutina en lugar de constante
!  print "(";
!  glk($0086, 8); ! set input style
!  glk($100, 48);
!  print "0";
!  glk($100, 0); 
!  glk($0086, 0); ! set input style
!  print " para salir) ";
!];

! Valores iniciales de los parámetros relacionados con el buffer de texto:
Constant INICIAL_MONOSIZE = 170; 
Constant INICIAL_PROPSIZE = 200;
Constant INICIAL_LEADING  = 25;
Constant INICIAL_BASELINE = 17;
Constant INICIAL_COLS     = 115;
Constant INICIAL_REFLOW   = true;

! Las posibles distribuciones de ventanas en la aventura:
Constant LAYOUT_MENU_PRINCIPAL = 0; ! Distribución en el menú principal
Constant LAYOUT_JUEGO = 1;          ! Distribución durante el juego

! Color del borde del mapa en el mapeador automático:
Constant MAPA_COLOR_BORDE = COLOR_HYPERLINK;

! Tamaños para arrays relacionados con el menú de acciones:
Constant MAXIMO_OPCIONES = 100;         ! Número máximo de opciones en el array
Constant MAXIMO_TECLAS_OPCIONES = 30;   ! Número de teclas de acceso directo

! Número máximo de cadenas DIFERENTES que se han impreso:
Constant PS_TAB_SIZE = 1000;

! Vamos a usar Damusix junto con SGW+DMX
Constant SGW_CON_DAMUSIX;
Constant SONIDO_REPETIR = -1;

! Constantes para los gestores de timer:
Constant TIMER_TICK = 10;
Constant TIMER_DURACION_BECCA = 500;
Constant TIMER_DURACION_IMAGEN_PERSONAJE = 400;
Constant TIMER_DURACION_TLF_KATIE = 600;
Constant TIMER_DURACION_IMAGEN_LOCALIDAD = 1;


! ====================================================================
! VARIABLES GLOBALES
! ====================================================================


! El array de opciones en el menú de acciones:
Array opcionesMenu --> MAXIMO_OPCIONES;

! Números de opción asociados con una tecla de acceso rápido:
Array numeroOpciones -> MAXIMO_TECLAS_OPCIONES;

! Teclas de acceso rápido en el menú de acciones:
Array teclasOpciones -> '1' '2' '3' '4' '5' '6' '7' '8' '9' 'A'
                        'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'L' 'M'
                        'O' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z';

! Altura (en px.) de la ventana de logo en el menú principal:
Global altoLogoMenu = 400;

! Anchura de la ventana gráfica:
Global anchoVentanaGrafica = GRAFICOS_MEDIANOS;

! Se pone a true y false en la rutina PermitirEmpujarDir, y luego se consulta en
! MensajesLibreria:
Global estoyEmpujando = false;

! La ventana de conversación con personajes:
Global gg_conversawin = 0;

! La ventana de menús de acciones:
Global gg_menuwin = 0;

! Hay gráficos o no:
Global hayGraficos = true;

! Interruptor de pistas:
Global hayPistas = 0;

! Hay sonidos:
Global haySonido = true;
Global haySonidoFondo = true;

! Hay eventos en tiempo real:
Global hayTiempoReal = true;

! Hay efecto de teletipo:
!Global hayTeletipo = false;

! La distribución de ventanas actual. Empezamos con la distribución
! del menú principal, y cuando empezamos el juego (en IniciarAventura())
! cambiamos a la distribución LAYOUT_JUEGO. Es necesario saber en qué
! layout estamos para poder restaurar correctamente las ventanas ante
! un UNDO/RESTART/RESTORE:
Global layoutPantalla = LAYOUT_MENU_PRINCIPAL;

! Si se ha activado el listado automático de salidas:
Global mostrarSalidas = true;

! La imagen que representa la oscuridad:
Global SGW_IMAGEN_OSCURIDAD = Oscuridad_jpg;

! Lista que se usa en PistasSub() para apagar y encender correctamente
! los sonidos que estén sonando al entrar en las pistas:
Array sonidosSonando -> DAMUSIX_NCANALMAX;


! ====================================================================
! REPLACES
! ====================================================================


! La pregunta del final del juego, pero con menús:
Replace AfterGameOver;

! Ajustamos esta rutina para que SGW+DMX no actualice sola el gráfico de la
! localidad actual cuando se está mostrando el gráfico de un personaje:
Replace AfterPrompt;

! Con el siguiente Replace conseguimos que el objeto empujado hacia una
! dirección aparezca en la descripción de la localidad de destino del "empuje":
Replace AllowPushDir;

! En este juego no se responde, ni se habla:
Replace AnswerSub;
Replace TellSub;

! Para usar el comando box con Glulx:
Replace Box__Routine;

! Nuestra versión de CerrarVentanaMapa es prácticamente idéntica a la de
! Mapeador.h, con la única diferencia de que sólo llama a EncenderGraficos()
! cuando hayGraficos es true:
Replace CerrarVentanaMapa;

! En este juego no se usa el Consultar (CONSULTA, LEE, BUSCA EN x SOBRE y...):
Replace ConsultSub;

! Igualmente, esta versión no muestra puntos cardinales, sino lugares, al
! indicar hacia dónde va un PNJ móvil:
Replace DirDada;

! Nuestra versión de DrawStatusLine:
Replace DrawStatusLine;

! Sustituimos la rutina EncenderGraficos que aparece en Mapeador:
Replace EncenderGraficos;

! Reemplazo de los puntos de entrada de Glulx:
Replace HandleGlkEvent;
Replace InitGlkWindow;

! Lo pide TestMachine_NG.h:
Replace KeyboardPrimitive;

! Lo pide Timer.h:
Replace KeyDelay;

! Nuestra versión de LanguageDirection no muestra los puntos cardinales y
! muestra entre paréntesis el destino de la dirección:
Replace LanguageDirection;

! Lo pide Sonidos_NG.h:
Replace ListenSub;
Replace Locale;

! Para deshabilitar los modos breve y superbreve:
Replace LMode1Sub;
Replace LMode3Sub;

! Usamos el ParseNoun de IntNombre_NG:
Replace ParseNoun;

! Nuestra versión pone hipervínculos automáticamente:
Replace PSN__;

! Nuestra versión elimina también los signos de admiración e interrogación:
Replace QuitarAcentos;

! Nuestra versión pregunta si quiere guardar la partida antes de salir:
Replace QuitSub;

! Cambia la función random() (ver random.h):
Replace random;

! Nuestra versión pregunta si quiere guardar la partida antes de reiniciar:
Replace RestartSub;

! En este juego no se usa el BuscarEn (MIRA EN, BUSCA EN/DENTRO/DE/SOBRE,
! REGISTRA...):
Replace SearchSub;

! Queremos que la línea de estado se cree sin bordes:
Replace StatusLineHeight;

! Para usar el menú de acciones:
Replace YesOrNo;

! Ponemos nuestra propias versiones de estas rutinas para nuestros menús:
Replace ZIPI_PintaTitulo;
Replace ZIPI_RunMenu;
Replace ZIPI_RunOtro;
Replace ZIPI_tecla;


Include "Parser";


!===============================================================================
! (2) Puntos de Entrada para Glk [solo en Glulx]:
!     -  HandleGlkEvent(), IdentifyGlkObject(), InitGlkWindow()
!-------------------------------------------------------------------------------


[ HandleGlkEvent ev context buffer
  obj long r;
  switch (ev-->0) {
    evtype_MouseInput:
      glk_request_mouse_event(ev-->1);
      if (context == 1) return 1;  ! character input request, no se hace nada
      r = HandleGlkMouseEvent(ev-->1);
      if (r) {
        obj = r;
        jump HayObjeto;
      }

    evtype_Hyperlink:
      glk_request_hyperlink_event(ev-->1);  ! ev-->1 es la ventana
      if (context == 1) return 1;  ! character input request, no se hace nada
      obj = ev-->2;                ! ev-->2 es el número de hyperlink

      if (ev-->1 == gg_menuwin) {  ! Ventana del menú de acciones
        glk_cancel_line_event(gg_mainwin, gg_event);
        if (obj hasnt general) {    ! Si no hay que continuar escribiendo
          glk_set_style(style_Input);
          PrintAnything(obj.ZIPI_ejecutar());
          new_line;
          glk_set_style(style_Normal);
        }
        ! Los casos de save y restore hay que tratarlos aparte, porque tienden
        ! a repetir el input del jugador en pantalla, no sé por qué:
        if (obj == Menu_Save or Menu_Restore) {
          if (obj == Menu_Save) SaveSub();
          else                  RestoreSub();
          buffer-->0 = 0;
          return 2; ! Se simula la pulsación de Intro con input vacío
        }
        long = PrintAnyToArray(buffer + WORDSIZE,
                               INPUT_BUFFER_LEN - WORDSIZE,
                               obj.ZIPI_ejecutar());
        buffer-->0 = long;
        if (obj has general) {
          glk_request_line_event(gg_mainwin, buffer + WORDSIZE,
                                 INPUT_BUFFER_LEN - WORDSIZE, buffer-->0);
          return 1; ! Seguimos escribiendo
        } else {
          return 2; ! No seguimos escribiendo: Intro
        }
      }

      if (ev-->1 == gg_mainwin or gg_statuswin) {  ! Principal o de estado
      .HayObjeto;
        glk_cancel_line_event(gg_mainwin, gg_event);
        if (gg_event-->2 == 0) {          ! Si no hay nada escrito
          if (obj ofclass Object) {       ! Si es un objeto (no una cadena)
            ! ¿Es punto cardinal? ¿Es localidad adyacente? Mostrar la orden
            if (obj in Compass || (ConexionLocalidad(obj) && obj hasnt door)) {
              glk_set_style(style_Input);
              print "ve "; MostrarNombre(obj, 2, 0, 1); new_line;
              glk_set_style(style_Normal);
              long = PrintAnyToArray(buffer + WORDSIZE,
                                     INPUT_BUFFER_LEN - WORDSIZE,
                                     MostrarNombre, obj, 2, 0, 1);
              buffer-->0 = long;
              return 2;
            } else if (obj == location) { ! Si es el nombre de la localidad
              print (s_input) "mira ", "^";
              long = PrintAnyToArray(buffer + WORDSIZE,
                                     INPUT_BUFFER_LEN - WORDSIZE, "m");
              buffer-->0 = long;
              return 2;
            } else if (obj == Menu_Importantes) {
              MenuAcciones.AbrirVentana();
              r = MenuAcciones.MostrarAcciones(obj);
              MenuAcciones.CerrarVentana();
              if (r) {
                glk_set_style(style_Input);
                r = r.ZIPI_ejecutar();
                PrintAnything(r);
                new_line;
                glk_set_style(style_Normal);
                long = PrintAnyToArray(buffer + WORDSIZE,
                                       INPUT_BUFFER_LEN - WORDSIZE,
                                       r);       ! El verbo
                buffer-->0 = long;
                return 2;
              } else {
                glk_request_line_event(gg_mainwin, buffer + WORDSIZE,
                                       INPUT_BUFFER_LEN - WORDSIZE, 0);
                return 1;
              }
            } else { ! Es objeto, no punto cardinal ni lugar actual o adyacente
              MostrarImagenAuxiliar(obj);
              MenuAcciones.AbrirVentana();
              r = MenuAcciones.MostrarAcciones(obj);
              MenuAcciones.CerrarVentana();
              if (r) { ! Si se ha escogido una opción en el menú:
                glk_cancel_line_event(gg_mainwin, gg_event);
                if (r hasnt general) {    ! Si no hay que continuar escribiendo
                  glk_set_style(style_Input);
                  print (address) r.ZIPI_ejecutar(), " ";
                  MostrarNombre(obj, 2, 0, 1);
                  new_line;
                  glk_set_style(style_Normal);
                }
                long = PrintAnyToArray(buffer + WORDSIZE,
                                       INPUT_BUFFER_LEN - WORDSIZE,
                                       r.ZIPI_ejecutar());       ! El verbo
                long = long + PrintAnyToArray(buffer + WORDSIZE + long,
                                              INPUT_BUFFER_LEN - WORDSIZE,
                                              " ");              ! Un espacio
                long = long + PrintAnyToArray(buffer + WORDSIZE + long,
                                              INPUT_BUFFER_LEN - WORDSIZE,
                                              MostrarNombre, obj,
                                              2, 0, 1);          ! El objeto
                long = long + PrintAnyToArray(buffer + WORDSIZE + long,
                                              INPUT_BUFFER_LEN - WORDSIZE,
                                              " ");              ! Un espacio
                if (r provides ZIPI_secundario) {   ! Si hay que completar...
                  long = long + PrintAnyToArray(buffer + WORDSIZE + long,
                                                INPUT_BUFFER_LEN - WORDSIZE,
                                                r.ZIPI_secundario());
                  long = long + PrintAnyToArray(buffer + WORDSIZE + long,
                                                INPUT_BUFFER_LEN - WORDSIZE,
                                                " ");                                          
                }
                buffer-->0 = long;
                if (r has general) {
                  glk_request_line_event(gg_mainwin, buffer + WORDSIZE,
                                         INPUT_BUFFER_LEN - WORDSIZE,
                                         buffer-->0);
                  return 1; ! Seguimos escribiendo
                } else {
                  return 2; ! No seguimos escribiendo: Intro
                }
              } else { ! Si no se ha escogido ninguna opción del menú
                glk_request_line_event(gg_mainwin, buffer + WORDSIZE,
                                       INPUT_BUFFER_LEN - WORDSIZE, 0);
                return 1;
              }
            }
          } ! if (obj ofclass Object)
        } ! if (gg_event-->2 == 0)
        ! Si llegamos hasta aquí, puede ser por una de estas causas (o varias):
        ! - El jugador ya había tecleado algo (el input no era vacío)
        ! - El hyperlink pulsado no era un objeto, sino una cadena
        long = gg_event-->2;
        long = PrintAnyToArray(buffer + WORDSIZE + long,
                               INPUT_BUFFER_LEN - WORDSIZE,
                               MostrarNombre, obj, 2, 0, 1);
        buffer-->0 = long + gg_event-->2;
        ! Si ya había algo escrito, se entiende que el jugador quiere completar
        ! la entrada que estaba escribiendo, por lo que retornamos 1. Si no
        ! había nada escrito, retornamos 2 para simular la pulsación de Intro:
        if (gg_event-->2 > 0) {
          ! Añadimos un espacio en blanco al final:
          long = PrintAnyToArray(buffer + WORDSIZE + buffer-->0,
                                 INPUT_BUFFER_LEN - WORDSIZE, " ");
          buffer-->0 = buffer-->0 + long;
          glk_request_line_event(gg_mainwin, buffer + WORDSIZE,
                                 INPUT_BUFFER_LEN - WORDSIZE, buffer-->0);
          return 1;  ! Retornamos 1 para que el jugador pueda seguir tecleando 
        } else {
          glk_set_style(style_Input);
          Tokenise__(buffer, parse);
          ! Si en alguna parte hay una coma, se entiende que se está hablando
          ! con un personaje o dándole una orden, por lo que no mostramos ve
          ! ni ex:
          for (r = WORDSIZE : r < parse-->0 + WORDSIZE : r++) {
            if (parse-->r == ',//') jump Imprimir;
          }
          ! Si la primera palabra del buffer es un verbo, no mostramos ve ni ex:
          if (LanguageIsVerb(buffer, parse, 1)) jump Imprimir;  
          if (obj ofclass Lugar) print "ve ";
          else                   print "ex ";
        .Imprimir;
          ImprimeTodoElBuffer(buffer);
          glk_set_style(style_Normal);
          new_line;
          return 2;  ! Retornamos 2 para que simule la pulsación de Intro
        }
      } ! if (ev-->1 == gg_mainwin or gg_statuswin)
  } ! switch (ev-->0)
  SGW_HandleGlk(ev);
  ControlTimer.CT_HandleGlkEvent(ev, context, buffer);
  Mapa_HandleGlkEvent(ev, context, buffer);
  midiario.Diary_HandleGlkEvent(ev, context, buffer);
];


[ IdentifyGlkObject fase tipo ref rock;
  MenuAcciones.Menu_IdentifyGlkObject(fase, tipo, ref, rock);
  SGW_IdentifyGlk(fase, tipo, ref, rock);
  Damusix.IdentificarSonidos(fase);
  Mapa_IdentifyGlkObject(fase, tipo, ref, rock);
  Conversa_IdentifyGlkObject(fase, tipo, ref, rock);
  if (fase == 2) {
    ControlTimer.ReactivarTick();
    ZIPI_Configuracion.restaurar_valores();
    ZIPI_Mostrar_Hyperlinks.restaurar_valores();
  }
];


[ InitGlkWindow winrock;
  switch (winrock) {
    GG_MAINWIN_ROCK, GG_STATUSWIN_ROCK, GG_MENUWIN_ROCK, GG_CONVERSAWIN_ROCK:
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Weight, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Justification, stylehint_just_LeftRight);

      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_Weight, 1);

      ! Esta será mi negrita:
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_BackColor, $0000ff);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_TextColor, $0000ff);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Weight, 1);
 
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_TextColor, $82c1fb);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_Weight, 0);

      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Subheader,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_Subheader,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_SubHeader,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_SubHeader,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Note,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextBuffer, style_Note,
                        stylehint_BackColor, $000000);

      glk_stylehint_set(wintype_TextBuffer, style_BlockQuote,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_BlockQuote,
                        stylehint_BackColor, $ffffff);


      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Weight, 0);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Justification, stylehint_just_LeftRight);
         
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_Weight, 1);
 
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_Weight, 1);
  
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_BackColor, $0000ff);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_TextColor, $0000ff);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Weight, 1);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Justification, stylehint_just_LeftRight);

      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_TextColor, $82c1fb);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Subheader,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_Subheader,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_SubHeader,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_SubHeader,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Note,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextGrid, style_Note,
                        stylehint_BackColor, $000000);

      glk_stylehint_set(wintype_TextGrid, style_BlockQuote,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_BlockQuote,
                        stylehint_BackColor, $ffffff);
  }

  rfalse; ! si te olvidas esta linea, el juego no funcionará bien
];


! El IdentifyGlkObject de la ventana de conversaciones con personajes:
[ Conversa_IdentifyGlkObject fase tipo ref rock;
  if (fase == 0) { ! Poner cero en todos nuestros objetos glk
    gg_conversawin = 0;
    return;
  }
  if (fase == 1) { ! Reiniciar correctamente las variables glk
    switch (tipo) {
      0: ! es una ventana
         switch (rock) {
           GG_CONVERSAWIN_ROCK: gg_conversawin = ref;
         }
      1: ! es un flujo
         ! pero no hay flujos en este ejemplo
      2: ! es una referencia a fichero
         ! pero no hay ficheros en este ejemplo
    }
    return;
  }
  if (fase == 2) { ! Actualizar nuestras ventanas
    if (gg_conversawin) {
      glk_window_close(gg_conversawin, 0);
      gg_conversawin = 0;
    }
    return;
  }
];


!===============================================================================
! (3) Modificar Mensajes de la Libreria; Otros Includes; Incluir VerbLib.h
!-------------------------------------------------------------------------------


!Include "Rastros_NG";


[ quieres_ x;
  if (player provides persona) {
    switch (player.persona) {
      PRIMERA_PERSONA,
      PRIMERA_PERSONA_SINGULAR: print "quiero";
      SEGUNDA_PERSONA,
      SEGUNDA_PERSONA_SINGULAR: print "quieres";
      TERCERA_PERSONA,
      TERCERA_PERSONA_SINGULAR: print "quiere";
      PRIMERA_PERSONA_PLURAL:   print "queremos";
      SEGUNDA_PERSONA_PLURAL:   print "queréis";
      TERCERA_PERSONA_PLURAL:   print "quieren";
      default:                  print "quieres";
    }
  } else print "quieres";
  print (string) x;
];


Object LibraryMessages
  with
    mostrar_nombre [ l;
      l = LugarReal().(lm_o.door_dir);
      if (l == nothing) print (the) lm_o;
      else              MostrarNombreLink(l);
    ],
    before [;
      Look:
        switch (lm_n) {
!          5, 6: new_line;
!                if (lm_o ~= location) {
!                  if (lm_o has supporter) print "Sobre ";
!                  else                    print "En ";
!                  print (the) lm_o;
!                  print " ", (puedes_) " ver ";
!                } else print "", (_Puedes_) " ver ";
!
!                if (n == 5) print "también ";
!                WriteListFrom(child(lm_o),
!                              ENGLISH_BIT + WORKFLAG_BIT + RECURSE_BIT +
!                              TERSE_BIT + CONCEAL_BIT); ! Quitamos PARTINV_BIT
!                if (lm_o ~= location) ".";
!                ".";

          7: print "No observ", (as_) " nada digno de mención al mirar hacia ";
             self.mostrar_nombre();
             ".";
        }

      Prompt:
        new_line;
        ImprimirPrompt();
        rtrue;

      Go:
        switch (lm_n) {
          2: if (estoyEmpujando)
               "^No ", (puedes_) " seguir empujando porque no hay salida
               hacia ", (the) noun, ".";
             if (noun == in_obj)
               "No v", (eo_) " ningún sitio en el que ", (pueda_) " entrar.";
             "No ", (puedes_) " ir por ahí, porque no hay salida hacia ",
              (the) noun, ".";
          5: if (estoyEmpujando) {
               print "^No ", (puedes_) " empujar nada a través ";
             } else {
               print "No ", (puedes_) " pasar a través ";
             }
             DelMostrarNombre(lm_o);
             ".";
        }
        
      Take:
        if (lm_n == 1) {
          print "Reco";
          if (player.persona == PRIMERA_PERSONA_SINGULAR) print "j";
          else                                            print "g";
          print (es_) " ";
          if (noun has moved) print (the) noun;
          else                print (a) noun;
          ".";
        }

      Drop:
        if (lm_n == 4) "Dej", (as_) " ", (the) lm_o, ".";

      Remove:
        if (lm_n == 3) {
          if (verb_word == 'quita') {
            "Quit", (as_) " ", (the) lm_o, " ", (del) second, ".";
          } else {
            "Sac", (as_) " ",  (the) lm_o, " ", (del) second, ".";
          }
        }

      GetOff:
        print "Pero si no est", (oy_) " en ";
        if (lm_o ofclass Lugar) MostrarNombreLink(lm_o);
        else                    print (the) lm_o;
        "...";

      Exit:
        if (lm_n == 1) {
          "Si ", (quieres_) " moverte, indica hacia dónde quieres ir.";
        }

      Miscellany:
        switch (lm_n) {
           4: print " ¡Enhorabuena! Has acabado la aventura ";
              rtrue;
          10: rtrue;
          13: ! Reactivamos timer en caso de UNDO:
!              ControlTimer.ReactivarTick();
              "[Retrocediendo al turno anterior.]";
          17: switch (random(4)) {
                1: "Está muy oscuro y no puedes ver nada.";
                2: "Todo está demasiado oscuro y no aprecias nada con
                    claridad.";
                3: "La oscuridad te impide ver dónde te encuentras.";
                4: "Te mueves a tientas a través de una oscuridad que te impide
                    ver nada.";
              }
          19: "Has tenido días mejores...";
          30: switch (random(3)) {
                1: "No encuentro eso que dices.";
                2: "No veo nada parecido por aquí.";
                3: "Parece que no hay nada de eso.";
              };
          27: "Las palabras se te agolpan en los labios.";
          38: switch (random(5)) {
                1: "¿Qué quieres decir con eso?";
                2: "Lo siento, no te entiendo.";
                3: "Intenta ser un poco más preciso.";
                4: "No comprendo eso que dices.";
                5: "¿Qué intentas decir?";
              }
          39: ! Cuando el jugador intenta llevar a cabo una acción usando una
              ! palabra que está en la lista de nombres de la localidad actual:
              switch (action_to_be) {
                ##Examine:  PrintOrRun(location, description);
                ##Enter:    "Ya estás aquí.";
                ##SalirPor: <<Exit>>; ! SALIR DEL PASILLO estando en el pasillo
                default:    "Debes ser más específico.";
              }
              rtrue;
        }
    ];


! Hay que definirla antes de incluir Moviles_NG:
Class Lugar
!  class LugarConRastro
  with
    sgw_mus 0,              ! Música de fondo en la localidad
    sgw_vol VOLUMEN_FONDO,  ! Volumen de la música de fondo
    sgw_img Oscuridad_jpg,  ! Imagen gráfica de la localidad
    describe [;
      PrintOrRun(self, description);
      if (mostrarSalidas) {
        new_line;
        glk_set_style(style_Emphasized);
        <Salidas>;
        glk_set_style(style_Normal);
        rtrue;
      }
    ],
    number,                           ! Necesario en varias librerías
    dibujado false,                   ! Necesario para Mapeador.h
    before [
      l r;
      l = LugarReal();

      ! Cuando se usa "EXAMINA EL PASILLO":
      Examine:
        if (noun ofclass Lugar) {
          r = ConexionLocalidad(noun);
          if (r) <<Examine r>>;
        }

      ! Cuando se usa "VE AL PASILLO":
      Enter, SalirA:
        if (noun ofclass Lugar) {
          r = ConexionLocalidad(noun);
          if (r) <<Go r>>;
        }
        
      GetOff:
        if (noun == LugarReal()) <<Exit>>;
        rfalse;
    ],
    after [;
      Go:
        ! Si se está mostrando la imagen de un personaje, quitarla antes:
        timer_imagen_personaje.ocultar_imagen();
        SGW_MarcoDeTrabajo(1);
    ],
  has
    scenery light;
    

#ifdef DEBUG;
! En modo depuración podemos saltarnos la espera pulsando una tecla:
[ WaitDelay delay;
  return KeyDelay(delay);
];
#endif;


Include "elcirculo.bli";    ! Los recursos multimedia de la aventura
Include "SGW+DMX_NG";       ! Entre Parser y VerbLib
Include "BetaTest";         ! Modo betatesting

Include "VerbLib";

Include "Contenedor";       ! Contenedores
Include "Decorado_NG";      ! Objetos de decorado
Include "Diary";            ! Un diario autorellenable durante el juego
Include "EscenarioAbrible"; ! Escenario que se puede abrir y cerrar
Include "Etemas";           ! Los temas de conversación
!Include "EventList_NG";     ! Listas de mensajes
!Include "ExaminarFalso";    ! Poder examinar objetos sólo con su nombre
Include "GlulxBox";         ! Usar el comando box con Glulx - gracias a Eliuk
Include "Gtalk_NG";         ! Conversaciones con personajes
Include "IntNombre_NG";     ! Poder usar adjetivos como en InformATE
Include "Moviles_NG";       ! La librería Moviles retocada por mí
Include "Pistas";           ! Las pistas creadas con ZIPI
Include "PNJpuertas_NG";    ! La librería PnjPuertas retocada por mí (muy poco)
Include "PNJactor_NG";      ! Librerías que hacen que un PNJ pueda coger y dejar
Include "PNJacciones_NG";   ! Poner detrás de Moviles, PNJpuertas y PNJactor
Include "Prand_NG";         ! Listas de mensajes
!Include "Teletipo";         ! Teletipo para sacar mensajes letra a letra
Include "Timer";            ! Mi librería de eventos temporizados


!===============================================================================
! (4) Rutinas Initialise() e IniciarAventura()
!-------------------------------------------------------------------------------


[ Initialise
  r v menu;
  if (ExisteAutoSave()) menu = ZIPI_Menu_Principal_Con_AutoLoad;
  else                  menu = ZIPI_Menu_Principal;
  IniciarGraficosSonidos();
  ExtenderVentanaEstado();
  ! En el ordenador del Instituto (un equipo ya antiguo, con Ubuntu 12.04 LTS,
  ! gráfica Intel y pantalla a 1024x768), a veces no funcionaba bien la rutina
  ! ExtenderVentanaEstado(). No sé por qué, pero, por alguna razón, a veces
  ! acabas teniendo 18 líneas, a veces 25 y a veces 1. Sólo me ha pasado en
  ! ese ordenador. Lo curioso es que con el KeyDelay(1) se arregla:
  KeyDelay(1);
  viewImageCenter(Logo_Circulo_Con_Letras_jpg);
  v = Damusix.QueVolumenCanal(CANAL_FONDO);
  Damusix.AsignarCanal(Darkwalk_ogg, CANAL_FONDO, v, SONIDO_REPETIR);
  Damusix.Tocar(Darkwalk_ogg);
  do {
    r = ZIPI_RunMenu(menu, 2);
  } until (r ~= 3);
  if (r ~= 2) quit;
  clearTextWindow();
  closeAllWindows();
  glk_window_close(gg_statuswin, 0);
  gg_statuswin = glk_window_open(gg_mainwin,
                                 winmethod_Above + winmethod_Fixed +
                                 winmethod_NoBorder,
                                 1, wintype_TextGrid, GG_STATUSWIN_ROCK);
  if (hayGraficos) EncenderGraficos();

  ! Los eventos hay que iniciarlos aquí, y no en IniciarAventura
  ! (no sé por qué, pero si lo pones en IniciarAventura, no funciona):
  glk_request_hyperlink_event(gg_mainwin);
  glk_request_hyperlink_event(gg_statuswin);
];


[ IniciarAventura logo;

  ! Cambiamos el layout de la pantalla de LAYOUT_MENU_PRINCIPAL a LAYOUT_JUEGO:
  layoutPantalla = LAYOUT_JUEGO;

!  location = thedark;
!  dibujarEstado = false;

  ! Esto es para que el juego dé siempre la descripción de la habitación, aunque
  ! ya la hayamos visitado
  lookmode = 2;

  ! Inventario en una sola frase:
  inventory_style = ENGLISH_BIT + RECURSE_BIT + FULLINV_BIT;

  ! Parseado estricto (de la librería IntNombre):
  parseado_estricto = 1;

  ! Nombre de la oscuridad
  thedark.short_name = "Oscuridad";
  
  ! Localización donde comienza el jugador
  location = cuarto_katie;

!  AsignarPersona(PRIMERA_PERSONA + PERSONA_SINGULAR);
!  give player female;

!  clearTextWindow();

  if (logo) {
    clearTextWindow();
    clearGraphicWindow();
!    DibujaLogoAlien();
  }

  timer_telefono_katie.AsignarGestor(1);
  timer_becca.AsignarGestor(2);
  timer_imagen_localidad.AgregarGestorAlFinal();
  ControlTimer.ActivarTick(TIMER_TICK);

  PNJ_Ruta(becca, MOVIMIENTO_PERSEGUIR, katie);

  ChangePlayer(katie);

  IniciarMoviles();  ! Inicia los móviles
  IniciarPuertas();  ! Inicia las puertas
!  IniciarRastros(); ! Inicia los rastros
  RegistraTodo();    ! Registra los sonidos

  Damusix.PararCanal(CANAL_FONDO);
  Damusix.LiberarCanal(DarkWalk_ogg);
  Damusix.VolumenCanal(CANAL_FONDO, VOLUMEN_FONDO);
  sonido_telefono_katie.sonar();
  KeyDelay();
];


!===============================================================================
! (5) Rutinas de la Libreria Implementadas, Reemplazadas o Ampliadas
!-------------------------------------------------------------------------------


! La pregunta del final del luego, ahora usando el menú de acciones:
[ AfterGameOver
  i;

  .RRQPL;

    L__M(##Miscellany,5);

  .RRQL;

    #Ifdef TARGET_ZCODE;
    #IfV3; read buffer parse; #Endif; ! V3
    temp_global=0;
    #IfV5; read buffer parse DrawStatusLine; #Endif; ! V5
    #Ifnot; ! TARGET_GLULX
    i = Menu_AfterGameOver.Qselect(1);
    #Endif; ! TARGET_
    if (i == QUIT1__WD or QUIT2__WD) {
        #Ifdef TARGET_ZCODE;
        quit;
        #Ifnot; ! TARGET_GLULX
        quit;
        #Endif; ! TARGET_
    }
    if (i == RESTART__WD) {
        #Ifdef TARGET_ZCODE;
        @restart;
        #Ifnot; ! TARGET_GLULX
        @restart;
        #Endif; ! TARGET_
    }
    if (i == RESTORE__WD) {
        RestoreSub();
        jump RRQPL;
    }
    if (i == FULLSCORE1__WD or FULLSCORE2__WD && TASKS_PROVIDED==0) {
        new_line; FullScoreSub();
        jump RRQPL;
    }
    if (deadflag == 2 && i == AMUSING__WD && AMUSING_PROVIDED==0) {
        new_line; Amusing();
        jump RRQPL;
    }
    #IfV5;
    if (i == UNDO1__WD or UNDO2__WD or UNDO3__WD) {
        if (undo_flag == 0) {
            L__M(##Miscellany, 6);
            jump RRQPL;
        }
        if (undo_flag == 1) jump UndoFailed2;
        #Ifdef TARGET_ZCODE;
        @restore_undo i;
        #Ifnot; ! TARGET_GLULX
        @restoreundo i;
        i = (~~i);
        #Endif; ! TARGET_
        if (i == 0) {
          .UndoFailed2;
            L__M(##Miscellany, 7);
        }
        jump RRQPL;
    }
    #Endif; ! V5
    L__M(##Miscellany, 8);
    jump RRQL;
];


[ AfterPrompt;
  ! Pasándole el parámetro 3 en lugar de 1, lo que hacemos es pedirle que
  ! actualice la música pero no los gráficos:
  if (timer_imagen_personaje.mostrandose()) SGW_MarcoDeTrabajo(3);
  else                                      SGW_MarcoDeTrabajo(1);
];


! Modificado para que al empujar un objeto a una localidad se muestre
! más información:
[ AllowPushDir
  i tmp;
  if (parent(second) ~= compass) return L__M(##PushDir, 2, noun);
  if (second == u_obj or d_obj)  return L__M(##PushDir, 3, noun);
  AfterRoutines(); i = noun; move i to player;
  tmp = location;                                     ! (c) Alpha
  estoyEmpujando = true;                              ! (c) Alpha
  <Go second>;
  estoyEmpujando = false;                             ! (c) Alpha
  if (location == thedark) move i to real_location;
  else                     move i to location;
  if (tmp ~= location && location ~= thedark)
    PrintOrRun(i, describe);                          ! (c) Alpha
];


[ Amusing;
  rfalse;
];


[ DrawStatusLine
  pos;
  if (gg_statuswin == 0) rfalse;
  glk_set_window(gg_statuswin);
  StatusLineHeight(1);
  glk_window_clear(gg_statuswin);
  glk_window_move_cursor(gg_statuswin, 0, 0);
  glk_set_style(style_SubHeader);
  glk_set_hyperlink(Menu_Importantes);
  print "Menú";
  glk_set_hyperlink(0);
  print " | ";
  glk_set_hyperlink(location);
  print (name) location;
  glk_set_hyperlink(0);
  if (turns < 10)         pos = 1;
  else if (turns < 100)   pos = 2;
  else if (turns < 1000)  pos = 3;
  else if (turns < 10000) pos = 4;
  else                    pos = 5;
  glk_window_get_size(gg_statuswin, gg_arguments,
                      gg_arguments + WORDSIZE);
  pos = gg_arguments-->0 - pos - 10;
  glk_window_move_cursor(gg_statuswin, pos, 0);
  print "| Turnos: ", turns;
  glk_set_window(gg_mainwin);
];


[ PonerLugarAlAlcance actual dir
  dest;
  dest = actual.dir;
  if (dest ofclass Lugar) PlaceInScope(dest);
  else if (dest has door && dest has open) PlaceInScope(dest.dir);
];


[ InScope actor
  l;

  l = LugarReal();

  ! Así podemos examinar la localidad actual simplemente tecleando su nombre:
  if (action_to_be == ##ExaminarFalso) PlaceInScope(l);

  ! Así podemos usar "VE AL SALON" y "EXAMINA EL SALON" en lugar de
  ! "VE AL SUR" y "EXAMINA EL SUR" (ver también la clase Lugar): 
  if (l provides n_to)   PonerLugarAlAlcance(l, n_to);
  if (l provides s_to)   PonerLugarAlAlcance(l, s_to);
  if (l provides e_to)   PonerLugarAlAlcance(l, e_to);
  if (l provides w_to)   PonerLugarAlAlcance(l, w_to);
  if (l provides ne_to)  PonerLugarAlAlcance(l, ne_to);
  if (l provides nw_to)  PonerLugarAlAlcance(l, nw_to);
  if (l provides se_to)  PonerLugarAlAlcance(l, se_to);
  if (l provides sw_to)  PonerLugarAlAlcance(l, sw_to);
  if (l provides u_to)   PonerLugarAlAlcance(l, u_to);
  if (l provides d_to)   PonerLugarAlAlcance(l, d_to);
  if (l provides in_to)  PonerLugarAlAlcance(l, in_to);
  if (l provides out_to) PonerLugarAlAlcance(l, out_to);

  ! Así le podemos pedir a Becca que coja el teléfono aunque el teléfono no
  ! esté presente:
  if (actor == becca && LugarReal() ~= cocina_katie) {
    PlaceInScope(telefono_katie);
  }
  
  rfalse;
];


! Esta versión no muestra los puntos cardinales y representa las direcciones
! como los nombres de los lugares a los que se llega por esa dirección:
[ LanguageDirection d
  l par dest puerta;
  par = true;
  switch (d) {
    n_to:    par = false; ! print "al norte";
    s_to:    par = false; ! print "al sur";
    e_to:    par = false; ! print "al este";
    w_to:    par = false; ! print "al oeste";
    ne_to:   par = false; ! print "al nordeste";
    nw_to:   par = false; ! print "al noroeste";
    se_to:   par = false; ! print "al sudeste";
    sw_to:   par = false; ! print "al suroeste";
    u_to:    glk_set_hyperlink(u_obj);   print "arriba"; glk_set_hyperlink(0);
    d_to:    glk_set_hyperlink(d_obj);   print "abajo";  glk_set_hyperlink(0);
    in_to:   glk_set_hyperlink(in_obj);  print "dentro"; glk_set_hyperlink(0);
    out_to:  glk_set_hyperlink(out_obj); print "fuera";  glk_set_hyperlink(0);
    default: return RunTimeError(9, d);
  }
  l = LugarReal();
  print " ";
  if (par) print "(";
  dest = l.d;
  if (dest has door && dest has open) {
    puerta = dest;
    dest = dest.d;
    MostrarNombreLink(dest);
    print ", por ";
    MostrarNombreLink(puerta);
  } else {
    MostrarNombreLink(dest);
  }
  if (par) print ")";
];


! Desactiva los modos breve y superbreve:
[ LMode1Sub;
   print_ret (s_emph) "[Modo deshabilitado.]";
];


[ LMode3Sub;
   print_ret (s_emph) "[Modo deshabilitado.]";
];


! Modificado para que ponga hipervínculos automáticamente:
[ PSN__ o
  ret vi;
  if (o == 0) { print (string) NOTHING__TX; rtrue; }
  switch (metaclass(o)) {
    Routine:  print "<routine ", o, ">"; rtrue;
    String:   print "<string ~", (string) o, "~>"; rtrue;
    nothing:  print "<illegal object number ", o, ">"; rtrue;
  }
  if (o == player) { print (string) YOURSELF__TX; rtrue; }
  #Ifdef LanguagePrintShortName;
  if (LanguagePrintShortName(o)) rtrue;
  #Endif; ! LanguagePrintShortName
  if (indef_mode && o.&short_name_indef ~= 0 &&
      PrintOrRun(o, short_name_indef, 1) ~= 0) rtrue;
  vi = o ofclass VerboIrregular;
  if (~~vi) glk_set_hyperlink(o);
  if (o.&short_name ~= 0) {
    ret = PrintOrRun(o, short_name, 1);
    if (ret ~= 0) {
      if (~~vi) glk_set_hyperlink(0);
      rtrue;
    }
  }
  print (object) o;
  if (~~vi) glk_set_hyperlink(0);
];


! Modificado para que ?, !, ¿, ¡ se separen de las palabras al parsear:
[ QuitarAcentos buf pars x i word at len;
  Tokenise__(buf, pars);
  for (x = 1: x <= tokenCount(pars): x++) { ! para cada token
    word = tokenDict(pars,x); ! dictionary value of token 1,2,3...
    at   = tokenPos(pars,x);  ! position in buffer of token 1,2,3...
    len  = WordLength(x);     ! length in chars of token 1,2,3...

    if (word == 0) { ! no comprendida
      for (i = at: i < at + len: i++)
        switch (buf->i) {
          'á', 'à', 'ä', 'â': buf->i = 'a';
          'é', 'è', 'ë', 'ê': buf->i = 'e';
          'í', 'ì', 'ï', 'î': buf->i = 'i';
          'ó', 'ò', 'ö', 'ô': buf->i = 'o';
          'ú', 'ù', 'ü', 'û': buf->i = 'u';
          'ñ': buf->i = 'n';
          'ç': buf->i = 'c';
          '?': buf->i = ' ';
          '¿': buf->i = ' ';
          '!': buf->i = ' ';
          '¡': buf->i = ' ' ;
        }
      Tokenise__(buf, pars);
    }
  }
];


[ QuitSub
  res fref;
.Inicio;
  print "¿Realmente quieres abandonar el juego? ";
  if (YesOrNo() ~= 0) {
    print (s_input) " Sí^";
    if (~~autoguardador.se_ha_guardado) {
      print "¿Deseas guardar la partida antes de salir? ";
      if (YesOrNo() ~= 0) {
        print (s_input) "Sí^";
        fref = glk($0062, $01, $01, 0); ! fileref_create_by_prompt
        if (fref == 0) jump SFailed;
        gg_savestr = glk($0042, fref, $01, GG_SAVESTR_ROCK); ! stream_open_file
        glk($0063, fref); ! fileref_destroy
        if (gg_savestr == 0) jump SFailed;
        @save gg_savestr res;
        if (res == -1) {
          ! The player actually just typed "restore". We're going to print
          !  L__M(##Restore,2); the Z-Code Inform library does this correctly
          ! now. But first, we have to recover all the Glk objects; the values
          ! in our global variables are all wrong.
          GGRecoverObjects();
          glk($0044, gg_savestr, 0); ! stream_close
          gg_savestr = 0;
          return L__M(##Restore, 2);
        }
        glk($0044, gg_savestr, 0); ! stream_close
        gg_savestr = 0;
        if (res == 0) jump Salir;
      .SFailed;
        L__M(##Save, 1); new_line;
        jump Inicio;
      }
    }
  .Salir;
    quit;
  } else {
    print (s_input) "No";
  }
  new_line;
];


[ RestartSub
  fref res;
.Inicio;
  print "¿Realmente quieres reiniciar el juego? ";
  if (YesOrNo() ~= 0) {
    print (s_input) " Sí^";
    if (~~autoguardador.se_ha_guardado) {
      print "¿Deseas guardar la partida antes de reiniciar? ";
      if (YesOrNo() ~= 0) {
        print (s_input) "Sí^";
        fref = glk($0062, $01, $01, 0); ! fileref_create_by_prompt
        if (fref == 0) jump SFailed;
        gg_savestr = glk($0042, fref, $01, GG_SAVESTR_ROCK); ! stream_open_file
        glk($0063, fref); ! fileref_destroy
        if (gg_savestr == 0) jump SFailed;
        @save gg_savestr res;
        if (res == -1) {
          ! The player actually just typed "restore". We're going to print
          !  L__M(##Restore,2); the Z-Code Inform library does this correctly
          ! now. But first, we have to recover all the Glk objects; the values
          ! in our global variables are all wrong.
          GGRecoverObjects();
          glk($0044, gg_savestr, 0); ! stream_close
          gg_savestr = 0;
          return L__M(##Restore, 2);
        }
        glk($0044, gg_savestr, 0); ! stream_close
        gg_savestr = 0;
        if (res == 0) jump Salir;
      .SFailed;
        L__M(##Save, 1); new_line;
        jump Inicio;
      }
    }
  .Salir;
    @restart;
    print "Error: no se ha podido reiniciar el juego";
  } else {
    print (s_input) "No";
  }
  new_line;
];


! Modificado para que no ponga un borde debajo de la línea de estado:
[ StatusLineHeight hgt parwin;
  if (gg_statuswin == 0) return;
  parwin = glk($0029, gg_statuswin); ! window_get_parent
  glk($0026, parwin, $112, hgt, 0); ! window_set_arrangement
  gg_statuswin_cursize = hgt;
];


! Para el Examinar Falso:
[ UnknownVerb;
  verb_wordnum = 0;
  return 'no.verb';
];


! La pregunta de "sí o no" usa ahora el menú de acciones:
[ YesOrNo
  r;
  r = Menu_YesOrNo.Qselect(1);
  return r == 1;
];


!===============================================================================
! (6) Incluir SpanishG.h; Otros Includes
!-------------------------------------------------------------------------------


Include "SpanishG";

Include "random";          ! Cambia la función random()
Include "Mapeador";
Include "TestMachine_NG";  ! El comprobador automático (c) Alien soft
Include "Sonidos_NG";


!===============================================================================
! (7) Clases del Juego
!-------------------------------------------------------------------------------


Class Destino
  with
    nombre_destino 0,
    before [;
      Go:
        coche_rachel.volver = location;
    ];


Class Personaje
  class Movil
  with
    imagen 0, ! La imagen asociada al personaje; se muestra al examinarlo
    dice_rand [ _vararg_count
      a;
      self.dice_inicio();
      @call prand _vararg_count a;
      self.dice_fin();
      return a;
    ],
    dice_once [ _vararg_count
      a;
      self.dice_inicio();
      @call prandonce _vararg_count a;
      self.dice_fin();
      return a;
    ],
    dice_last [ _vararg_count
      a;
      self.dice_inicio();
      @call prandlast _vararg_count a;
      self.dice_fin();
      return a;
    ],
    dice_seq [ _vararg_count
      a;
      self.dice_inicio();
      @call prandseq _vararg_count a;
      self.dice_fin();
      return a;
    ],
    dice [ _vararg_count
      msg nl hablado;
      self.dice_inicio();
      for ( : _vararg_count > 0: _vararg_count--) {
        @copy sp msg;
        if (msg ofclass String) {
          if (hablado) {          
            switch (self.dice_retardo) {
              -1:
               0: KeyDelay();
               default: WaitDelay(self.dice_retardo);
            }
          }
          ! print (string) msg;
          PrintAnything(msg);
          hablado = true;
        } else {
          nl = msg;
        }
      }
      self.dice_fin(nl);
      rtrue;
    ],
    dice_retardo -1,
    dice_inicio [;
      print "^---";
      glk_set_style(style_User1);
      glk_set_hyperlink(self);
      if (self == player) print "Tú: ";
      else                print (string) self.short_name, ": ";
      glk_set_hyperlink(0);
      glk_set_style(style_Normal);
      print "@<<";
    ],
    dice_fin [ nl;
      print "@>>";
      if (~~nl) new_line;
    ],
    marcha [ dir;
      print "^", (link) self, " ";
      if (dir == in_obj)       print "entra en ";
      else if (dir == out_obj) print "sale por ";
      else                     print "se marcha ";
      print (DirDada) dir, ".^";
    ],
    llega [ dir;
      print "^", (link) self, " ";
      if (self.tipo_de_movimiento == MOVIMIENTO_PERSEGUIR) {
        if (self.perseguido == player) {
          print "te sigue";
        } else {
          print "sigue ", (al) self.perseguido;
        }
      } else {
        print "llega";
      }
      if (dir ~= NULL) {
        print " desde ";
        MostrarNombreLink(LugarReal().(dir.door_dir));
        print ".^";
      }
    ],
    mostrar_imagen [;
      if (self.imagen == 0) rfalse;
      ! Ocultamos antes la imagen en caso de que ya estuviera:
      timer_imagen_personaje.ocultar_imagen();
      viewImageCenter(self.imagen);
      timer_imagen_personaje.AgregarGestorAlFinal();
      timer_imagen_localidad.DesactivarGestor();
      give timer_imagen_personaje general;
    ],
    after [;
      Examine:
        self.mostrar_imagen();
    ],
    life [;
      Tell, Answer:
        if (actor ~= player) <<Ask actor>>;
    ],
    orders [;
      NotUnderstood:
        if (actor ~= player) <<Ask actor>>;
    ],
    ! Nosotros usaremos Qselect en lugar de select, para que funcione con el
    ! testeador automático:
    Qselect [ q
      old_pie;
      old_pie = parse_input_externo;
      if (parse_input_externo == -1) parse_input_externo = 1;
      ControlTimer.PausarTick();
      self.select(q);
      ControlTimer.ReanudarTick();
      glk_set_window(gg_mainwin);
      glk_window_noscroll(gg_mainwin);
      glk_window_close(gg_conversawin, 0);
      gg_conversawin = 0;
      parse_input_externo = old_pie;
    ],
  has
    animate proper;

    
!===============================================================================
! (8) Objetos del Juego
!-------------------------------------------------------------------------------


! ====================================================================
! OBJETOS DE SOPORTE
! ====================================================================


! Objeto necesario para que no haya errores al compilar si no hay objetos
! definidos con ciertas propiedades:
Object
  with
    nombre_si_visitado NULL,
    nombre_no_visitado NULL,
    nombre_direccion   NULL,
    del_nombre_link    NULL,
    ! Esta rutina no se usa. Sólo la pongo para evitar un warning, ya que la
    ! rutina VozLejana() de la librería de Sonidos no se usa:
    dummy [;
      VozLejana("dummy");
    ];


Object autoguardador
  with
    found_in [; return self.activado; ],
    activar [;
      give self ~absent;
      move self to location;
      self.activado = true;
    ],
    desactivar [;
      remove self;
      give self absent;
      self.activado = false;
    ],
    activado true,
    se_ha_guardado false,
    each_turn [;
      if (self.found_in()) {
        if (~~(AutoSave())) {
          print "^No se ha podido guardar la partida automáticamente. Se
                 deshabilitará el guardado automático.^";
          self.desactivar();
        } else {
          self.se_ha_guardado = true;
        }
      }
    ],
  has
    concealed;


Object testigo
  class Movil;


Object timer_imagen_personaje
  class GestorTimer
  with
    duracion TIMER_DURACION_IMAGEN_PERSONAJE,
    mostrandose [;
      return self has general;
    ],
    ocultar_imagen [;
      if (self.mostrandose()) self.evento();
    ],
    evento [;
      give self ~general;
      self.EliminarGestor();
      timer_imagen_localidad.ActivarGestor();
      !MostrarImagenLocalidad();
    ];


Object timer_imagen_localidad
  class GestorTimer
  with
    duracion TIMER_DURACION_IMAGEN_LOCALIDAD,
    px 0,
    py 0,
    deltax -1,
    deltay -1,
    condicion [;
      return location provides sgw_img && gg_bigwin;
    ],
    evento [
      img img_w img_h win_w win_h;
      img = location.sgw_img;
      glk_image_get_info(img, gg_arguments, gg_arguments + WORDSIZE);
      img_w = gg_arguments-->0;
      img_h = gg_arguments-->1;
      glk_window_get_size(gg_bigwin, gg_arguments, gg_arguments + WORDSIZE);
      win_w = (gg_arguments-->0);
      win_h = (gg_arguments-->1);
      if (img_w > win_w) {
        if (self.deltax == -1) {
          if (self.px + img_w < win_w) {
            self.deltax = 1;
          }
        } else {
          if (self.px == 0) {
            self.deltax = -1;
          }
        }
      } else {
        self.deltax = 0;
      }
      if (img_h > win_h) {
        if (self.deltay == -1) {
          if (self.py + img_h < win_h) {
            self.deltay = 1;
          }
        } else {
          if (self.py == 0) {
            self.deltay = -1;
          }
        }
      } else {
        self.deltay = 0;
      }
      glk_window_clear(gg_bigwin);
      glk_image_draw(gg_bigwin, location.sgw_img, self.px, self.py);
      self.px = self.px + self.deltax;
      self.py = self.py + self.deltay;
    ];


! ====================================================================
! MENÚS ZIPI
! ====================================================================


[ ZIPI_PintaTitulo titulo anchura altura;
  ZIPI_clrscr();
  #ifdef TARGET_ZCODE;
  @split_window 1;
  #endif;
  ZIPI_setwindow();
  ZIPI_bold();
  ZIPI_setcursor(anchura, 1 + altura);
  PrintOrRunVar(titulo, 1);
  ZIPI_roman();
];


[ ZIPI_RunMenu _m top
  i j count cur key dest r tec iniciox inicioy anchura altura max long;

  cur = 0;
  count = _m.#ZIPI_item / WORDSIZE; count = count + 2;

  for (::) {
    glk_window_get_size(gg_statuswin, gg_arguments, gg_arguments + WORDSIZE);
    anchura = gg_arguments-->0;
    altura  = gg_arguments-->1;
    if (_m provides ZIPI_anchura) {
      max = _m.ZIPI_anchura;
    } else {
      max = 0;
      for (i = 0 : i < count - 2 : i++) {
        long = PrintAnyToArray(buffer + WORDSIZE,
                               INPUT_BUFFER_LEN - WORDSIZE,
                               _m.&ZIPI_item-->i, ZIPI_titulo);
        if (long > max) max = long;
      }
    }
    iniciox = (anchura / 2) - (max / 2);
    if ((top == 2) || (layoutPantalla == LAYOUT_MENU_PRINCIPAL)) {
      inicioy = 0;
    } else {
      inicioy = (gg_arguments-->1 / 2) - (count / 2);
    }

    ZIPI_PintaTitulo(_m.ZIPI_titulo, iniciox, inicioy);

    if (_m == ZIPI_Configuracion) {
      glk_set_style(style_Header);
      ZIPI_setcursor(1, inicioy + 11); print "|";
      ZIPI_setcursor(1, inicioy + 12); print "|";
      ZIPI_setcursor(anchura, inicioy + 11); print "|";
      ZIPI_setcursor(anchura, inicioy + 12); print "|";
      glk_set_style(style_Normal);
    }

    for (i = 0, tec = 0 : i < count - 2 : i++) {
      dest = _m.&ZIPI_item-->i;
      j = i + 3 + inicioy;
      ZIPI_setcursor(3 + iniciox, j);
      if (dest ~= ZIPI_Separador) {
        glk_set_hyperlink(teclasOpciones->tec);
        print "[";
        glk_set_style(style_Header);
        print (char) teclasOpciones->tec;
        glk_set_style(style_Normal);
        print "] ";
        numeroOpciones->tec = i;
        tec++;
        PrintOrRun(_m.&ZIPI_item-->i, ZIPI_titulo);
        glk_set_hyperlink(0);
      }
    }

    j = i + 4 + inicioy;
    ZIPI_setcursor(3 + iniciox, j);
    glk_set_hyperlink('Q');
    if (top) print (s_head) "[Q] Salir";
    else     print (s_head) "[Q] Volver";
    glk_set_hyperlink(0);

    dest = _m.&ZIPI_item-->cur;

    if (cur == count - 1) {
      ZIPI_setcursor((anchura / 2) - 10, altura);
      if (top) print (string) "Salir de la aventura";
      else     print (string) "Volver al menú anterior";
    } else if (cur < count - 2 && dest provides ZIPI_informacion) {
      long = PrintAnyToArray(buffer + WORDSIZE,
                             INPUT_BUFFER_LEN - WORDSIZE,
                             dest, ZIPI_informacion);
      ZIPI_setcursor((anchura / 2) - (long / 2), altura);
      PrintAnything(dest, ZIPI_informacion);
    }

    j = cur + 3 + inicioy;
    ZIPI_setcursor(iniciox, j);
    print (s_emph) ">";
    ZIPI_setcursor(iniciox, j);

    key = ZIPI_tecla(gg_statuswin);

    print " ";

    switch (key) {
      'k', 'K', 'p', 'P', '-', '_', 129, -4:
        do {
          cur--;
          if (cur == count - 2) cur--;
          if (cur < 0) cur = count - 1;
        } until ((_m.&ZIPI_item-->cur) ~= ZIPI_Separador);

      'j', 'J', 'n', 'N', '=', '+', 130, -5:
        do {
          cur++;
          if (cur == count - 2) cur++;
          if (cur >= count) cur = 0;
        } until ((_m.&ZIPI_item-->cur) ~= ZIPI_Separador);

      'q', 'Q', 27, 131, 10, 8, -2, keycode_Escape:
        rfalse;
 
      132, 13, ' ', -3, -6:
    .Aceptar;
        if (cur == count - 1) rfalse;
        if (cur == count - 2) break;
        dest = _m.&ZIPI_item-->cur;
        if (dest ofclass ZIPI_Menu)          ZIPI_RunMenu(dest);
        else if (dest ofclass ZIPI_Pista)    ZIPI_RunPista(dest);
        else if (dest provides ZIPI_cambiar) dest.ZIPI_cambiar();
        else {
          glk_request_mouse_event(gg_statuswin);
          r = ZIPI_RunOtro(dest);
          glk_cancel_mouse_event(gg_statuswin);
          if (dest == ZIPI_Restaurar) return 3;
          if (r == 2) return r;
        }
    }

    ! Busca la tecla entre el vector
    for (i = 0 : i < MAXIMO_TECLAS_OPCIONES : i++) {
      if (key == (teclasOpciones->i) && i < tec) {
        cur = numeroOpciones->i;
        key = 132;
        jump Aceptar;
      }
    }
  }
  rfalse;
];


[ ZIPI_RunOtro _o
  r gr;
  gr = gg_bigwin ~= 0;
  if (gr) closeGraphicWindow();
  ZIPI_PintaTitulo(_o.ZIPI_titulo);
  print "^";
  r = _o.ZIPI_ejecutar();
  if (~~r) ZIPI_Espera();
  if (gr) {
    openGraphicWindow(altoLogoMenu);
    clearGraphicWindow();
    viewImageCenter(Logo_Circulo_Con_Letras_jpg);
  }
  return r;
];


[ ZIPI_tecla win sw
  key done ix gi;

  ! Comienzo del hackeo (c) Alpha
  if (parse_input_externo > 0) {
    glk_set_window(gg_mainwin);
    gi = test_machine.get_input();
    if (win) glk_set_window(win);
    if (gi ~= 0) {
      if (parse_input_externo == 2) parse_input_externo = -1; ! Para gtalk
      return buffer->WORDSIZE;
    }
  }
  if (parse_input_externo == -1) parse_input_externo = 0;
  ! Fin del hackeo (c) Alpha

  if (win) {
    glk_request_hyperlink_event(win);
    if (~~sw) glk_request_mouse_event(win);
  }

  glk_request_char_event(gg_mainwin);

  while (~~done) {
    glk_select(gg_event);
    ix = HandleGlkEvent(gg_event, 1, gg_arguments);
    if (ix == 2) {
      key = gg_arguments-->0;
      done = true;
    } else if (ix >= 0) {
      switch (gg_event-->0) {
        evtype_CharInput:
          key = gg_event-->2;
          done = true;

        evtype_Hyperlink:
          glk_request_hyperlink_event(gg_event-->1);
          ! Si estamos en el menú de acciones y pulsamos de nuevo "Menú",
          ! devolvemos 'Q' para que se cierre el menú (así, pulsando "Menú"
          ! vamos abriendo y cerrando la ventana alternativamente):
          if (win == gg_menuwin && gg_event-->1 == gg_statuswin) {
            key = 'Q';
          } else {
            key = gg_event-->2;
          }
          done = true;

        evtype_MouseInput:
          key = 0; ! Devuelve la tecla 0, para no interferir
          done = true;

        evtype_Arrange, evtype_Redraw:
          DrawStatusLine();     ! Redibujamos la línea de estado
          if (win) glk_set_window(win);  ! Volvemos a la ventana anterior
          ! Cuando se redimensiona habiendo un menú de acciones, se
          ! devuelve la tecla 0, lo que hará que se redibuje la ventana:
          key = 0;
          done = true;
      }
    }
  }

  glk_cancel_char_event(gg_mainwin);

  if (win) {
    glk_request_hyperlink_event(win);
    if (~~sw) glk_request_mouse_event(win);
  }

  return key;
];


Object ZIPI_Aumentar_Ancho_Ventana
  class ZIPI_Otro
  with
    ZIPI_titulo "Aumentar tamaño del área de juego",
    ZIPI_informacion "Aumenta el espacio horizontal que ocupa el juego en la
                      pantalla",
    ZIPI_cambiar [;
      ZIPI_Configuracion.ha_cambiado_algo = true;
      glk_set_config(config_Cols, glk_get_config(config_Cols) + 4);
      ZIPI_Configuracion.guardar_valores();
      RefrescarVentanasTexto();
      ! Esto sólo se ve en el menú principal, porque durante el juego
      ! el menú de configuración ocupa toda la pantalla, y luego
      ! restauramos el gráfico de la localidad actual:
      viewImageCenter(Logo_Circulo_Con_Letras_jpg);
    ];


Object ZIPI_Aumentar_Texto
  class ZIPI_Otro
  with
    ZIPI_titulo "Aumentar tamaño del texto",
    ZIPI_informacion "Aumenta el tamaño del texto mostrado en el juego",
    ZIPI_cambiar [;
      ZIPI_Configuracion.ha_cambiado_algo = true;
      glk_incr_fontsize();
      ZIPI_Configuracion.guardar_valores();
      RefrescarVentanasTexto();
      ! Esto sólo se ve en el menú principal, porque durante el juego
      ! el menú de configuración ocupa toda la pantalla, y luego
      ! restauramos el gráfico de la localidad actual:
      viewImageCenter(Logo_Circulo_Con_Letras_jpg);
    ];


Object ZIPI_AutoSave
  class ZIPI_Otro
  with
    ZIPI_informacion "Activa o desactiva el guardado automático de partidas",
    ZIPI_titulo [;
      if (autoguardador.activado) {
        "Guardar partida automáticamente: SÍ (recomendado)";
      } else {
        "Guardar partida automáticamente: NO";
      }
    ],
    ZIPI_cambiar [;
      if (autoguardador.activado) autoguardador.desactivar();
      else                        autoguardador.activar();
    ];


Object ZIPI_Avanzadas
  class ZIPI_Menu
  with
    ZIPI_titulo "Opciones avanzadas",
    ZIPI_informacion "Cambiar algunas opciones avanzadas que afectan al juego",
    ZIPI_anchura 50,
    ZIPI_item
      ZIPI_Tiempo_Real
      ZIPI_Mostrar_Hyperlinks
      ZIPI_AutoSave
      ZIPI_Reflow;


Object ZIPI_Configuracion
  class ZIPI_Menu
  with
    ZIPI_titulo "Opciones de configuración",
    ZIPI_informacion "Cambiar algunas opciones de configuración del juego",
    ZIPI_anchura 45,
    ha_cambiado_algo false,
    monosize INICIAL_MONOSIZE,
    propsize INICIAL_PROPSIZE,
    leading  INICIAL_LEADING,
    baseline INICIAL_BASELINE,
    cols     INICIAL_COLS,
    reflow   INICIAL_REFLOW,
    guardar_valores [;
      self.monosize = glk_get_config(config_MonoSize);
      self.propsize = glk_get_config(config_PropSize);
      self.leading  = glk_get_config(config_Leading);
      self.baseline = glk_get_config(config_Baseline);
      self.cols     = glk_get_config(config_Cols);
      self.reflow   = glk_get_reflow() == 1;
    ],
    restaurar_valores [;
      glk_set_config(config_MonoSize, self.monosize);
      glk_set_config(config_PropSize, self.propsize);
      glk_set_config(config_Leading,  self.leading);
      glk_set_config(config_Baseline, self.baseline);
      glk_set_config(config_Cols,     self.cols);
      glk_set_reflow(self.reflow);
      RefrescarVentanasTexto();
      MostrarImagenLocalidad();
    ],
    ZIPI_item
      ZIPI_Graficos
      ZIPI_Tamano_Graficos
      ZIPI_Sonido
      ZIPI_Sonido_Fondo
      ZIPI_Separador
      ZIPI_Aumentar_Texto
      ZIPI_Disminuir_Texto
      ZIPI_Separador
      ZIPI_Aumentar_Ancho_Ventana
      ZIPI_Disminuir_Ancho_Ventana
      ZIPI_Separador
      ZIPI_Avanzadas;


Object ZIPI_Continuar_Partida
  class ZIPI_Otro
  with
    ZIPI_titulo "Continuar la partida",
    ZIPI_informacion "Continuar la partida desde donde la habías dejado",
    ZIPI_ejecutar [;
      StatusLineHeight(1);
      clearTextWindow();
      glk_set_window(gg_mainwin);
      AutoLoad();
      glk_set_window(gg_statuswin);
      ExtenderVentanaEstado();
      print "^Error: no se ha podido cargar la partida.";
      rfalse;
    ];


Object ZIPI_Disminuir_Ancho_Ventana
  class ZIPI_Otro
  with
    ZIPI_titulo "Disminuir tamaño del área de juego",
    ZIPI_informacion "Reduce el espacio horizontal que ocupa el juego en la
                      pantalla",
    ZIPI_cambiar [ cols;
      ZIPI_Configuracion.ha_cambiado_algo = true;
      cols = glk_get_config(config_Cols);
      if (cols > INICIAL_COLS) {
        glk_set_config(config_Cols, cols - 4);
        ZIPI_Configuracion.guardar_valores();
        RefrescarVentanasTexto();
        ! Esto sólo se ve en el menú principal, porque durante el juego
        ! el menú de configuración ocupa toda la pantalla, y luego
        ! restauramos el gráfico de la localidad actual:
        viewImageCenter(Logo_Circulo_Con_Letras_jpg);
      }
    ];


Object ZIPI_Disminuir_Texto
  class ZIPI_Otro
  with
    ZIPI_titulo "Disminuir tamaño del texto",
    ZIPI_informacion "Reduce el tamaño del texto mostrado en el juego",
    ZIPI_cambiar [;
      ZIPI_Configuracion.ha_cambiado_algo = true;
      glk_decr_fontsize();
      ZIPI_Configuracion.guardar_valores();
      RefrescarVentanasTexto();
      ! Esto sólo se ve en el menú principal, porque durante el juego
      ! el menú de configuración ocupa toda la pantalla, y luego
      ! restauramos el gráfico de la localidad actual:
      viewImageCenter(Logo_Circulo_Con_Letras_jpg);
    ];


Object ZIPI_Graficos
  class ZIPI_Otro
  with
    ZIPI_informacion "Activa o desactiva los gráficos durante el juego",
    ZIPI_titulo [;
      if (hayGraficos) "Gráficos: SÍ (recomendado)";
      else             "Gráficos: NO";
    ],
    ZIPI_cambiar [;
      ZIPI_Configuracion.ha_cambiado_algo = true;
      hayGraficos = ~~hayGraficos;
    ];


Object ZIPI_Jugar_Con_Intro
  class ZIPI_Otro
  with
    ZIPI_titulo "Comenzar la aventura con introducción",
    ZIPI_informacion "Comienza la aventura desde el principio",
    ZIPI_ejecutar [;
      StatusLineHeight(1);
      glk_window_clear(gg_statuswin);
      glk_set_window(gg_mainwin);
      clearTextWindow();
      if (hayGraficos) EncenderGraficos();
      else             ApagarGraficos();
      Introduccion();
      IniciarAventura();
      return 2;
    ];

    
Object ZIPI_Jugar_Sin_Intro
  class ZIPI_Otro
  with
    ZIPI_titulo "Comenzar la aventura saltando la introducción",
    ZIPI_informacion "Comenzar la aventura directamente sin ver la
                      introducción",
    ZIPI_ejecutar [;
      StatusLineHeight(1);
      glk_window_clear(gg_statuswin);
      glk_set_window(gg_mainwin);
      clearTextWindow();
      if (hayGraficos) EncenderGraficos();
      else             ApagarGraficos();
      IniciarAventura(true);
      return 2;
    ];


Object ZIPI_Menu_Principal
  class ZIPI_Menu
  with
    ZIPI_titulo "EL CÍRCULO - (c) Alpha Aventuras 2012",
    ZIPI_item
      ZIPI_Jugar_Con_Intro
      ZIPI_Jugar_Sin_Intro
      ZIPI_Restaurar_Partida
      ZIPI_Configuracion
      ZIPI_Separador
      ZIPI_Menu1;


Object ZIPI_Menu_Principal_Con_AutoLoad
  class ZIPI_Menu
  with
    ZIPI_titulo "EL CÍRCULO - (c) Alpha Aventuras 2012",
    ZIPI_item
      ZIPI_Continuar_Partida
      ZIPI_Jugar_Con_Intro
      ZIPI_Jugar_Sin_Intro
      ZIPI_Restaurar_Partida
      ZIPI_Configuracion
      ZIPI_Separador
      ZIPI_Menu1;


Object ZIPI_Mostrar_Hyperlinks
  class ZIPI_Otro
  with
    mostrarLink true,
    colorLink COLOR_HYPERLINK,
    ZIPI_titulo [;
      if (self.mostrarLink) "Mostrar hipervínculos: SÍ (recomendado)";
      else                  "Mostrar hipervínculos: NO";
    ],
    ZIPI_informacion "Activa o desactiva el resaltado de hipervínculos en el
                      texto durante el juego",
    restaurar_valores [
      c;
      if (self.mostrarLink) {
        glk_set_config(config_LinkColor, self.colorLink);
      } else {
        self.colorLink = glk_get_config(config_LinkColor);
        c = glk_window_stylehint_get(gg_mainwin, style_Normal,
                                     stylehint_TextColor);
        glk_set_config(config_LinkColor, c);
      }
    ],
    ZIPI_cambiar [;
      self.mostrarLink = ~~(self.mostrarLink);
      self.restaurar_valores();
    ];


Object ZIPI_Restaurar_Partida
  class ZIPI_Otro
  with
    ZIPI_titulo "Restaurar una partida guardada",
    ZIPI_informacion "Cargar una partida guardada con anterioridad",
    ZIPI_ejecutar [ res fref;
      StatusLineHeight(1);
      clearTextWindow();
      glk_set_window(gg_mainwin);
      fref = glk($0062, $01, $02, 0); ! fileref_create_by_prompt
      if (fref == 0) jump RFailed;
      gg_savestr = glk($0042, fref, $02, GG_SAVESTR_ROCK); ! stream_open_file
      glk($0063, fref); ! fileref_destroy
      if (gg_savestr == 0) jump RFailed;

      @restore gg_savestr res;

      glk($0044, gg_savestr, 0); ! stream_close
      gg_savestr = 0;

    .RFailed;
      glk_set_window(gg_statuswin);
      ExtenderVentanaEstado();
      print "^Error: no se ha podido cargar la partida.";
      rfalse;
    ];
      

Object ZIPI_Reflow
  class ZIPI_Otro
  with
    ZIPI_informacion "El recalibrado es más lento pero el texto se muestra de
                      forma más correcta",
    ZIPI_titulo [;
      if (ZIPI_Configuracion.reflow) {
        "Recalibrar pantalla: SÍ (recomendado)";
      } else {
        "Recalibrar pantalla: NO";
      }
    ],
    ZIPI_cambiar [;
      if (ZIPI_Configuracion.reflow) glk_set_reflow(0);
      else                           glk_set_reflow(1);
      ZIPI_Configuracion.guardar_valores();
    ];


Object ZIPI_Salir
  class ZIPI_Otro
  with
    ZIPI_titulo "Salir",
    ZIPI_informacion "Salir del juego y volver al escritorio",
    ZIPI_ejecutar [; quit; ];


Object ZIPI_Sonido
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      if (haySonido) "Sonido global: SÍ (recomendado)";
      else           "Sonido global: NO";
    ],
    ZIPI_informacion "Activar o desactivar el sonido durante el juego",
    ZIPI_cambiar [;
      haySonido = ~~haySonido;
      if (haySonido) Damusix.ActivarAudio();
      else           Damusix.DesactivarAudio();
    ];


Object ZIPI_Sonido_Fondo
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      if (haySonidoFondo) "Sonido de fondo: SÍ (recomendado)";
      else                "Sonido de fondo: NO";
    ],
    ZIPI_informacion "Activar o desactivar únicamente el sonido de fondo",
    ZIPI_cambiar [;
      haySonidoFondo = ~~haySonidoFondo;
      if (haySonidoFondo) Damusix.VolumenCanal(CANAL_FONDO, VOLUMEN_FONDO);
      else                Damusix.VolumenCanal(CANAL_FONDO, 0);
    ];


Object ZIPI_Tamano_Graficos
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      switch (anchoVentanaGrafica) {
        GRAFICOS_MINUSCULOS: "Tamaño de gráficos: ",
                             GRAFICOS_MINUSCULOS, " px. (MINÚSCULOS)";
        GRAFICOS_PEQUENOS:   "Tamaño de gráficos: ",
                             GRAFICOS_PEQUENOS, " px. (PEQUEÑOS)";
        GRAFICOS_MEDIANOS:   "Tamaño de gráficos: ",
                             GRAFICOS_MEDIANOS, " px. (MEDIANOS, recomendado)";
        GRAFICOS_GRANDES:    "Tamaño de gráficos: ",
                             GRAFICOS_GRANDES,  " px. (GRANDES)";
        default:             "Tamaño de gráficos: ",
                             anchoVentanaGrafica, " px.";          
      }
    ],
    ZIPI_informacion "Cambia el tamaño de los gráficos mostrados durante el
                      juego",
    ZIPI_cambiar [;
      ZIPI_Configuracion.ha_cambiado_algo = true;
      if (anchoVentanaGrafica < GRAFICOS_GRANDES)
        anchoVentanaGrafica = anchoVentanaGrafica + 50;
      else
        anchoVentanaGrafica = GRAFICOS_MINUSCULOS;
    ];


Object ZIPI_Tiempo_Real
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      if (hayTiempoReal) "Tiempo real: SÍ (recomendado)";
      else               "Tiempo real: NO";
    ],
    ZIPI_informacion "Activar o desactivar los eventos en tiempo real durante
                      el juego",
    ZIPI_restaurar [;
      if (hayTiempoReal) ControlTimer.ActivarTick(TIMER_TICK);
      else               ControlTimer.DesactivarTick();
    ],
    ZIPI_cambiar [;
      hayTiempoReal = ~~hayTiempoReal;
    ];


! ====================================================================
! MENÚS DE ACCIONES
! ====================================================================


Object MenuAcciones
  with
    acciones_comunes Menu_Examinar Menu_Coger Menu_Dejar Menu_Abrir
                     Menu_Cerrar Menu_AbrirCon Menu_CerrarCon
                     Menu_Encender Menu_Apagar,
    ! El IdentifyGlkObject de la ventana de menús de acciones:
    Menu_IdentifyGlkObject [ fase tipo ref rock;
      if (fase == 0) { ! Poner cero en todos nuestros objetos glk
        gg_menuwin = 0;
        return;
      }
      if (fase == 1) { ! Reiniciar correctamente las variables glk
        switch (tipo) {
          0: ! es una ventana
             switch (rock) {
               GG_MENUWIN_ROCK: gg_menuwin = ref;
             }
          1: ! es un flujo
             ! pero no hay flujos en este ejemplo
          2: ! es una referencia a fichero
             ! pero no hay ficheros en este ejemplo
        }
        return;
      }
      if (fase == 2) { ! Actualizar nuestras ventanas
        if (layoutPantalla == LAYOUT_MENU_PRINCIPAL) {
          if (gg_menuwin) {
            MenuAcciones.CerrarVentana();
          }
        } else { ! layoutPantalla == LAYOUT_JUEGO
          if (gg_menuwin) {
            MenuAcciones.AbrirVentana();
          }
        }
        return;
      }
    ],
    ! Se encarga de mostrar el menú de acciones correctamente, desactivando
    ! previamente los timers y preparando las ventanas antes y después.
    ! Si top == true, no se muestra la opción de "[Q] Salir":
    MostrarAcciones [ obj top
      r;
      if (gg_menuwin == 0) self.AbrirVentana();
      ControlTimer.PausarTick();
      glk_set_window(gg_menuwin);
      glk_cancel_hyperlink_event(gg_mainwin);    ! Durante el menú, desactiva
      glk_cancel_hyperlink_event(gg_statuswin);  ! enlaces de otras ventanas
      r = self.RunMenu(obj, top);
      glk_set_window(gg_mainwin);
      glk_request_hyperlink_event(gg_mainwin);   ! Se vuelven a activar los
      glk_request_hyperlink_event(gg_statuswin); ! enlaces de otras ventanas
      glk_request_hyperlink_event(gg_menuwin);   ! incluyendo la de menú
      ControlTimer.ReanudarTick();
      return r;
    ],
    menu_no_cabe false,
    AbrirVentana [;
      glk_set_reflow(0);
      if (gg_menuwin) glk_window_close(gg_menuwin, 0);
      if (gg_bigwin) {
        gg_menuwin = glk_window_open(gg_bigwin,
                                     winmethod_Left + winmethod_Proportional +
                                     winmethod_NoBorder,
                                     100, wintype_TextGrid,
                                     GG_MENUWIN_ROCK);
        glk_window_get_size(gg_menuwin, gg_arguments,
                            gg_arguments + WORDSIZE);
        if (gg_arguments-->0 < ANCHO_ACCIONES) {
          ! El menú no cabe sobre la ventana gráfica. La cerramos y
          ! abrimos el menú sobre la ventana de texto:
          self.menu_no_cabe = true;
          glk_window_close(gg_menuwin, 0);
          closeGraphicWindow();
          gg_menuwin = glk_window_open(gg_mainwin,
                                       winmethod_Left + winmethod_Fixed +
                                       winmethod_NoBorder,
                                       ANCHO_ACCIONES, wintype_TextGrid,
                                       GG_MENUWIN_ROCK);
        }
      } else {
        gg_menuwin = glk_window_open(gg_mainwin,
                                     winmethod_Left + winmethod_Fixed,
                                     ANCHO_ACCIONES, wintype_TextGrid,
                                     GG_MENUWIN_ROCK);
      }
    ],
    CerrarVentana [;
      glk_window_close(gg_menuwin, 0);
      gg_menuwin = 0;
      DrawStatusLine();
      if (self.menu_no_cabe) {
        self.menu_no_cabe = true;
        EncenderGraficos();
      }
      MostrarImagenLocalidad();
      glk_set_reflow(ZIPI_Configuracion.reflow);
    ],
    ! Muestra el menú de acciones de un objeto:
    RunMenu [ _m top win
      menu size i j count opc cur key dest tec altura anchura delta oldcur;

      ! Si el objeto tiene menú propio, usamos ése. En caso contrario, usamos
      ! el menú de acciones comunes:
      if (_m provides ZIPI_item) {
        menu = _m.&ZIPI_item;
        size = _m.#ZIPI_item / WORDSIZE;
      } else {
        menu = self.&acciones_comunes;
        size = self.#acciones_comunes / WORDSIZE;
      }

      for (i = count = 0 : i < size : i++) {
        opc = menu-->i;
        if (opc == 0) continue;
        if (opc provides ZIPI_condicion && (~~(opc.ZIPI_condicion(_m)))) {
          continue;
        }
        if (count < MAXIMO_OPCIONES) {
          opcionesMenu-->count = opc;
          count++;
        #ifdef DEBUG;
        } else {
          print "*** ERROR: Superado número máximo de opciones del menú ***";
        #endif;
        }
      }

      ! Si sólo hay una opción, y es la de examinar, directamente examinamos:
      if (count == 1 && menu-->0 == Menu_Examinar) return menu-->0;

      if (~~top) {
        opcionesMenu-->count++ = ZIPI_Separador;
        opcionesMenu-->count++ = ZIPI_Ninguna;
      }

      cur = 0;
      if (win == 0) win = gg_menuwin;

      for (::) {
        glk_window_get_size(win, gg_arguments, gg_arguments + WORDSIZE);
        anchura = gg_arguments-->0;
        altura  = gg_arguments-->1;

        glk_window_clear(win);
        glk_window_move_cursor(win, 0, 1);

        if (_m provides ZIPI_titulo) {
          glk_set_style(style_Input);
          print " ", (string) _m.ZIPI_titulo, "^";
          glk_set_style(style_Normal);
        } else {
          glk_set_style(style_Input);
          print " "; MostrarNombre(_m, 2); print ":^";
          glk_set_style(style_Normal);
        }

        if (delta > 0) {
          glk_window_move_cursor(win, anchura - 1, 1);
          print "@@94";
        }

        for (i = 0 + delta, tec = 0 + delta : i < count : i++) {
          j = i + 4 - delta;
          if (j >= altura) break;
          glk_window_move_cursor(win, 3, j - 1);
          opc = opcionesMenu-->i;
          if (opc ~= ZIPI_Separador) {
            if (opc == ZIPI_Ninguna) {
              glk_set_hyperlink('Q');
              print "[", (s_head) "Q", "] ";
            } else {
              glk_set_hyperlink(teclasOpciones->tec);
              print "[";
              glk_set_style(style_Header);
              if (tec < MAXIMO_TECLAS_OPCIONES) {
                print (char) teclasOpciones->tec;
                numeroOpciones->tec = i;
                tec++;
              } else {
                print " ";
              }
              glk_set_style(style_Normal);
              print "] ";
            }
            PrintOrRun(opc, ZIPI_titulo);
            glk_set_hyperlink(0);
          }
        }

        j = i + 5 - delta;

        if (j > altura + top) {
          glk_window_move_cursor(win, anchura - 1, altura - 1);
          print "v";
        }

        glk_set_window(gg_statuswin);
        glk_window_move_cursor(gg_statuswin, 7, 0);
        glk_window_get_size(gg_statuswin, gg_arguments,
                            gg_arguments + WORDSIZE);
        for (i = 7 : i < gg_arguments-->0 : i++) print (string) " ";

        if (cur < count - 2) {
          dest = opcionesMenu-->cur;
          if (dest provides ZIPI_informacion) {
            glk_set_window(gg_statuswin);
            glk_window_move_cursor(gg_statuswin, 7, 0);
            glk_window_get_size(gg_statuswin, gg_arguments,
                                gg_arguments + WORDSIZE);
            for (i = 7 : i < gg_arguments-->0 : i++) {
              print (string) " ";
            }
            glk_window_move_cursor(gg_statuswin, 7, 0);
            PrintAnything(dest, ZIPI_informacion, _m);
          }
        }

        glk_request_hyperlink_event(gg_statuswin);
        glk_set_window(win);

        j = cur + 4 - delta;
        glk_window_move_cursor(win, 1, j - 1);
        print (s_emph) ">";
        glk_window_move_cursor(win, 1, j - 1);

        key = ZIPI_tecla(win, true);

        if (key >= 'a' && key <= 'z') key = key - 32;  ! Pasamos a mayúsculas

        print " ";

        switch (key) {
          'k', 'K', 'p', 'P', '-', '_', 129, -4:
            do {
              oldcur = cur;
              cur--;
              if (cur < 0) cur = 0;
              if (j <= 4) delta = delta - (oldcur - cur);
            } until (opcionesMenu-->cur ~= ZIPI_Separador);

          'j', 'J', 'n', 'N', '=', '+', 130, -5:
            do {
              oldcur = cur;
              cur++;
              if (cur > count - 1) cur = count - 1;
              if (j >= altura - 1) delta = delta + (cur - oldcur);
            } until (opcionesMenu-->cur ~= ZIPI_Separador);

          'q', 'Q', 27, 131, 10, 8, -2, keycode_Escape:
            if (~~top) rfalse;

          132, 13, ' ', -3, -6:
        .Aceptar;
            dest = opcionesMenu-->cur;
            if (dest ofclass ZIPI_Menu) {
              return MenuAcciones.RunMenu(dest, top, win);
            } else if (dest == ZIPI_Ninguna) {
              rfalse;
            } else if (dest ofclass ZIPI_Pista) {
              ZIPI_RunPista(dest);
            } else if (dest provides ZIPI_cambiar) {
              dest.ZIPI_cambiar();
            } else {
              return dest;
            }
        }

        ! Busca la tecla en el vector:
        for (i = 0 : i < MAXIMO_TECLAS_OPCIONES : i++) {
          if (key == (teclasOpciones->i) && i < tec) {
            cur = numeroOpciones->i;
            key = 132;
            jump Aceptar;
          }
        }
      }

      rfalse;
    ];


Object Menu_Abrir
  class ZIPI_Otro
  with
    ZIPI_titulo "Abrir",
    ZIPI_ejecutar [; return 'abre'; ],
    ZIPI_informacion [ obj; print "Abrir ", (the) obj; ],
    ZIPI_condicion [ obj;
      return obj has openable && obj hasnt open;
    ];


Object Menu_AbrirCon
  class ZIPI_Otro
  with
    ZIPI_titulo "Abrir con...",
    ZIPI_informacion [ obj; print "Abrir ", (the) obj, " con algo"; ],
    ZIPI_secundario [; return 'con'; ],
    ZIPI_ejecutar [; return 'abre'; ],
    ZIPI_condicion [ obj;
      return obj has openable && obj hasnt open;
    ],
  has
    general; ! Esto indica que el jugador puede seguir escribiendo el input


Object Menu_Apagar
  class ZIPI_Otro
  with
    ZIPI_titulo "Apagar",
    ZIPI_informacion [ obj; print "Apagar ", (the) obj; ],
    ZIPI_ejecutar [; return 'apaga'; ],
    ZIPI_condicion [ obj;
      return obj has switchable && obj has on;
    ];


Object Menu_Cerrar
  class ZIPI_Otro
  with
    ZIPI_titulo "Cerrar",
    ZIPI_informacion [ obj; print "Cerrar ", (the) obj; ],
    ZIPI_ejecutar [; return 'cierra'; ],
    ZIPI_condicion [ obj;
      return obj has openable && obj has open;
    ];


Object Menu_CerrarCon
  class ZIPI_Otro
  with
    ZIPI_titulo "Cerrar con...",
    ZIPI_informacion [ obj; print "Cerrar ", (the) obj, " con algo"; ],
    ZIPI_secundario [; return 'con'; ],
    ZIPI_ejecutar [; return 'cierra'; ],
    ZIPI_condicion [ obj;
      return obj has openable && obj has open;
    ],
  has
    general; ! Esto indica que el jugador puede seguir escribiendo el input


Object Menu_Coger
  class ZIPI_Otro
  with
    ZIPI_titulo "Coger",
    ZIPI_informacion [ obj; print "Coger ", (the) obj; ],
    ZIPI_ejecutar [; return 'coge'; ],
    ZIPI_condicion [ obj;
      return (obj hasnt static or scenery &&
              (~~IndirectlyContains(player, obj))) &&
              (~~(obj ofclass Personaje));
    ];


Object Menu_Dejar
  class ZIPI_Otro
  with
    ZIPI_titulo "Dejar",
    ZIPI_informacion [ obj; print "Dejar ", (the) obj; ],
    ZIPI_ejecutar [; return 'deja'; ],
    ZIPI_condicion [ obj;
      return obj ~= player && IndirectlyContains(player, obj);
    ];


Object Menu_Encender
  class ZIPI_Otro
  with
    ZIPI_titulo "Encender",
    ZIPI_informacion [ obj; print "Encender ", (the) obj; ],
    ZIPI_ejecutar [; return 'enciende'; ],
    ZIPI_condicion [ obj;
      return obj has switchable && obj hasnt on;
    ];

    
Object Menu_Examinar
  class ZIPI_Otro
  with
    ZIPI_titulo "Examinar",
    ZIPI_informacion [ obj; print "Examinar ", (the) obj; ],
    ZIPI_ejecutar [; return 'ex'; ];


Object ZIPI_Ninguna
  class ZIPI_Otro
  with
    ZIPI_titulo "Ninguna acción";


Object Menu_YesOrNo
  class Conversacion
  with
    quip [ a b;
      switch (a) {
        ! Quip 1: Menú principal
        11: ! No se necesita nombre de quip para el menú principal
        12: ! No se necesita respuesta
        13: qtype = MainMenu;
            qqon = true;
            killz = true;
        14: return Qlist(b, 2, 2, 3);

        ! Quip 2
        21: print "Sí";
        22: self.qoff(2, 3);
        23: qqon = true;

        ! Quip 3
        31: print "No";
        32: self.qoff(2, 3);
        33: qqon = true;
      }
    ],
    Qselect [ q r;
      self.qon(2, 3);
      ControlTimer.PausarTick();
      r = self.select(q, true);
      ControlTimer.ReanudarTick();
      glk_set_window(gg_mainwin);
      glk_window_noscroll(gg_mainwin);
      glk_window_close(gg_conversawin, 0);
      gg_conversawin = 0;
      return r;
    ];


Object Menu_AfterGameOver
  class Conversacion
  with
    quip [ a b;
      switch (a) {
        ! Quip 1: Menú principal
        11: ! No se necesita nombre de quip para el menú principal
        12: ! No se necesita respuesta
        13: qtype = MainMenu;
            qqon = true;
            killz = true;
        14: return Qlist(b, 6, 2, 3, 4, 5, 6, 7);

        ! Quip 2
        21: print "Reiniciar";
        22: return RESTART__WD;
        23: qqon = true;

        ! Quip 3
        31: print "Recuperar";
        32: return RESTORE__WD;
        33: qqon = true;

        ! Quip 4
        41: print "Deshacer";
        42: return UNDO1__WD;
        43:
            #ifdef DEATH_MENTION_UNDO;
            qqon = true;
            #endif;

        ! Quip 5
        51: print "Puntuación";
        52: return FULLSCORE1__WD;
        53: if (TASKS_PROVIDED == 0) qqon = true;

        ! Quip 6
        61: print "Curiosidades";
        62: return AMUSING__WD;
        63: if (deadflag == 2 && AMUSING_PROVIDED == 0) qqon = true;

        ! Quip 7
        71: print "Terminar";
        72: return QUIT1__WD;
        73: qqon = true;
      }
    ],
    Qselect [ q r;
      self.qon(2, 3, 7);
      ControlTimer.PausarTick();
      r = self.select(q, true);
      ControlTimer.ReanudarTick();
      glk_set_window(gg_mainwin);
      glk_window_noscroll(gg_mainwin);
      glk_window_close(gg_conversawin, 0);
      gg_conversawin = 0;
      return r;
    ];


Object Menu_Restart
  class ZIPI_Otro
  with
    ZIPI_titulo "Reiniciar",
    ZIPI_ejecutar [; return RESTART__WD; ];


Object Menu_Restore
  class ZIPI_Otro
  with
    ZIPI_titulo "Recuperar",
   ZIPI_ejecutar [; return RESTORE__WD; ];


Object Menu_Save
  class ZIPI_Otro
  with
    ZIPI_titulo "Guardar",
    ZIPI_ejecutar [; return "guardar"; ];


Object Menu_Undo
  class ZIPI_Otro
  with
    ZIPI_titulo "Deshacer",
    ZIPI_ejecutar [; return UNDO1__WD; ];


Object Menu_Score
  class ZIPI_Otro
  with
    ZIPI_titulo "Puntuación",
    ZIPI_condicion [; return TASKS_PROVIDED == 0; ],
    ZIPI_ejecutar [; return FULLSCORE1__WD; ];


Object Menu_Creditos
  class ZIPI_Otro
  with
    ZIPI_titulo "Créditos",
    ZIPI_ejecutar [; return "créditos"; ];


Object Menu_Quit
  class ZIPI_Otro
  with
    ZIPI_titulo "Terminar",
    ZIPI_ejecutar [; return QUIT1__WD; ];


Object Menu_Importantes
  class ZIPI_Menu
  with
    ZIPI_titulo "Principal",
    ZIPI_item
      Menu_Ayuda
      Menu_Inventario
      Menu_Mapa
      Menu_Diario
      Menu_Configuracion
      ZIPI_Separador
      Menu_Save
      Menu_Restore
      ZIPI_Separador
      Menu_Undo
      Menu_Score
      Menu_Creditos
      ZIPI_Separador
      Menu_Restart
      Menu_Quit;


Object Menu_Ayuda
  class ZIPI_Otro
  with
    ZIPI_titulo "Ayuda",
    ZIPI_ejecutar [; return "ayuda"; ];

    
Object Menu_Diario
  class ZIPI_Otro
  with
    ZIPI_titulo "Diario",
    ZIPI_ejecutar [; return "diario"; ];


Object Menu_Inventario
  class ZIPI_Otro
  with
    ZIPI_titulo "Inventario",
    ZIPI_ejecutar [; return "inventario"; ];


Object Menu_Mapa
  class ZIPI_Otro
  with
    ZIPI_titulo "Mapa",
    ZIPI_ejecutar [; return "mapa"; ];


Object Menu_Configuracion
  class ZIPI_Otro
  with
    ZIPI_titulo "Configuración",
    ZIPI_ejecutar [; return "configuracion"; ];


!===============================================================================
! (9) Otras Rutinas Reemplazadas; Rutinas Propias del Juego
!-------------------------------------------------------------------------------


[ AntesReflow
  anchura altura;
  glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
                             winmethod_Above + winmethod_Proportional, 50, 0);
  glk_window_get_size(gg_statuswin, gg_arguments, gg_arguments + WORDSIZE);
  anchura = gg_arguments-->0;
  altura  = gg_arguments-->1;
  glk_set_window(gg_statuswin);
  glk_window_clear(gg_statuswin);
  glk_window_move_cursor(gg_statuswin, anchura / 2 - 12, altura / 2);
  print "Recalibrando la pantalla";
  glk_window_move_cursor(gg_statuswin, anchura / 2 - 10, altura / 2 + 1);
  print "Por favor, espere...";
  glk_set_window(gg_mainwin);
  glk_window_noscroll(gg_mainwin);
  KeyDelay(1000);
];


! Imprime el artículo de un objeto o localidad:
! - obj: el objeto o localidad en sí
! - art: 0 = artículo definido
!        1 = artículo indefinido
!        0 = sin artículo
! - cap: 0 = artículo en minúscula
!        1 = artículo en mayúscula
! - input: 0 = nombre_link tiene preferencia sobre input_link
!          1 = input_link tiene preferencia sobre nombre_link
[ ArticuloPrevio obj art cap;
  if (obj has proper) rfalse;
  switch (art) {
    0: if (cap) PrefaceByArticle(obj, 0, -1);    ! CDefArt(obj);
       else     PrefaceByArticle(obj, 1, -1);    ! DefArt(obj);
    1: if (cap) PrefaceByArticle(obj, 2, -1, 1); ! CInDefArt(obj);
       else     PrefaceByArticle(obj, 2, -1);    ! IndefArt(obj);
  }
];


[ AutoLoad
  fref res;

  fref = glk_fileref_create_by_name(fileusage_SavedGame + fileusage_BinaryMode,
                                    ChangeAnyToCString(CadenaAutoSave), 0);
  if (fref == 0) {
    glk_fileref_destroy(fref);
    rfalse;
  }
  gg_savestr = glk_stream_open_file(fref, $02, GG_SAVESTR);
  glk_fileref_destroy(fref);
  if (gg_savestr == 0) jump RFailed;
  @restore gg_savestr res;
  glk_stream_close(gg_savestr, 0);
  gg_savestr = 0;
  rtrue;
.RFailed;
  glk_stream_close(gg_savestr, 0);
  gg_savestr = 0;
  rfalse;
];


[ AutoSave
  fref res;

  fref = glk_fileref_create_by_name(fileusage_SavedGame + fileusage_BinaryMode,
                                    ChangeAnyToCString(CadenaAutoSave), 0);
  if (fref == 0) {
    glk_fileref_destroy(fref);
    rfalse;
  }
  gg_savestr = glk_stream_open_file(fref, $01, GG_SAVESTR_ROCK);
  glk_fileref_destroy(fref);
  if (gg_savestr == 0) jump SFailed;
  @save gg_savestr res;
  if (res == -1) {
    ! The player actually just typed "restore". We're going to print
    !  L__M(##Restore,2); the Z-Code Inform library does this correctly
    ! now. But first, we have to recover all the Glk objects; the values
    ! in our global variables are all wrong.
    GGRecoverObjects();
  }
  glk_stream_close(gg_savestr, 0);
  gg_savestr = 0;
  rtrue;
.SFailed;
  glk_stream_close(gg_savestr, 0);
  gg_savestr = 0;
  rfalse;
];


[ ApagarGraficos t;
  hayGraficos = false;
  closeGraphicWindow();
  if (t) print (s_emph) "[Gráficos desactivados.]^";
];


[ BanderaFin df;
  deadflag = df;
  ControlTimer.DesactivarTick();
  Damusix.PararTodo();
];


[ CadenaAutoSave;
  print "autosave.sav";
];


[ CerrarVentanaMapa;
  glk_window_close(gg_mapawin, 0);
  gg_mapawin = 0;
  if (gg_objwin) {
    glk_window_close(gg_objwin, 0); ! gg_objwin se usa en el mapa para la
    gg_objwin = 0;                  ! ventana de texto con hipervínculos
  }
  if (gg_statuswin) glk_window_close(gg_statuswin, 0);
  gg_statuswin = glk_window_open(glk_window_get_parent(gg_mainwin),
                                 winmethod_Above + winmethod_Fixed +
                                 winmethod_NoBorder,
                                 1, wintype_TextGrid, GG_STATUSWIN_ROCK);
  glk_request_hyperlink_event(gg_statuswin);
  if (hayGraficos) EncenderGraficos();
  else             ApagarGraficos();
  ControlTimer.ReanudarTick();
  glk_window_noscroll(gg_mainwin);
];


[ ComoHablar;
  print_ret "[Para hablar con un personaje, usa la forma ~",
            (s_input) "PERSONAJE, lo que sea", "~. Por ejemplo: ~",
            (s_input) "JASON, QUÉ OPINAS DE MADRE", "~.]";
];


! Si dest es una localidad adyacente a la actual, devuelve la dirección en la
! que se encuentra:
[ ConexionLocalidad conex
  l o dest;
  l = LugarReal();
  objectloop (o in Compass) {
    dest = l.(o.door_dir);
    if (dest == conex) return o;
    else if (dest has door && dest has open &&
             dest.(o.door_dir) == conex) return dest;
  }
  rfalse;
];


! Muestra el nombre de un objeto o localidad con un 'de'/'del' delante:
[ DelMostrarNombre o flag;
  if (o provides del_nombre_link) {
    if (o.del_nombre_link ofclass Routine) {
      ! La rutina del_nombre_link() deberá encargarse de activar el
      ! hipervínculo con glk_set_hyperlink(self) o algo similar:
      o.del_nombre_link();
    } else {
      glk_set_hyperlink(o);
      print (string) o.del_nombre_link;
      glk_set_hyperlink(0);
    }
  } else {
    if (flag) print "D";
    else      print "d";
    if (o has proper) {
      print "e ";
      glk_set_hyperlink(o);
      MostrarNombre(o);
      glk_set_hyperlink(0);
    } else {
      PrintAnyToArray(texto_impreso, 50, ArticuloPrevio, o);
      ! Si NO ES articulo "el", agregar 'e' y un espacio:
      if (texto_impreso->0 ~= 'e') print "e ";
      ArticuloPrevio(o);
      glk_set_hyperlink(o);
      MostrarNombre(o, 2);
      glk_set_hyperlink(0);
    }
  }
  return "";
];


[ DespuesReflow;
  glk_set_window(gg_mainwin);
  glk_window_noscroll(gg_mainwin);
  StatusLineHeight(1);
  MostrarImagenLocalidad();
];


! Igualmente, esta versión no muestra puntos cardinales, sino lugares, al
! indicar hacia dónde va un PNJ móvil:
[ DirDada i
  l par;
  par = true;
  switch (i) {
    n_obj:   par = false; ! print "hacia el norte";
    s_obj:   par = false; ! print "hacia el sur";
    e_obj:   par = false; ! print "hacia el este";
    w_obj:   par = false; ! print "hacia el oeste";
    ne_obj:  par = false; ! print "hacia el noreste";
    nw_obj:  par = false; ! print "hacia el noroeste";
    se_obj:  par = false; ! print "hacia el sureste";
    sw_obj:  par = false; ! print "hacia el suroeste";
    u_obj:   par = false; ! print "hacia arriba";
    d_obj:   par = false; ! print "hacia abajo";
    in_obj:  par = false; ! print "al interior";
    out_obj: par = false; ! print "afuera";
    default: print "hacia ", (the) i;
  }
  l = LugarReal();
    
  if (par) print " (";
  if (~~(i == in_obj or out_obj)) print "hacia ";
  MostrarNombreLink(l.(i.door_dir));
  if (par) print ")";
];


[ EncenderGraficos t
  habiaGraficos;
  habiaGraficos = hayGraficos;
  hayGraficos = true;
  openGraphicWindow(anchoVentanaGrafica);
  glk_request_mouse_event(gg_bigwin);
  clearGraphicWindow();
  MostrarImagenLocalidad();
  if (t) {
    glk_set_style(style_Emphasized);
    if (habiaGraficos) print "[Cambiando tamaño de gráficos (tamaño ";
    else               print "[Gráficos activados (tamaño ";
    switch (anchoVentanaGrafica) {
      GRAFICOS_PEQUENOS: print "pequeño";
      GRAFICOS_MEDIANOS: print "mediano";
      GRAFICOS_GRANDES:  print "grande";
      default:           print anchoVentanaGrafica, " px";
    }
    print ").]^";
    style roman;
  }
];


! Esta versión de ExaminarFalsoSub convierte la acción en Entrar o
! Examinar dependiendo de si el objeto de destino es una localidad o no:
[ ExaminarFalsoSub;
  ! Si es el nombre de la localidad actual, la describimos:
  if (noun == location) { PrintOrRun(noun, description); rtrue; }
  if (noun ofclass Lugar) <<Enter noun>>;
  else                    <<Examine noun>>;
];


[ ExisteAutoSave
  fref;
  fref = glk_fileref_create_by_name(fileusage_SavedGame + fileusage_BinaryMode,
                                    ChangeAnyToCString(CadenaAutoSave), 0);
  if (fref == 0) jump RFailed;
  gg_savestr = glk_stream_open_file(fref, $02, GG_SAVESTR);
  glk_fileref_destroy(fref);
  if (gg_savestr == 0) jump RFailed;
  glk_stream_close(gg_savestr, 0);
  gg_savestr = 0;
  rtrue;
.RFailed;
  glk_stream_close(gg_savestr, 0);
  gg_savestr = 0;
  rfalse;
];


[ ExtenderVentanaEstado por;
  if (por == 0) por = 100;
  glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
                             winmethod_Above + winmethod_Proportional +
                             winmethod_NoBorder, por, 0);
];


[ HandleGlkMouseEvent ventana;
  if (ventana == gg_bigwin) {
    return "mira";
  } else if (ventana == gg_objwin) {
    if (curr_obj_pic ofclass Object) return curr_obj_pic;
  }
  rfalse;
];


[ ImprimirPrompt;
  if (player ~= selfobj) {
    glk_set_style(style_User1);
    print (string) player.short_name;
    glk_set_style(style_Normal);
    print " ";
  }
  print (s_input) "> ";
];


[ IniciarGraficosSonidos
  ancho alto;
  if (glk_gestalt(gestalt_AlphaAventuras, 0) == 0) {
    print "^Lo sentimos, pero este juego necesita un intérprete
            propio y no funcionará con ningún otro intérprete Glulx
            estándar.^";
    KeyDelay();
    quit;
  }

  ! Inicialización sonora
  IniciarSonidos();

  ! Inicialización gráfica
  glk_get_screen_size(gg_arguments, gg_arguments + WORDSIZE);
  ancho = gg_arguments-->0;
  alto  = gg_arguments-->1;

  if (alto <= 600)  {
    anchoVentanaGrafica = GRAFICOS_PEQUENOS;
    altoLogoMenu = 250;
    glk_decr_fontsize();
    glk_decr_fontsize();
    glk_decr_fontsize();
    glk_decr_fontsize();
    ZIPI_Configuracion.guardar_valores();
  } else if (alto <= 768) {
    anchoVentanaGrafica = GRAFICOS_MEDIANOS;
    altoLogoMenu = 300;
    glk_decr_fontsize();
    glk_decr_fontsize();
    glk_decr_fontsize();
    ZIPI_Configuracion.guardar_valores();
  } else if (alto <= 800) {
    anchoVentanaGrafica = GRAFICOS_MEDIANOS;
    altoLogoMenu = 350;
    glk_decr_fontsize();
    glk_decr_fontsize();
    ZIPI_Configuracion.guardar_valores();
!  } else if (alto <= 1080) {
!    anchoVentanaGrafica = GRAFICOS_MEDIANOS;
  } else {
    anchoVentanaGrafica = GRAFICOS_GRANDES;
  }

  if (ancho <= 1280) {
    ! No cambia nada
  } else if (ancho <= 1600) {
    glk_set_config(config_Cols, 135);
    glk_incr_fontsize();
    ZIPI_Configuracion.guardar_valores();
  } else if (ancho <= 1920) {
    glk_set_config(config_Cols, 135);
    glk_incr_fontsize();
    glk_incr_fontsize();
    ZIPI_Configuracion.guardar_valores();
  }

  initializeSGW(altoLogoMenu);
];


[ IniciarSonidos;
  Damusix.VolumenCanal(CANAL_FONDO,     VOLUMEN_FONDO);
  Damusix.VolumenCanal(CANAL_TV_SALON,  VOLUMEN_TV_SALON);
  Damusix.VolumenCanal(CANAL_TV_CUARTO, VOLUMEN_TV_CUARTO);
  Damusix.VolumenCanal(CANAL_TELEFONO,  VOLUMEN_TELEFONO);
];


[ Introduccion;
  clearMainWindow();
  viewImageCenter(Oscuridad_jpg);
  InicioPrologo();
];


[ link obj msg;
  return link_general(obj, msg, 2, 0);
];


[ Link_ obj msg;
  return link_general(obj, msg, 2, 1);
];


[ link_del obj;
  return DelMostrarNombre(obj);
];


[ link_el obj;
  return link_general(obj, 0, 0, 0);
];


[ Link_el_ obj;
  return link_general(obj, 0, 0, 1);
];


[ link_general obj msg art cap;
!  if (~~(obj ofclass Object && ~~TestScope(obj)))
  if (art == 2) glk_set_hyperlink(obj);
  if (msg ~= 0) {
    print (string) msg;
    glk_set_hyperlink(0);
    return "";
  } else {
    if (art ~= 2) {
      ArticuloPrevio(obj, art, cap);
      glk_set_hyperlink(obj);
      MostrarNombre(obj, 2, cap);
    } else {
      MostrarNombre(obj, art, cap);
    }
  }
  glk_set_hyperlink(0);
  return obj;
];


[ link_i obj msg;
  glk_set_style(style_Input);
  link(obj, msg);
  glk_set_style(style_Normal);
];


#ifndef LugarReal;
[ LugarReal;
  if (location == thedark) return real_location;
  else                     return location;
];
#endif;


[ MostrarImagenAuxiliar img;
  viewImageSlide(img);
];


[ MostrarImagenLocalidad loc;
  if (~~loc) loc = location;
  viewImageCenter(loc);
!  if (loc provides sgw_img) viewImageCenter(loc.sgw_img);
];


[ MostrarImagenGradualmente imagen veces retardo
  i;
  for (i = 0 : i < veces : i++) {
    viewImageCenter(imagen, true);
    WaitDelay(retardo);
  }  
];


! Muestra el nombre del objeto o localidad, con un hipervínculo asociado,
! con artículo y teniendo preferencia nombre_link sobre input_link:
! - cap: 0 = artículo en minúscula
!        1 = artículo en mayúscula
[ MostrarNombreLink obj cap;
  ArticuloPrevio(obj, 0, cap);
  glk_set_hyperlink(obj);
  MostrarNombre(obj, 2);
  glk_set_hyperlink(0);
];


![ OcultarImagenAuxiliar;
!  closeImageSlide();
!!  if (gg_objwin ~= 0) glk_window_close(gg_objwin, 0);
!!  gg_objwin = 0;
!!  MostrarImagenLocalidad();
!];


! Imprime el nombre de un objeto o localidad:
! - obj: el objeto o localidad en sí
! - art: 0 = artículo definido
!        1 = artículo indefinido
!        2 = sin artículo
! - cap: 0 = artículo en minúscula
!        1 = artículo en mayúscula
! - input: 0 = nombre_link tiene preferencia sobre input_link
!          1 = input_link tiene preferencia sobre nombre_link
[ MostrarNombre obj art cap input
  ;
  if (obj ofclass String) {
    print (string) obj;
  } else if (obj ofclass Routine) {
    print (string) obj();
  } else if (obj ofclass Lugar && obj has visited &&
             obj provides nombre_si_visitado) {
    ArticuloPrevio(obj, art, cap); PrintOrRun(obj, nombre_si_visitado, 1);
  } else if (obj ofclass Lugar &&  obj hasnt visited &&
             obj provides nombre_no_visitado) {
    ArticuloPrevio(obj, art, cap); PrintOrRun(obj, nombre_no_visitado, 1);
  } else if (obj ofclass Lugar && obj provides nombre_direccion) {
    ArticuloPrevio(obj, art, cap); PrintOrRun(obj, nombre_direccion, 1);
  } else if (input && obj provides input_link) {
    ArticuloPrevio(obj, art, cap); PrintOrRun(obj, input_link, 1);
  } else if (input && obj provides nombre_link) {
    ArticuloPrevio(obj, art, cap); PrintOrRun(obj, nombre_link, 1);
  } else if ((~~input) && obj provides nombre_link) {
    ArticuloPrevio(obj, art, cap); PrintOrRun(obj, nombre_link, 1);
  } else if ((~~input) && obj provides input_link) {
    ArticuloPrevio(obj, art, cap); PrintOrRun(obj, input_link, 1);
  } else if (obj provides name) {
    ArticuloPrevio(obj, art, cap); print (address) obj.&name-->0;
  } else if (obj provides name_m) {
    ArticuloPrevio(obj, art, cap); print (address) obj.&name_m-->0;
  } else if (obj provides name_f) {
    ArticuloPrevio(obj, art, cap); print (address) obj.&name_f-->0;
  } else if (obj provides name_mp) {
    ArticuloPrevio(obj, art, cap); print (address) obj.&name_mp-->0;
  } else if (obj provides name_fp) {
    ArticuloPrevio(obj, art, cap); print (address) obj.&name_fp-->0;
  } else {
    ArticuloPrevio(obj, art, cap); PrintAnything(obj);
  }
];


[ RefrescarVentanasTexto;
  glk_window_get_arrangement(glk_window_get_parent(gg_statuswin),
                             gg_arguments, gg_arguments + WORDSIZE,
                             gg_arguments + 2 * WORDSIZE);
  glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
                             gg_arguments-->0, gg_arguments-->1,
                             gg_arguments-->2);
];


!===============================================================================
! (10) Verbos y Gramaticas Propias del Juego
!-------------------------------------------------------------------------------


Verb meta 'ayuda'
  *                 -> Ayuda;

Verb 'chilla' = 'grita';

Verb meta 'configuracion'
  *                           -> Configuracion;

Verb meta 'creditos'
  *                 -> Creditos;

Verb 'cuentale' = 'cuenta';

Extend 'di' first
  * 'a' creature             -> Answer;

Verb meta 'graficos'
  *                           -> Graficos
  * 'on'/'encendido'/'si'     -> EncenderGraficos
  * 'off'/'apagado'/'no'/'nx' -> ApagarGraficos
  * 'pequenos'                -> GraficosPequenos
  * 'medianos'                -> GraficosMedianos
  * 'grandes'                 -> GraficosGrandes;

Extend only 'grita' replace
  *                 -> Gritar
  * 'a//' creature  -> Gritar;

Extend 'habla' first
  * 'con' creature topic     -> Tell
  * 'con' creature           -> Tell
  * 'a' creature             -> Tell;

Verb 'hola'
  *                 -> Saludar;

Verb 'llama'
  *                 -> Llamar
  * 'a//' noun      -> Llamar
  * 'por' noun      -> LlamarPor;

Verb meta 'musica'
  *                                   -> Musica
  * 'fondo' 'on'/'encendida'/'si'     -> EncenderMusica
  * 'fondo' 'off'/'apagada'/'no'/'nx' -> ApagarMusica
  * 'on'/'encendida'/'si'             -> EncenderMusica
  * 'off'/'apagada'/'no'/ 'nx'        -> ApagarMusica;

Verb 'no.verb' * noun -> ExaminarFalso;
 
Verb meta 'pistas'
  *                 -> Pistas
  * 'no' / 'nx'     -> PistasNo;

Verb 'preguntale' = 'pregunta';

Extend 'pregunta' replace
  * creature 'sobre'/'por' topic       -> Pregunta
  * 'a//' creature                     -> Pregunta
  * 'a//' creature 'sobre'/'por' topic -> Pregunta
  * 'sobre'/'por' topic 'a//' creature -> Pregunta reverse
  * topic 'a//' creature               -> Pregunta reverse
  * 'a//' creature 'acerca' 'de' topic -> Pregunta;

Extend only 'sal' 'salte' 'salirse' 'salirte'
  * noun            -> SalirA
  * 'a//' noun      -> SalirA;

Extend 'sal'
  * 'por' noun      -> SalirPor;

Extend 'saluda' first
  *                 -> Saludar;

Verb 'sigue'
  * creature               -> Seguir
  * creature 'aqui'        -> Seguir
  * 'a//' creature         -> Seguir
  * 'a//' creature 'aqui'  -> Seguir;

Verb meta 'sonido' 'sonidos'
  *                                   -> Sonido
  * 'on'/'encendido'/'si'             -> EncenderSonido
  * 'off'/'apagado'/'no'/'nx'         -> ApagarSonido
  * 'fondo'                           -> Musica
  * 'fondo' 'on'/'encendido'/'si'     -> EncenderMusica
  * 'fondo' 'off'/'apagado'/'no'/'nx' -> ApagarMusica;

Verb 'vamonos' 'vayamonos'
  *                  -> Venir
  * 'de' 'aqui'      -> Venir;

Verb 'vamos'
  *                  -> Venir;

Verb 'ven'
  *                  -> Venir
  * 'aqui'           -> Venir
  * 'conmigo'        -> Venir;

Verb meta 'verbo.nulo'
  *                  -> VerboNulo;
  
#ifdef DEBUG;
Verb meta 't'
  *                    -> TestPasoAPaso;

Verb meta 'tt'
  *                    -> TestContinuar;
#endif;


!===============================================================================
! (11) Rutinas de Acciones Propias del Juego
!-------------------------------------------------------------------------------


[ AnswerSub;
  ComoHablar();
];


[ ApagarGraficosSub;
  AntesReflow();
  ApagarGraficos(true);
  DespuesReflow();
];

  
[ ApagarMusicaSub;
  haySonidoFondo = false;
  Damusix.VolumenCanal(CANAL_FONDO, 0);
  print (s_emph) "[Desactivado el sonido de fondo.]^";
];


[ ApagarSonidoSub;
  haySonido = false;
  Damusix.DesactivarAudio();
  print (s_emph) "[Desactivados todos los efectos sonoros.]^";
];


[ AyudaSub;
  print "Prueba a pedir ayuda a alguien. Si necesitas pistas más elaboradas,
         puedes usar el sistema de pistas interactivas tecleando el comando ",
         (link_i) "PISTAS", ".^";
];


[ ColgarSub;
  "No tiene sentido colgar eso.";
];


[ ConfiguracionSub
  fondo v m rflw;
  ControlTimer.PausarTick();
  fondo = Damusix.SonandoDeFondoCanal(CANAL_FONDO);
  ExtenderVentanaEstado();
  ZIPI_Configuracion.ha_cambiado_algo = false;

  ZIPI_RunMenu(ZIPI_Configuracion, true);
  
  rflw = ZIPI_Configuracion.ha_cambiado_algo && ZIPI_Configuracion.reflow;
  ZIPI_Configuracion.ha_cambiado_algo = false;

  v = Damusix.QueVolumenCanal(CANAL_FONDO);
  if (LugarReal() provides sgw_mus) {
    m = LugarReal().sgw_mus;
    if (fondo && haySonidoFondo && v ~= 0 && (~~(Damusix.SonandoDeFondo(m)))) {
      Damusix.AsignarCanal(m, CANAL_FONDO, v, SONIDO_REPETIR);
      Damusix.TocarCanal(CANAL_FONDO);
    }
  }
  StatusLineHeight(1);
  if (rflw) AntesReflow();
  if (hayGraficos) EncenderGraficos();
  else             ApagarGraficos();
  if (rflw) {
    DespuesReflow();
  } else {
    glk_set_window(gg_mainwin);
    glk_window_noscroll(gg_mainwin);
  }
  ControlTimer.ReanudarTick();
];


[ ConsultSub;
  <<Examine noun>>;
];


[ CreditosSub;
  viewImageCenter(Logo_Alpha_Aventuras_jpg);
  print (s_head) "^@<<EL CÍRCULO@>>", " --- (c) 2012 Alpha Aventuras^^";
  print (s_bold) "-- PROGRAMACIÓN Y DISEÑO:^";
  print "    Ricardo Pérez López^^";
  print (s_bold) "-- GRÁFICOS:^";
  print "    Manuel Millán Ruiz^^";
  print (s_bold) "-- TEXTOS:^";
  print "    Ricardo Pérez López^^";
  print (s_bold) "-- MAPEADO Y DOCUMENTACIÓN:^";
  print "    Ricardo Pérez López^";
  print "    Antonio Matiola Ortiz^^";
  print (s_bold) "-- PRUEBAS:^";
  print "    Ricardo Pérez López^";
  print "    Manuel Millán Ruiz^^";
  KeyDelay();
  print "Desarrollado usando el lenguaje Inform, de Graham Nelson,
         con ayuda de las siguientes librerías:^^";
  print "- INFSP6 (fix), de Sarganar et al.^";
  print "- Adaptación de SGW+DMX, de Eliuk Blau^";
  print "- Damusix, de Eliuk Blau^";
  print "- PNJactor_NG y PNJacciones_NG (adaptaciones de los originales de Zak
           y Carlos)^";
  print "- Moviles_NG (adaptación de Moviles, de Mel Hython)^";
  print "- PNJpuertas_NG (Adaptación de PnjPuertas, de Jaevius)^";
  print "- Decir, de Zak^";
  print "- Etemas, de Zak^";
  print "- Decorado_NG (adaptación de Decorado, de Zak y Mel Hython)^";
  print "- Adaptación de Barra, de Presi^";
  print "- Adaptación de ZIPI, de Zak^";
  print "- Timer, de Sothoth";
  KeyDelay();
  print "^^Basado en la novela @<<Ringu@>> de Koji Suzuki y el film
         @<<The Ring@>> (c) 2002 Dreamworks SKG.";
  print "^^Nuestro agradecimiento a todos los integrantes del CAAD que nos han
         ayudado, directa o indirectamente, en el desarrollo de esta aventura.^^
         (c) 2012 Alpha Aventuras^^
         Este programa es software libre, publicado bajo la licencia GNU GPL v3.
         El texto completo de la licencia se encuentra en la siguiente
         dirección:^^";
  print (s_pref) "http://www.gnu.org/licenses/gpl.txt^";
  print "^El código fuente del programa está disponible en Github:^^";
  print (s_pref) "https://github.com/ricpelo/elcirculo^";
  KeyDelay();
  print "^Visítanos en:^^";
  print (s_pref) "http://www.alpha-aventuras.es^
        http://wiki.caad.es/Alpha_Aventuras^
        http://www.facebook.com/alphaaventuras^";
  KeyDelay();
  MostrarImagenLocalidad();
];


[ EncenderGraficosSub;
  AntesReflow();
  EncenderGraficos(true);
  DespuesReflow();
];


[ EncenderMusicaSub i;
  haySonidoFondo = true;
  Damusix.VolumenCanal(CANAL_FONDO, VOLUMEN_FONDO);

  if (~~i) {
    print (s_emph) "[Activado el sonido de fondo.]^";
  }
];


[ EncenderSonidoSub;
  haySonido = true;
  Damusix.ActivarAudio();
  print (s_emph) "[Activados todos los efectos sonoros.]^";
];


[ GraficosGrandesSub;
  anchoVentanaGrafica = GRAFICOS_GRANDES;
  EncenderGraficosSub();
];


[ GraficosMedianosSub;
  anchoVentanaGrafica = GRAFICOS_MEDIANOS;
  EncenderGraficosSub();
];


[ GraficosPequenosSub;
  anchoVentanaGrafica = GRAFICOS_PEQUENOS;
  EncenderGraficosSub();
];


[ GraficosSub;
  print (s_emph) "[Por favor, usa la forma ~", (link_i) "GRAFICOS SI",
        (s_emph) "~ o ~", (link_i) "GRAFICOS NO", (s_emph) "~ para activar o
        desactivar, respectivamente, el uso de gráficos. También puedes
        cambiar el tamaño de la ventana gráfica usando ~",
        (link_i) "GRAFICOS PEQUEÑOS", (s_emph) "~, ~",
        (link_i) "GRAFICOS MEDIANOS", (s_emph) "~ o ~",
        (link_i) "GRAFICOS GRANDES", (s_emph) "~.]^";
];


[ GritarSub;
!  pagina_contenidos.update(1);
!  diario_llave.update();
!  diario_ticket.update();  
!  diario_amigos.update();
!  midiario.update(p2, 1);
  "Emites un sonoro grito, pero nadie responde.";
];


[ LlamarPorSub;
  "Con eso no puedes llamar a ningún sitio.";
];


[ LlamarSub;
  "¿Llamar a qué o a quién?";
];


[ MusicaSub;
  print (s_emph) "[Por favor, usa la forma ~", (link_i) "SONIDO FONDO SI",
        (s_emph) "~ o ~", (link_i) "SONIDO FONDO NO", (s_emph) "~ para activar
        o desactivar, respectivamente, el sonido de fondo.]^";
];


[ PistasNoSub;
  switch (hayPistas) {
    2:       print (s_emph) "[Las pistas ya han sido desactivadas.]^";
    default: hayPistas = 2;
             print (s_emph) "[PISTAS desactivadas.]^";
  }
];


[ PistasSub
  i;
  switch (hayPistas) {
    0: hayPistas = 1;
       print (s_emph) "[Advertencia: Es sabido que la tentación de la ayuda es
             a veces tan fuerte que se suelen obtener pistas prematuramente.
             Por tanto, en cualquier momento durante el juego puedes poner ",
             (link_i) "PISTAS NO", (s_emph) ", y eso te impedirá obtener ayuda
             en la sesión de juego actual. Si sigues queriendo una pista, pon ",
             (link_i) "PISTAS", (s_emph) " otra vez.]^";

    1: ControlTimer.PausarTick();
       if (hayGraficos) {
         ApagarGraficos();
         hayGraficos = true;
       }
       ExtenderVentanaEstado();

       for (i = 0 : i < DAMUSIX_NCANALMAX : i++) {
         sonidosSonando->i = Damusix.SonandoDeFondoCanal(i);
         Damusix.PararCanal(i);
       }

       Damusix.AsignarCanal(Darkwalk_ogg, CANAL_FONDO,
                            Damusix.QueVolumenCanal(CANAL_FONDO), 
                            SONIDO_REPETIR);
       Damusix.TocarCanal(CANAL_FONDO);
       
       ZIPI_Empezar();
       
       for (i = 0 : i < DAMUSIX_NCANALMAX : i++) {
         if ((i ~= CANAL_FONDO) && (sonidosSonando->i)) Damusix.TocarCanal(i);
       }

       if ((sonidosSonando->CANAL_FONDO) && (LugarReal() provides sgw_mus)) {
         Damusix.AsignarCanal(LugarReal().sgw_mus, CANAL_FONDO,
                              Damusix.QueVolumenCanal(CANAL_FONDO),
                              SONIDO_REPETIR);
         Damusix.TocarCanal(CANAL_FONDO);
       } else {
         Damusix.PararCanal(CANAL_FONDO);
       }

       StatusLineHeight(1);
       if (hayGraficos) EncenderGraficos();
       ControlTimer.ReanudarTick();
       glk_set_window(gg_mainwin);
       glk_window_noscroll(gg_mainwin);

    2: print (s_emph) "[Las pistas han sido desactivadas.]^";
  }
];


[ PreguntaSub;
  ComoHablar();
];


! Para poder poner "SALIR AL PASILLO", que sería lo mismo que "ENTRA EN EL
! PASILLO".
[ SalirASub;
  print_ret (The) noun, " no es algo a donde puedas salir.";
];


[ SalirPorSub;
  if (noun ofclass Lugar) <<Exit>>;
  else                    <<Enter noun>>;
];


[ SaludarSub;
!  i c;
!  glk_set_config(config_LinkColor,
!                 glk_window_stylehint_get(gg_mainwin, style_Normal,
!                                          stylehint_TextColor));
!  glk_window_get_arrangement(glk_window_get_parent(gg_statuswin),
!                             gg_arguments, gg_arguments + WORDSIZE,
!                             gg_arguments + 2 * WORDSIZE);
!  glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
!                             gg_arguments-->0, gg_arguments-->1,
!                             gg_arguments-->2);
!  for (i = 255 : i >= 0 : i = i - 15) {
!    c = i * 65536 + i * 256 + i;
!    glk_window_stylehint_set(gg_mainwin, style_Normal,
!                                         stylehint_TextColor, c);
!    glk_set_config(config_LinkColor, c);
!    glk_window_get_arrangement(glk_window_get_parent(gg_statuswin),
!                               gg_arguments, gg_arguments + WORDSIZE,
!                               gg_arguments + 2 * WORDSIZE);
!    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
!                               gg_arguments-->0, gg_arguments-->1,
!                               gg_arguments-->2);
!    WaitDelay(1);
!  }
!  viewImageSlide(Logo_Circulo_Chico_jpg);
!  pagina_contenidos.update();
!  diario_llave.update();
!  diario_amigos.update();
!  IndefArt(tv_cuarto_katie); new_line;
!  CInDefArt(tv_cuarto_katie); new_line;
!  DefArt(tv_cuarto_katie); new_line;
!  CDefArt(tv_cuarto_katie); new_line;
!  PrintShortName(tv_cuarto_katie); new_line;
!  PrefaceByArticle(puerta_katie, 0, -1); new_line;   ! CDefArt(obj);
!  PrefaceByArticle(puerta_katie, 1, -1); new_line;   ! DefArt(obj);
!  PrefaceByArticle(puerta_katie, 2, -1, 1); new_line;! CInDefArt(obj);
!  PrefaceByArticle(puerta_katie, 2, -1); new_line;   ! IndefArt(obj);
!  VozLejana("Hola");
  glk_mplayer(ChangeAnyToCString(VideoPepe));
  "Saludas cordialmente.";
];


[ VideoPepe;
  print "pepe.avi";
];


[ SearchSub;
  <<Examine noun>>;
];


[ SeguirSub;
  "Decide por ti mism", (o) player, " a dónde deseas ir.";
];


[ SonidoSub;
  print (s_emph) "[Por favor, usa la forma ~", (s_input) "SONIDO SI",
        (s_emph) "~ o ~", (s_input) "SONIDO NO",
        (s_emph) "~ para activar o desactivar, respectivamente,
                  todos los efectos sonoros.]^";
];


[ TellSub;
  ComoHablar();
];


[ VenirSub;
  <<Seguir player>>;
];


[ VerboNuloSub;
  rfalse;
];


#ifdef DEBUG;
[ TestPasoAPasoSub;
  test_machine.run_once();
];


[ TestContinuarSub;
  test_machine.run();
];
#endif;


!===============================================================================
! (12) Partes de la aventura (en archivos separados)
!-------------------------------------------------------------------------------


Include "diario.inf";      ! Diario de tareas
Include "prologo.inf";     ! Prólogo
Include "historia.inf";    ! Primer capítulo


! Fin elcirculo.inf
