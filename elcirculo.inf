!% -~S
!% -G
!% +language_name=Spanish
!% $MAX_STATIC_DATA=25000
!% $MAX_PROP_TABLE_SIZE=63840
!% $MAX_VERBS=200
!% $MAX_ZCODE_SIZE=45000
!% $MAX_VERBSPACE=4500

!
! EL CÍRCULO
!
! Copyright (c) 2012 Ricardo Pérez López (Alpha Aventuras)
!

! This program is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.


!===============================================================================
! (1) Constantes; Variables Globales; Replaces; Propertys; Incluir Parser.h
!-------------------------------------------------------------------------------


! ====================================================================
! CONSTANTES
! ====================================================================


Constant Story "@<<EL CÍRCULO@>>";
Constant Headline "^(c) 2012 Alpha Aventuras^^
                  Teclea CRÉDITOS si quieres saber más acerca de la aventura, o
                  AYUDA cuando estés bloqueado.^";
Release 1;

! Queremos usar el comando 'Salidas'
Constant ADMITIR_COMANDO_SALIDAS;
! No queremos usar los comandos 'Lugares' y 'Objetos'
Constant NO_PLACES;
! No queremos usar puntuación
Constant NO_SCORE;
! Queremos que se muestren las deducciones del parser
!Constant IMPRIMIR_DEDUCCIONES;
! Hay curiosidades al final del juego
Constant AMUSING_PROVIDED;

! Altura (en caracteres) de la ventana grid en el menú principal:
Constant ALTURA_MENU_PRINCIPAL = 15;
! Altura (en caracteres) de la ventana grid cuando al mostrar información larga:
Constant ALTURA_MENU_COMPLETA  = 24;
! Altura (en px.) de la ventana de logo en el menú principal:
Constant ALTURA_LOGO_MENU      = 350;

! Canales y volúmenes para los sonidos:
Constant CANAL_FONDO     = 9; Constant VOLUMEN_FONDO     = 50;
Constant CANAL_TV_SALON  = 0; Constant VOLUMEN_TV_SALON  = 100;
Constant CANAL_TV_CUARTO = 1; Constant VOLUMEN_TV_CUARTO = 50;
Constant CANAL_TELEFONO  = 2; Constant VOLUMEN_TELEFONO  = 100;

! La roca de la ventana de menús de acciones:
Constant GG_MENUWIN_ROCK = 213;

! El color de fondo de la ventana gráfica es negro:
Constant CLR_GG_PERSBACK = CLR_GG_BLACK;

! No queremos marcos en las cajas hechas con el comando box:
Constant GBOXQUOTE_NOFRAME;

! Alturas de los gráficos:
Constant GRAFICOS_MINUSCULOS = 200;
Constant GRAFICOS_PEQUENOS   = 250;
Constant GRAFICOS_MEDIANOS   = 350;
Constant GRAFICOS_GRANDES    = 450;

! Constantes de gtalk.h:
Constant GT_SELECT       = "Selecciona una opción ";
Constant GT_ZEROEXIT     = "(0 para salir) ";
Constant GT_WOULDLIKE    = "^¿Qué vas a decir?^";
Constant GT_NOQUIP       = "No se te ocurre nada más que decir.^";
Constant GT_NOSAY        = "^Prefieres no decir nada.^";
Constant GT_OPTIONPREFIX = "[";
Constant GT_OPTIONSUFFIX = "] ";

! Número máximo de cadenas DIFERENTES que se han impreso:
Constant PS_TAB_SIZE = 1000;

! Vamos a usar Damusix junto con SGW+DMX
Constant SGW_CON_DAMUSIX;
Constant SONIDO_REPETIR = -1;

! Constantes para los gestores de timer:
Constant TIMER_TICK = 1000;
Constant TIMER_DURACION_BECCA = 5;
Constant TIMER_DURACION_IMAGEN_PERSONAJE = 4;
Constant TIMER_DURACION_TLF_KATIE = 6;


! ====================================================================
! VARIABLES GLOBALES
! ====================================================================


! Alto de la ventana gráfica:
Global altoVentanaGrafica = GRAFICOS_MEDIANOS;

! Interruptor para indicar si hay que dibujar o no la línea de estado
! (ver rutina Inicialise):
Global dibujarEstado = false;

! Se pone a true y false en la rutina PermitirEmpujarDir, y luego se consulta en
! MensajesLibreria:
Global estoyEmpujando = false;

! La ventana de menús de acciones:
Global gg_menuwin = 0;

! Hay gráficos o no:
Global hayGraficos = true;

! Interruptor de pistas:
Global hayPistas = 0;

! Hay sonidos:
Global haySonido = true;
Global haySonidoFondo = true;

! Hay eventos en tiempo real:
Global hayTiempoReal = true;

! Hay efecto de teletipo:
!Global hayTeletipo = false;

! Si se ha activado el listado automático de salidas:
Global mostrarSalidas = true;

! La imagen que representa la oscuridad:
Global SGW_IMAGEN_OSCURIDAD = Oscuridad_jpg;


! ====================================================================
! REPLACES
! ====================================================================


! Ajustamos esta rutina para que SGW+DMX no actualice sola el gráfico de la
! localidad actual cuando se está mostrando el gráfico de un personaje:
Replace AfterPrompt;

! Con el siguiente Replace conseguimos que el objeto empujado hacia una
! dirección aparezca en la descripción de la localidad de destino del "empuje":
Replace AllowPushDir;

! En este juego no se habla, ni se responde, ni se dice:
Replace AnswerSub;
Replace DecirSub;
Replace TellSub;

! Para usar el comando box con Glulx:
Replace Box__Routine;

! Nuestra versión de CerrarVentanaMapa es prácticamente idéntica a la de
! Mapeador.h, con la única diferencia de que sólo llama a EncenderGraficos()
! cuando hayGraficos es true:
Replace CerrarVentanaMapa;

! En este juego no se usa el Consultar (CONSULTA, LEE, BUSCA EN x SOBRE y...):
Replace ConsultSub;

! Igualmente, esta versión no muestra puntos cardinales, sino lugares, al
! indicar hacia dónde va un PNJ móvil:
Replace DirDada;

! Nuestra versión de esta rutina sólo redibuja la línea de estado cuando
! la variable global dibujarEstado está a true:
Replace DrawStatusLine;

! Sustituimos la rutina EncenderGraficos que aparece en Mapeador:
Replace EncenderGraficos;

! Para que el verbo se convierta en Entrar o Examinar dependiendo de si
! es una localidad o no:
Replace ExaminarFalsoSub;

! Reemplazo de los puntos de entrada de Glulx:
Replace HandleGlkEvent;
Replace InitGlkWindow;

! Lo pide TestMachine_NG.h:
Replace KeyboardPrimitive;

! Lo pide Timer.h:
Replace KeyDelay;

! Nuestra versión de LanguageDirection no muestra los puntos cardinales y
! muestra entre paréntesis el destino de la dirección:
Replace LanguageDirection;

! Usamos el ParseNoun de IntNombre_NG:
Replace ParseNoun;

! Nuestra versión elimina también los signos de admiración e interrogación:
Replace QuitarAcentos;

! Cambia la función random() (ver random.h):
Replace random;

! En este juego no se usa el BuscarEn (MIRA EN, BUSCA EN/DENTRO/DE/SOBRE,
! REGISTRA...):
Replace SearchSub;

! Nuestra versión mejora la de ExaminarFalso en que muestra un menú de
! acciones si el objeto lo tiene:
Replace UnknownVerb;

! Ponemos nuestra propia versión de ZIPI_RunMenu y ZIPI_RunOtro,
! para el menú principal y las pistas:
Replace ZIPI_RunMenu;
Replace ZIPI_RunOtro;
Replace ZIPI_tecla;


Include "Parser";


!===============================================================================
! (2) Puntos de Entrada para Glk [solo en Glulx]:
!     -  HandleGlkEvent(), IdentifyGlkObject(), InitGlkWindow()
!-------------------------------------------------------------------------------


! El IdentifyGlkObject de la ventana de menús de acciones:
[ Menu_IdentifyGlkObject fase tipo ref rock;
  if (fase == 0) { ! Poner cero en todos nuestros objetos glk
    gg_menuwin = 0;
    return;
  }       
  if (fase == 1) { ! Reiniciar correctamente las variables glk
    switch (tipo) {
      0: ! es una ventana
         switch (rock) {
           GG_MENUWIN_ROCK: gg_menuwin = ref;
         }
      1: ! es un flujo
         ! pero no hay flujos en este ejemplo
      2: ! es una referencia a fichero
         ! pero no hay ficheros en este ejemplo
    }
    return;
  }       
  if (fase == 2) { ! Actualizar nuestras ventanas
    rfalse;
  }
];


[ HandleGlkEvent ev context buffer
  obj long;
  switch (ev-->0) {
!    evtype_MouseInput:
!      glk_request_mouse_event(ev-->1); ! ev-->1 es la ventana
!      if (context == 0) return 1;      ! line input request
!      glk($00D3, gg_mainwin);          ! glk_cancel_char_event
!      buffer-->0 = 0;
!      return 2;

    evtype_Hyperlink:
      glk_request_hyperlink_event(ev-->1); ! ev-->1 es la ventana
      if (context == 1) return 1;  ! character input request, no se hace nada
      obj = ev-->2;                        ! ev-->2 es el número de hyperlink
      if (obj < 0) obj = -obj;     ! Si es negativo, es un texto, no un objeto
      else {                       ! En caso contrario, es un objeto
        if (obj in Compass) {   ! El jugador ha pulsado sobre un punto cardinal
          ImprimirPrompt();
          print (s_input) "ve ", (s_input) obj.input_link, "^";
        }
        obj = obj.input_link;
        glk_cancel_line_event(gg_mainwin, gg_event);
      }
      ExaminarFalso.mostrarExaminar = true; ! Mostramos "> ex objeto"
      ! Cuando se ha pulsado sobre un texto que no es un objeto,
      ! guardamos la cadena pulsada, con signo negativo para distinguir este
      ! caso en ExaminarFalsoSub():
      ExaminarFalso.palabraMenu = -obj;
      ! Rellenamos el búffer con el nombre del objeto (o con la cadena), como si
      ! el jugador lo hubiese tecleado:
      long = PrintAnyToArray(buffer + WORDSIZE, INPUT_BUFFER_LEN - WORDSIZE,
                             obj);
      buffer-->0 = long;
      return 2;  ! Retornamos 2 para que acepte como si hubiese pulsado Intro
  }
  SGW_HandleGlk(ev);
  ControlTimer.CT_HandleGlkEvent(ev, context, buffer);
  Mapa_HandleGlkEvent(ev, context, buffer);
  midiario.Diary_HandleGlkEvent(ev, context, buffer);
];


[ IdentifyGlkObject fase tipo ref rock;
  SGW_IdentifyGlk(fase, tipo, ref, rock);
  Damusix.IdentificarSonidos(fase);
  Menu_IdentifyGlkObject(fase, tipo, ref, rock);
  Mapa_IdentifyGlkObject(fase, tipo, ref, rock);
];


[ InitGlkWindow winrock;
  switch (winrock) {
    GG_MAINWIN_ROCK:
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Weight, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Justification, stylehint_just_LeftRight);

      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_Weight, 1);

      ! Esta será mi negrita:
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_BackColor, $0000ff);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_TextColor, $0000ff);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Weight, 1);
 
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_TextColor, $82c1fb);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_Weight, 0);

      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Subheader,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_Subheader,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_SubHeader,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextBuffer, style_SubHeader,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Note,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextBuffer, style_Note,
                        stylehint_BackColor, $000000);

      glk_stylehint_set(wintype_TextBuffer, style_BlockQuote,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_BlockQuote,
                        stylehint_BackColor, $ffffff);


      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Weight, 0);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Justification, stylehint_just_LeftRight);
         
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_Weight, 1);
 
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_Weight, 1);
  
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_BackColor, $0000ff);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_TextColor, $0000ff);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Weight, 1);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Justification, stylehint_just_LeftRight);

      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_TextColor, $82c1fb);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Subheader,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_Subheader,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_SubHeader,
                        stylehint_Size, 1);
      glk_stylehint_set(wintype_TextGrid, style_SubHeader,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Note,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextGrid, style_Note,
                        stylehint_BackColor, $000000);

      glk_stylehint_set(wintype_TextGrid, style_BlockQuote,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_BlockQuote,
                        stylehint_BackColor, $ffffff);
  }

  rfalse; ! si te olvidas esta linea, el juego no funcionará bien
];


!===============================================================================
! (3) Modificar Mensajes de la Libreria; Otros Includes; Incluir VerbLib.h
!-------------------------------------------------------------------------------


!Include "Rastros_NG";


Object LibraryMessages
  with
    mostrar_nombre [ l;
      l = LugarReal().(lm_o.door_dir);
      if (l == nothing) print (the) lm_o;
      else              l.mostrar_nombre();
    ],
    before [;
      Look:
        switch (lm_n) {
!          5, 6: new_line;
!                if (lm_o ~= location) {
!                  if (lm_o has supporter) print "Sobre ";
!                  else                    print "En ";
!                  print (the) lm_o;
!                  print " ", (puedes_) " ver ";
!                } else print "", (_Puedes_) " ver ";
!
!                if (n == 5) print "también ";
!                WriteListFrom(child(lm_o),
!                              ENGLISH_BIT + WORKFLAG_BIT + RECURSE_BIT +
!                              TERSE_BIT + CONCEAL_BIT); ! Quitamos PARTINV_BIT
!                if (lm_o ~= location) ".";
!                ".";

          7: print "No observ", (as_) " nada digno de mención al mirar hacia ";
             self.mostrar_nombre();
             ".";
        }

      Prompt:
        ImprimirPrompt();
        rtrue;

      Go:
        switch (lm_n) {
          2: if (estoyEmpujando)
               "^No ", (puedes_) " seguir empujando porque no hay salida
               hacia ", (the) noun, ".";
             if (noun == in_obj)
               "No ves ningún sitio en el que puedas entrar.";
             "No ", (puedes_) " ir por ahí, porque no hay salida hacia ",
              (the) noun, ".";
          5: if (estoyEmpujando)
               "^No ", (puedes_) " empujar nada a través ", (del) noun, ".";
             "No ", (puedes_) " pasar a través ", (del) noun, ".";
        }
        
      Take:
        if (lm_n == 1) {
          print "Reco";
          if (player.persona == PRIMERA_PERSONA_SINGULAR) print "j";
          else                                            print "g";
          print (es_) " ";
          if (noun has moved) print (the) noun;
          else                print (a) noun;
          ".";
        }

      Drop:
        if (lm_n == 4) "Dej", (as_) " ", (the) lm_o, ".";

      Remove:
        if (lm_n == 3) {
          if (verb_word == 'quita') {
            "Quit", (as_) " ", (the) lm_o, " ", (del) second, ".";
          } else {
            "Sac", (as_) " ",  (the) lm_o, " ", (del) second, ".";
          }
        }

      GetOff:
        print "Pero si no estas en ";
        if (lm_o ofclass Lugar) lm_o.mostrar_nombre();
        else                    print (the) lm_o;
        "...";

      Exit:
        if (lm_n == 1) {
          "Si quieres moverte, indica hacia dónde quieres ir.";
        }

      Miscellany:
        switch (lm_n) {
           4: TextoLlamativo(" ¡Enhorabuena! Has acabado la aventura ");
              rtrue;
          10: rtrue;
          13: ! Reactivamos timer en caso de UNDO:
              ControlTimer.ReactivarTick();
              "[Retrocediendo al turno anterior.]";
          17: switch (random(4)) {
                1: "Está muy oscuro y no puedes ver nada.";
                2: "Todo está demasiado oscuro y no aprecias nada con
                    claridad.";
                3: "La oscuridad te impide ver dónde te encuentras.";
                4: "Te mueves a tientas a través de una oscuridad que te impide
                    ver nada.";
              }
          19: "Has tenido días mejores...";
          30: switch (random(3)) {
                1: "No encuentro eso que dices.";
                2: "No veo nada parecido por aquí.";
                3: "Parece que no hay nada de eso.";
              };
          27: "Las palabras se te agolpan en los labios.";
          38: switch (random(5)) {
                1: "¿Qué quieres decir con eso?";
                2: "Lo siento, no te entiendo.";
                3: "Intenta ser un poco más preciso.";
                4: "No comprendo eso que dices.";
                5: "¿Qué intentas decir?";
              }
          39: ! Cuando el jugador intenta llevar a cabo una acción usando una
              ! palabra que está en la lista de nombres de la localidad actual:
              switch (action_to_be) {
                ##Examine:  PrintOrRun(location, description);
                ##Enter:    "Ya estás aquí.";
                ##SalirPor: <<Exit>>; ! SALIR DEL PASILLO estando en el pasillo
                default:    "Debes ser más específico.";
              }
              rtrue;
        }
    ];


! Hay que definirla antes de incluir Moviles_NG:
Class Lugar
!  class LugarConRastro
  with
!   sgw_mus Estancia_ogg,
    sgw_img Oscuridad_jpg,
    sgw_vol VOLUMEN_FONDO,
    describe [;
      PrintOrRun(self, description);
      if (mostrarSalidas) {
        new_line;
        glk_set_style(style_Emphasized);
        <Salidas>;
        glk_set_style(style_Normal);
        rtrue;
      }
    ],
    mostrar_nombre [;
      if (self has visited && self provides nombre_si_visitado) {
        PrintOrRun(self, nombre_si_visitado, 1); rfalse;
      }
      if (self hasnt visited && self provides nombre_no_visitado) {
        PrintOrRun(self, nombre_no_visitado, 1); rfalse;
      }
      if (self provides nombre_direccion) PrintOrRun(self, nombre_direccion, 1);
      else                                print (name) self;
    ],
    number,
    dibujado false,                   ! Necesario para Mapeador.h
    before [
      l;
      l = LugarReal();

      ! Cuando se usa "EXAMINA EL PASILLO":
      Examine:
        if (noun ofclass Lugar) {
          if      (noun == l.n_to)   <<Examine n_obj>>;
          else if (noun == l.s_to)   <<Examine s_obj>>;
          else if (noun == l.e_to)   <<Examine e_obj>>;
          else if (noun == l.w_to)   <<Examine w_obj>>;
          else if (noun == l.ne_to)  <<Examine ne_obj>>;
          else if (noun == l.nw_to)  <<Examine nw_obj>>;
          else if (noun == l.se_to)  <<Examine se_obj>>;
          else if (noun == l.sw_to)  <<Examine sw_obj>>;
          else if (noun == l.u_to)   <<Examine u_obj>>;
          else if (noun == l.d_to)   <<Examine d_obj>>;
          else if (noun == l.in_to)  <<Examine in_obj>>;
          else if (noun == l.out_to) <<Examine out_obj>>;
        }

      ! Cuando se usa "VE AL PASILLO":
      Enter, SalirA:
        if (noun ofclass Lugar) {
          if      (noun == l.n_to)   <<Go n_obj>>;
          else if (noun == l.s_to)   <<Go s_obj>>;
          else if (noun == l.e_to)   <<Go e_obj>>;
          else if (noun == l.w_to)   <<Go w_obj>>;
          else if (noun == l.ne_to)  <<Go ne_obj>>;
          else if (noun == l.nw_to)  <<Go nw_obj>>;
          else if (noun == l.se_to)  <<Go se_obj>>;
          else if (noun == l.sw_to)  <<Go sw_obj>>;
          else if (noun == l.u_to)   <<Go u_obj>>;
          else if (noun == l.d_to)   <<Go d_obj>>;
          else if (noun == l.in_to)  <<Go in_obj>>;
          else if (noun == l.out_to) <<Go out_obj>>;
        }
        
      GetOff:
        if (noun == LugarReal()) <<Exit>>;
        rfalse;
    ],
    after [ o;
      Go:
        ! Si se está mostrando la imagen de un personaje, quitarla antes:
        timer_imagen_personaje.ocultar_imagen();
        SGW_MarcoDeTrabajo(1);
        ! Actualizar el volumen de los sonidos:
        objectloop (o in self) if (o ofclass Sonido) o.cambiar_volumen();
    ],
  has
    scenery light;
    

#ifdef DEBUG;
[ WaitDelay delay;
  return KeyDelay(delay);
];
#endif;


Include "elcirculo.bli";    ! Los recursos multimedia de la aventura
Include "SGW+DMX_NG";       ! Entre Parser y VerbLib
Include "BetaTest";         ! Modo betatesting

Include "VerbLib";

Include "Barra";            ! Barra de estado personalizable
Include "Contenedor";       ! Contenedores
Include "Decorado_NG";      ! Objetos de decorado
Include "Diary";
Include "EscenarioAbrible"; ! Escenario que se puede abrir y cerrar
Include "Etemas";           ! Los temas de conversación
!Include "EventList_NG";     ! Listas de mensajes
Include "ExaminarFalso";    ! Poder examinar objetos sólo con su nombre
Include "GlulxBox";         ! Usar el comando box con Glulx - gracias a Eliuk
Include "Gtalk_NG";         ! Conversaciones
Include "IntNombre_NG";     ! Poder usar adjetivos como en InformATE
Include "Moviles_NG";       ! La librería Moviles retocada por mí
Include "Pistas";           ! Las pistas creadas con ZIPI
Include "PNJpuertas_NG";    ! La librería PnjPuertas retocada por mí (muy poco)
Include "PNJactor_NG";      ! Librerías que hacen que un PNJ pueda coger y dejar
Include "PNJacciones_NG";   ! Poner detrás de Moviles, PNJpuertas y PNJactor
Include "Prand_NG";         ! Listas de mensajes
!Include "Teletipo";         ! Teletipo para sacar mensajes letra a letra
Include "Timer";            ! Mi librería de eventos temporizados


!===============================================================================
! (4) Rutinas Initialise() e IniciarAventura()
!-------------------------------------------------------------------------------


[ Initialise r v;
  IniciarGraficosSonidos();
  openGraphicWindow(ALTURA_LOGO_MENU);
  clearGraphicWindow();
  StatusLineHeight(ALTURA_MENU_PRINCIPAL);
  clearMainWindow();
  viewImageCenter(Logo_Circulo_Con_Letras_jpg);
  v = Damusix.QueVolumenCanal(CANAL_FONDO);
  Damusix.AsignarCanal(Darkwalk_ogg, CANAL_FONDO, v, SONIDO_REPETIR);
  Damusix.Tocar(Darkwalk_ogg);
  ZIPI_Intro();
  do {
    r = ZIPI_RunMenu(ZIPI_Menu_Principal, true);
  } until (r ~= 3);
  if (r ~= 2) quit;
  StatusLineHeight(1);
  if (hayGraficos) EncenderGraficos();
  else             ApagarGraficos();
  clearTextWindow();
  ! Los mouse events hay que iniciarlos aquí, y no en IniciarAventura
  ! (no sé por qué, pero si lo pones en IniciarAventura, no funciona):
  ! glk_request_mouse_event(gg_bigwin);
];


[ IniciarAventura logo;

  location = thedark;

  dibujarEstado = false;

  ! Esto es para que el juego dé siempre la descripción de la habitación, aunque
  ! ya la hayamos visitado
  lookmode = 2;

  ! Inventario en una sola frase:
  inventory_style = ENGLISH_BIT + RECURSE_BIT + FULLINV_BIT;

  ! Parseado estricto (de la librería IntNombre):
  parseado_estricto = 1;

  ! Nombre de la oscuridad
  thedark.short_name = "Oscuridad";
  
  ! Localización donde comienza el jugador
  location = cuarto_katie;

!  AsignarPersona(PRIMERA_PERSONA + PERSONA_SINGULAR);
!  give player female;

!  clearTextWindow();

  if (logo) {
    clearTextWindow();
    clearGraphicWindow();
!    DibujaLogoAlien();
  }

  timer_telefono_katie.AsignarGestor(1);
  timer_becca.AsignarGestor(2);
  ControlTimer.ActivarTick(TIMER_TICK);

  ! Esto hay que ponerlo para que no aparezca tu otro yo moviéndose solo:
  PNJ_Ruta(katie, MOVIMIENTO_NINGUNO);
  ChangePlayer(katie);
!  move uniforme_katie to katie;

  PNJ_Ruta(becca, MOVIMIENTO_PERSEGUIR, katie);
  PNJ_Ruta(testigo, MOVIMIENTO_NINGUNO);

  IniciarMoviles();
  IniciarPuertas();
!  IniciarRastros();

  Damusix.PararCanal(CANAL_FONDO);
  Damusix.LiberarCanal(DarkWalk_ogg);
  Damusix.VolumenCanal(CANAL_FONDO, VOLUMEN_FONDO);
  sonido_telefono_katie.sonar();
  KeyDelay();
  openGraphicWindow(altoVentanaGrafica);
  glk_request_hyperlink_event(gg_mainwin);
  glk_request_hyperlink_event(gg_statuswin);
];


!===============================================================================
! (5) Rutinas de la Libreria Implementadas, Reemplazadas o Ampliadas
!-------------------------------------------------------------------------------


[ AfterPrompt;
  ! Pasándole el parámetro 3 en lugar de 1, lo que hacemos es pedirle que
  ! actualice la música pero no los gráficos:
  if (timer_imagen_personaje.mostrandose()) SGW_MarcoDeTrabajo(3);
  else                                      SGW_MarcoDeTrabajo(1);
];


! Modificado para que al empujar un objeto a una localidad se muestre
! más información:
[ AllowPushDir
  i tmp;
  if (parent(second) ~= compass) return L__M(##PushDir, 2, noun);
  if (second == u_obj or d_obj)  return L__M(##PushDir, 3, noun);
  AfterRoutines(); i = noun; move i to player;
  tmp = location;                                     ! (c) Alpha
  estoyEmpujando = true;                              ! (c) Alpha
  <Go second>;
  estoyEmpujando = false;                             ! (c) Alpha
  if (location == thedark) move i to real_location;
  else                     move i to location;
  if (tmp ~= location && location ~= thedark)
    PrintOrRun(i, describe);                          ! (c) Alpha
];


[ Amusing;
  rfalse;
];


[ DrawStatusLine;
  if (dibujarEstado) {
    barra_estado.dibujar();
  }
];


[ InScope actor
  l;
  
  ! Así podemos usar "VE AL SALON" y "EXAMINA EL SALON" en lugar de
  ! "VE AL SUR" y "EXAMINA EL SUR" (ver también la clase Lugar): 
  l = LugarReal();
  if (l provides n_to)   PlaceInScope(l.n_to);
  if (l provides s_to)   PlaceInScope(l.s_to);
  if (l provides e_to)   PlaceInScope(l.e_to);
  if (l provides w_to)   PlaceInScope(l.w_to);
  if (l provides ne_to)  PlaceInScope(l.ne_to);
  if (l provides nw_to)  PlaceInScope(l.nw_to);
  if (l provides se_to)  PlaceInScope(l.se_to);
  if (l provides sw_to)  PlaceInScope(l.sw_to);
  if (l provides u_to)   PlaceInScope(l.u_to);
  if (l provides d_to)   PlaceInScope(l.d_to);
  if (l provides in_to)  PlaceInScope(l.in_to);
  if (l provides out_to) PlaceInScope(l.out_to);

  ! Así le podemos pedir a Becca que coja el teléfono aunque el teléfono no
  ! esté presente:
  if (actor == becca && LugarReal() ~= cocina_katie) {
    PlaceInScope(telefono_katie);
  }

  rfalse;
];


! Esta versión no muestra los puntos cardinales y representa las direcciones
! como los nombres de los lugares a los que se llega por esa dirección:
[ LanguageDirection d
  l par;
  par = true;
  switch (d) {
    n_to:    par = false; ! print "al norte";
    s_to:    par = false; ! print "al sur";
    e_to:    par = false; ! print "al este";
    w_to:    par = false; ! print "al oeste";
    ne_to:   par = false; ! print "al nordeste";
    nw_to:   par = false; ! print "al noroeste";
    se_to:   par = false; ! print "al sudeste";
    sw_to:   par = false; ! print "al suroeste";
    u_to:    glk_set_hyperlink(u_obj);   print "arriba"; glk_set_hyperlink(0);
    d_to:    glk_set_hyperlink(d_obj);   print "abajo";  glk_set_hyperlink(0);
    in_to:   glk_set_hyperlink(in_obj);  print "dentro"; glk_set_hyperlink(0);
    out_to:  glk_set_hyperlink(out_obj); print "fuera";  glk_set_hyperlink(0);
    default: return RunTimeError(9, d);
  }
  l = LugarReal();
  print " ";
  if (par) print "(";
  glk_set_hyperlink(l.d);
  l.d.mostrar_nombre();
  glk_set_hyperlink(0);
  if (par) print ")";
];


! Modificado para que ?, !, ¿, ¡ se separen de las palabras al parsear:
[ QuitarAcentos buf pars x i word at len;
  Tokenise__(buf, pars);
  for (x = 1: x <= tokenCount(pars): x++) { ! para cada token
    word = tokenDict(pars,x); ! dictionary value of token 1,2,3...
    at   = tokenPos(pars,x);  ! position in buffer of token 1,2,3...
    len  = WordLength(x);     ! length in chars of token 1,2,3...

    if (word == 0) { ! no comprendida
      for (i = at: i < at + len: i++)
        switch (buf->i) {
          'á': buf->i = 'a';
          'é': buf->i = 'e';
          'ë': buf->i = 'e';
          'í': buf->i = 'i';
          'ó': buf->i = 'o';
          'ú': buf->i = 'u';
          'ü': buf->i = 'u';
          'ñ': buf->i = 'n';
          '?': buf->i = ' ';
          '¿': buf->i = ' ';
          '!': buf->i = ' ';
          '¡': buf->i = ' ' ;
        }
      Tokenise__(buf, pars);
    }
  }
];


! Modificado de la versión de ExaminarFalso. Ahora, cada objeto puede llevar
! asociado un menú de acciones:
[ UnknownVerb x
  tmp obj r;
  tmp = ExaminarFalso.EF_UnknownVerb(x);
  if (tmp) {
    obj = ExaminarFalso.objetoVerboDesconocido;
    if (obj provides ZIPI_item) {
      if (gg_menuwin ~= 0) glk_window_close(gg_menuwin, 0);
      gg_menuwin = glk_window_open(gg_mainwin,
                                   winmethod_Right + winmethod_Fixed,
                                   25, wintype_TextGrid, GG_MENUWIN_ROCK);
      glk_set_window(gg_menuwin);
      glk_cancel_hyperlink_event(gg_mainwin);    ! Durante el menú, desactiva
      glk_cancel_hyperlink_event(gg_statuswin);  ! los enlaces de otras ventanas
      r = RunMenu(obj);
      glk_window_close(gg_menuwin, 0);
      gg_menuwin = 0;
      glk_set_window(gg_mainwin);
      glk_request_hyperlink_event(gg_mainwin);   ! Se vuelven a activar los
      glk_request_hyperlink_event(gg_statuswin); ! enlaces de otras ventanas
      ! Si no se ha escogido nada en el menú de acciones (se ha seleccionado
      ! 'Q' de salir), devolvemos 'verbo.nulo' para no lanzar ninguna acción:
      if (~~r) return 'verbo.nulo';
      ! Si se ha escogido una acción en el menú, guardamos en palabraMenu
      ! el verbo asociado a esa acción y devolvemos 'examinar.falso' para
      ! que el control vaya ahora a ExaminarFalsoSub():
      ExaminarFalso.palabraMenu = r;
      ExaminarFalso.mostrarExaminar = true;      ! Mostramos "> ex objeto"
      return tmp; ! 'examinar.falso'
    } else {
      ! El jugador ha tecleado el nombre de un objeto que no tiene menú, por
      ! lo que sólo pueden haber dos posibilidades: o se examina el objeto, o
      ! se mueve al jugador a una nueva localidad. Ambas cosas se harán en
      ! la rutina ExaminarFalsoSub():
      return tmp; ! 'examinar.falso'
    }
  } else {
    ! Error de palabra no reconocida:
    return tmp;   ! false
  }
  
];


!===============================================================================
! (6) Incluir SpanishG.h; Otros Includes
!-------------------------------------------------------------------------------


Include "SpanishG";

Include "random";          ! Cambia la función random()
Include "Decir";           ! Para poder usar DECIR ... A ...
Include "Mapeador";
Include "TestMachine_NG";  ! El comprobador automático (c) Alien soft


!===============================================================================
! (7) Clases del Juego
!-------------------------------------------------------------------------------


Class Personaje
  class Movil
  with
    imagen 0,
    hablarand [ _vararg_count
      a;
      self.habla_inicio();
      @call prand _vararg_count a;
      self.habla_fin();
      return a;
    ],
    hablaonce [ _vararg_count
      a;
      self.habla_inicio();
      @call prandonce _vararg_count a;
      self.habla_fin();
      return a;
    ],
    hablalast [ _vararg_count
      a;
      self.habla_inicio();
      @call prandlast _vararg_count a;
      self.habla_fin();
      return a;
    ],
    hablaseq [ _vararg_count
      a;
      self.habla_inicio();
      @call prandseq _vararg_count a;
      self.habla_fin();
      return a;
    ],
    habla [ _vararg_count
      msg nl hablado;
      self.habla_inicio();
      for ( : _vararg_count > 0: _vararg_count--) {
        @copy sp msg;
        if (msg ofclass String) {
          if (hablado) {          
            switch (self.habla_retardo) {
              -1:
               0: KeyDelay();
               default: WaitDelay(self.habla_retardo);
            }
          }
          print (string) msg;
          hablado = true;
        } else {
          nl = msg;
        }
      }
      self.habla_fin(nl);
      rtrue;
    ],
    habla_retardo -1,
    habla_inicio [;
      print "^---";
      glk_set_style(style_User1);
      if (self == player) print "Tú: ";
      else                print (string) self.short_name, ": ";
      glk_set_style(style_Normal);
      print "@<<";
    ],
    habla_fin [ nl;
      print "@>>";
      if (~~nl) new_line;
    ],
    marcha [ dir;
      print "^", (The) self, " ";
      if (dir == in_obj)       print "entra en ";
      else if (dir == out_obj) print "sale por ";
      else                     print "se marcha ";
      print (DirDada) dir, ".^";
    ],
    llega [ dir;
      print "^", (The) self, " ";
      if (self.tipo_de_movimiento == MOVIMIENTO_PERSEGUIR) {
        if (self.perseguido == player) {
          print "te sigue";
        } else {
          print "sigue ", (al) self.perseguido;
        }
      } else {
        print "llega";
      }
      if (dir ~= NULL) {
        print " desde ";
        LugarReal().(dir.door_dir).mostrar_nombre();
        print ".^";
      }
    ],
    mostrar_imagen [;
      if (self.imagen == 0) rfalse;
      ! Ocultamos antes la imagen en caso de que ya estuviera:
      timer_imagen_personaje.ocultar_imagen();
      MostrarImagenAuxiliar(self.imagen);
!      timer_imagen_personaje.duracion = 4 + ControlTimer.numero_ticks();
      timer_imagen_personaje.AgregarGestorAlFinal();
      give timer_imagen_personaje general;
    ],
    after [;
      Examine:
        self.mostrar_imagen();
    ],
    orders [;
      NotUnderstood, Tell, Answer:
        if (actor ~= player) <<Ask actor>>;
    ],
    ! Nosotros usaremos Qselect en lugar de select, para que funcione con el
    ! testeador automático:
    Qselect [ q
      old_pie;
      old_pie = parse_input_externo;
      if (parse_input_externo == -1) parse_input_externo = 1;
      self.select(q);
      parse_input_externo = old_pie;
    ],
  has
    animate proper;

    
Class Sonido
  with
    emision 0,     ! El sonido a emitir
    fuente 0,      ! El objeto del que parte el sonido
    propagacion 3, ! El nº de localidades desde el que se puede oir el sonido
    volumen_principal 100, ! Volumen del sonido cuando el objeto está ahí
    volumen [
      d r;
      if (self.fuente == 0) return 0;
      if (ScopeCeiling(self.fuente) == LugarReal()) {
        return self.volumen_principal;
      }
      move testigo to ScopeCeiling(player);
      PNJ_Ruta(testigo, MOVIMIENTO_PERSEGUIR, self.fuente);
      d = testigo.longitud_precamino;
      PNJ_Ruta(testigo, MOVIMIENTO_NINGUNO);
      remove testigo;
      r = self.volumen_principal -
          (self.volumen_principal / self.propagacion * d);
      if (r < 0) r = 0;
      return r;
    ],
    cambiar_volumen [;
      Damusix.VolumenCanal(self.canal, self.volumen());
    ],
    sonando [;
      return Damusix.SonandoDeFondoCanal(self.canal);
    ],
    tocar_sonido [ snd;
      if (snd ~= 0) self.emision = snd;
      #ifdef DEBUG;
      if (self.emision == 0) {
        "*** ERROR: Se intenta tocar un sonido sin definirlo antes ***"; 
      }
      #endif;
      if (self.emision ~= 0) {
        Damusix.AsignarCanal(self.emision, self.canal, self.volumen(),
                             SONIDO_REPETIR);
        Damusix.TocarCanal(self.canal);
      }
    ],
    parar_sonido [;
      Damusix.PararCanal(self.canal);
    ],
    sonar [ snd;
      self.tocar_sonido(snd);
    ],
    parar [;
      self.parar_sonido();
    ],    
    quitar [;
      remove self;
      give self absent;
    ],
  has
    concealed;


Class Destino
  with
    nombre_destino 0,
    before [;
      Go:
        coche_rachel.volver = location;
    ];


!===============================================================================
! (8) Objetos del Juego
!-------------------------------------------------------------------------------


! ====================================================================
! OBJETOS DE SOPORTE
! ====================================================================


Object barra_estado
  class objeto_barra_estado
  with
    modo BE_COMPUESTO,
    disposicion
      1  1 true BE_LOCALIDAD
      68 1 true BE_TURNOS,
    lineas_inv
      BE_INV_TOTAL;


! Lugar necesario para que no haya errores al compilar si no hay localidades
! definidas con nombre_si_visitado, nombre_no_visitado y nombre_dirección:
Object
  class Lugar
  with
    nombre_si_visitado NULL,
    nombre_no_visitado NULL,
    nombre_direccion   NULL;


Object testigo
  class Movil;


Object timer_imagen_personaje
  class GestorTimer
  with
    duracion TIMER_DURACION_IMAGEN_PERSONAJE,
    mostrandose [;
      return self has general;
    ],
    ocultar_imagen [;
      if (self.mostrandose()) self.evento();
    ],
    evento [;
      OcultarImagenAuxiliar();
      give self ~general;
      self.EliminarGestor();
      MostrarImagenLocalidad();
    ];


! ====================================================================
! MENÚS ZIPI
! ====================================================================


Array teclas_opciones --> '1' '2' '3' '4' '5' '6' '7' '8' '9' 'A'
                          'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'L' 'M'
                          'O' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z';
Array numero_opciones -> 30;
    

[ ZIPI_RunMenu _m top
  i j count cur key target redibujar r k tec;

  redibujar = 1;
  cur = 0;
  count = _m.#ZIPI_item / WORDSIZE; count = count + 2;

  for (::) {
    if (redibujar) {
      ZIPI_PintaTitulo(_m.ZIPI_titulo);
      redibujar = 0;
    }

    for (i = 0, tec = 0: i < count - 2: i++) {
      j = i + 3;
      ZIPI_setcursor(5,j);
      if ((_m.&ZIPI_item-->i) ~= ZIPI_Separador) {
        glk(256, teclas_opciones-->tec);
        print "[";
        glk_set_style(style_Header);
        print (char) teclas_opciones-->tec;
        glk_set_style(style_Normal);
        print "] ";
        numero_opciones->tec = i;
        tec++;
      }
      if ((_m.&ZIPI_item-->i).ZIPI_titulo ofclass Routine)
        (_m.&ZIPI_item-->i).ZIPI_titulo();
      else print (string) (_m.&ZIPI_item-->i).ZIPI_titulo;
      glk_set_style(style_Normal);
      glk(256, 0);
    }

    j = i + 4;
    ZIPI_setcursor(5, j);
    glk(256, 'Q');
    if (top) print (s_head) "[Q] Salir";
    else     print (s_head) "[Q] Volver";
    glk(256, 0);
    j = cur + 3;
    ZIPI_setcursor(2, j);
    print (s_emph) ">";
    ZIPI_setcursor(2, j);
    key = ZIPI_tecla(gg_statuswin);
    print " ";

    if (key > ZIPI_EVENTO_HYPER) {
      cur = key - ZIPI_EVENTO_HYPER - 2;
      if (cur == -1) key = 27;
      else           key = 13;
    }

    switch (key) {
      'k', 'p', '-', '_', 129, -4:
        do {
          cur--;
          if (cur == count - 2) cur--;
          if (cur < 0) cur = count - 1;
        } until ((_m.&ZIPI_item-->cur) ~= ZIPI_Separador);
        break;
      'j', 'n', '=', '+', 130, -5:
        do {
          cur++;
          if (cur == count - 2) cur++;
          if (cur >= count) cur = 0;
        } until ((_m.&ZIPI_item-->cur) ~= ZIPI_Separador);
        break;
      'q', 'Q', 27, 131, 10, 8, -2, keycode_Escape:
        rfalse;
 
      132, 13, 'n', ' ', -3, -6:
    .Aceptar;
        if (cur == count - 1) rfalse;
        if (cur == count - 2) break;
        target = _m.&ZIPI_item-->cur;
        if (target ofclass ZIPI_Menu)          ZIPI_RunMenu(target);
        else if (target ofclass ZIPI_Pista)    ZIPI_RunPista(target);
        else if (target provides ZIPI_cambiar) target.ZIPI_cambiar();
        else {
          glk_request_mouse_event(gg_statuswin);
          r = ZIPI_RunOtro(target);
          glk_cancel_mouse_event(gg_statuswin);
          if (target == ZIPI_Restaurar) return 3;
          if (r == 2) return r;
        }
        redibujar = 1;
        break;
    }
    ! Busca la tecla entre el vector
    for (k = 0 : k < 31 : k++) {
      if (key == (teclas_opciones-->k) && k < tec) { 
        cur = numero_opciones->k;
        key = 132;
        jump Aceptar;
      }
    }
  }
  rfalse;
];


[ ZIPI_RunOtro _o
  r;
  closeGraphicWindow();
  StatusLineHeight(ALTURA_MENU_COMPLETA);
  ZIPI_PintaTitulo(_o.ZIPI_titulo);
  print "^";
  r = _o.ZIPI_ejecutar();
  if (~~r) ZIPI_Espera();
  StatusLineHeight(ALTURA_MENU_PRINCIPAL);
  openGraphicWindow(ALTURA_LOGO_MENU);
  clearGraphicWindow();
  viewImageCenter(Logo_Circulo_Con_Letras_jpg);
  return r;
];


[ ZIPI_tecla win sw
  key done ix;
  glk_request_hyperlink_event(win);
  if (~~sw) glk_request_mouse_event(win); 
  glk_request_char_event(gg_mainwin);
  while (~~done) {
    glk_select(gg_event);
    ix = HandleGlkEvent(gg_event, 1, gg_arguments);
    if (ix == 2) {
      key = gg_arguments-->0;
      done = true;
    } else if (ix >= 0) {
      switch (gg_event-->0) {
        2, 8: ! evtype_CharInput, evtype_Hyperlink
              key = gg_event-->2;
              done = true;
           4: ! evtype_MouseInput
              key = 0; ! Devuelve la tecla 0, para no interferir
              done = true;
        5, 6: ! evtype_Arrange, evtype_Redraw
              DrawStatusLine();     ! Redibujamos la línea de estado
              glk_set_window(win);  ! Volvemos a la ventana anterior
              ! Cuando se redimensiona habiendo un menú de acciones, se
              ! devuelve la tecla 0, lo que hará que se redibuje la ventana:
              key = 0;
              done = true;
      }
    }
  }
  glk_cancel_char_event(gg_mainwin);
  glk_request_hyperlink_event(win);
  if (~~sw) glk_request_mouse_event(win);
  return key;
];


Object ZIPI_Accesibilidad
  class ZIPI_Menu
  with
    ZIPI_titulo "Opciones de accesibilidad",
    ZIPI_item
      ZIPI_Tiempo_Real;


Object ZIPI_Configuracion
  class ZIPI_Menu
  with
    ZIPI_titulo "Opciones de gráficos y sonido",
    ZIPI_item
      ZIPI_Graficos
      ZIPI_Tamano_Graficos
      ZIPI_Sonido
      ZIPI_Sonido_Fondo
      ZIPI_Separador
      ZIPI_Aumentar_Texto
      ZIPI_Disminuir_Texto
      ZIPI_Separador
      ZIPI_Accesibilidad;


Object ZIPI_Graficos
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      if (hayGraficos) "Gráficos: SÍ (recomendado)";
      else             "Gráficos: NO";
    ],
    ZIPI_cambiar [;
      hayGraficos = ~~hayGraficos;
    ],
    ZIPI_ejecutar [; rtrue; ];


Object ZIPI_Jugar_Con_Intro
  class ZIPI_Otro
  with
    ZIPI_titulo "Comenzar la aventura con introducción",
    ZIPI_ejecutar [;
      StatusLineHeight(1);
      glk($002A, gg_statuswin);  ! window_clear
      glk($002F, gg_mainwin);    ! set_window
      if (hayGraficos) EncenderGraficos();
      else             ApagarGraficos();
      clearTextWindow();
      Introduccion();
      IniciarAventura();
      dibujarEstado = true;
      return 2;
    ];

    
Object ZIPI_Jugar_Sin_Intro
  class ZIPI_Otro
  with
    ZIPI_titulo "Comenzar la aventura saltando la introducción",
    ZIPI_ejecutar [;
      StatusLineHeight(1);
      glk($002A, gg_statuswin);  ! window_clear
      glk($002F, gg_mainwin);    ! set_window
      if (hayGraficos) EncenderGraficos();
      else             ApagarGraficos();
      clearTextWindow();
      IniciarAventura(true);
      dibujarEstado = true;
      return 2;
    ];


Object ZIPI_Menu_Principal
  class ZIPI_Menu
  with
    ZIPI_titulo "EL CÍRCULO - (c) Alpha Aventuras 2012",
    ZIPI_item
      ZIPI_Jugar_Con_Intro
      ZIPI_Jugar_Sin_Intro
      ZIPI_Restaurar
      ZIPI_Configuracion
      ZIPI_Separador
      ZIPI_Menu1;


Object ZIPI_Restaurar
  class ZIPI_Otro
  with
    ZIPI_titulo "Restaurar una partida guardada",
    ZIPI_ejecutar [ res fref;
      StatusLineHeight(1);
      clearTextWindow();
      glk($002F, gg_mainwin);    ! set_window
!      ImprimirPrompt();
      fref = glk($0062, $01, $02, 0); ! fileref_create_by_prompt
      if (fref == 0) jump RFailed;
      gg_savestr = glk($0042, fref, $02, GG_SAVESTR_ROCK); ! stream_open_file
      glk($0063, fref); ! fileref_destroy
      if (gg_savestr == 0) jump RFailed;

      @restore gg_savestr res;

      glk($0044, gg_savestr, 0); ! stream_close
      gg_savestr = 0;

    .RFailed;
      ZIPI_Intro();
      glk($002F, gg_statuswin);
      StatusLineHeight(ALTURA_MENU_PRINCIPAL);
      print "^Error: no se ha podido cargar la partida.";
      rfalse;
    ];
      

Object ZIPI_Salir
  class ZIPI_Otro
  with
    ZIPI_titulo "Salir",
    ZIPI_ejecutar [;
      quit;
    ];


Object ZIPI_Sonido
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      if (haySonido) "Sonido global: SÍ (recomendado)";
      else           "Sonido global: NO";
    ],
    ZIPI_cambiar [;
      haySonido = ~~haySonido;
      if (haySonido) Damusix.ActivarAudio();
      else           Damusix.DesactivarAudio();
    ],
    ZIPI_ejecutar [; rtrue; ];


Object ZIPI_Sonido_Fondo
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      if (haySonidoFondo) "Sonido de fondo: SÍ (recomendado)";
      else                "Sonido de fondo: NO";
    ],
    ZIPI_cambiar [;
      haySonidoFondo = ~~haySonidoFondo;
      if (haySonidoFondo) {
        Damusix.VolumenCanal(CANAL_FONDO, VOLUMEN_FONDO);
      } else {
        Damusix.VolumenCanal(CANAL_FONDO, 0);
      } 
    ],
    ZIPI_ejecutar [; rtrue; ];


Object ZIPI_Tamano_Graficos
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      switch (altoVentanaGrafica) {
        GRAFICOS_MINUSCULOS: "Tamaño de gráficos: ",
                             GRAFICOS_MINUSCULOS, " px. (MINÚSCULOS)";
        GRAFICOS_PEQUENOS:   "Tamaño de gráficos: ",
                             GRAFICOS_PEQUENOS, " px. (PEQUEÑOS)";
        GRAFICOS_MEDIANOS:   "Tamaño de gráficos: ",
                             GRAFICOS_MEDIANOS, " px. (MEDIANOS, recomendado)";
        GRAFICOS_GRANDES:    "Tamaño de gráficos: ",
                             GRAFICOS_GRANDES,  " px. (GRANDES)";
        default:             "Tamaño de gráficos: ",
                             altoVentanaGrafica, " px.";          
      }
    ],
    ZIPI_cambiar [;
      if (altoVentanaGrafica < GRAFICOS_GRANDES)
        altoVentanaGrafica = altoVentanaGrafica + 50;
      else
        altoVentanaGrafica = GRAFICOS_MINUSCULOS;
    ],
    ZIPI_ejecutar [; rtrue; ];


Object ZIPI_Aumentar_Texto
  class ZIPI_Otro
  with
    ZIPI_titulo "Aumentar tamaño del texto",
    ZIPI_cambiar [;
      glk_incr_fontsize();
      glk_window_get_arrangement(glk_window_get_parent(gg_statuswin),
                                 gg_arguments, gg_arguments + WORDSIZE,
                                 gg_arguments + 2 * WORDSIZE);
      glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
                                 gg_arguments-->0, gg_arguments-->1,
                                 gg_arguments-->2);
      ! Esto sólo se ve en el menú principal, porque durante el juego
      ! el menú de configuración ocupa toda la pantalla, y luego
      ! restauramos el gráfico de la localidad actual:
      viewImageCenter(Logo_Circulo_Con_Letras_jpg);
    ],
    ZIPI_ejecutar [; rtrue; ];


Object ZIPI_Disminuir_Texto
  class ZIPI_Otro
  with
    ZIPI_titulo "Disminuir tamaño del texto",
    ZIPI_cambiar [;
      glk_decr_fontsize();
      glk_window_get_arrangement(glk_window_get_parent(gg_statuswin),
                                 gg_arguments, gg_arguments + WORDSIZE,
                                 gg_arguments + 2 * WORDSIZE);
      glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
                                 gg_arguments-->0, gg_arguments-->1,
                                 gg_arguments-->2);
      ! Esto sólo se ve en el menú principal, porque durante el juego
      ! el menú de configuración ocupa toda la pantalla, y luego
      ! restauramos el gráfico de la localidad actual:
      viewImageCenter(Logo_Circulo_Con_Letras_jpg);
    ],
    ZIPI_ejecutar [; rtrue; ];


Object ZIPI_Tiempo_Real
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      if (hayTiempoReal) "Tiempo real: SÍ (recomendado)";
      else               "Tiempo real: NO";
    ],
    ZIPI_cambiar [;
      hayTiempoReal = ~~hayTiempoReal;
    ],
    ZIPI_ejecutar [; rtrue; ];


! ====================================================================
! MENÚS DE ACCIONES
! ====================================================================


! Muestra el menú de acciones de un objeto:
[ RunMenu _m top
  i j count cur key target redibujar k tec altura anchura delta oldcur;

  redibujar = 1;
  cur = 0;
  count = _m.#ZIPI_item / WORDSIZE; count = count + 2;

  for (::) {
    glk_window_get_size(gg_menuwin, gg_arguments, gg_arguments + WORDSIZE);
    anchura = gg_arguments-->0;
    altura  = gg_arguments-->1;

    if (redibujar) {
      glk_window_clear(gg_menuwin);
      glk_set_style(style_Input);
      print " ", (string) _m.input_link, ":^";
      glk_set_style(style_Normal);
      redibujar = 0;
    }

    if (delta > 0) {
      glk($002B, gg_menuwin, anchura - 1, 1);
      print "@@94";
    }

    for (i = 0 + delta, tec = 0 + delta: i < count - 2: i++) {
      j = i + 3 - delta;
      if (j >= altura) break;
      glk($002B, gg_menuwin, 4, j - 1);
      if ((_m.&ZIPI_item-->i) ~= ZIPI_Separador) {
        glk(256, teclas_opciones-->tec);
        print "[";
        glk_set_style(style_Header);
        print (char) teclas_opciones-->tec;
        glk_set_style(style_Normal);
        print "] ";
        numero_opciones->tec = i;
        tec++;
      }
      if ((_m.&ZIPI_item-->i).ZIPI_titulo ofclass Routine)
        (_m.&ZIPI_item-->i).ZIPI_titulo();
      else print (string) (_m.&ZIPI_item-->i).ZIPI_titulo;
      glk(256, 0);
    }

    j = i + 4 - delta;
    if (j <= altura) {
      glk($002B, gg_menuwin, 4, j - 1);
      glk(256, 'Q');
      if (top) print (s_head) "[Q] Salir";
      else     print (s_head) "[Q] Volver";
      glk(256, 0);
    } else {
      glk($002B, gg_menuwin, anchura - 1, altura - 1);
      print "v";
    }
    j = cur + 3 - delta;
    glk($002B, gg_menuwin, 1, j - 1);
    print (s_emph) ">";
    glk($002B, gg_menuwin, 1, j - 1);
    
    key = ZIPI_tecla(gg_menuwin, true);
    if (key == 0) redibujar = 1;
    print " ";

    if (key > ZIPI_EVENTO_HYPER) {
      cur = key - ZIPI_EVENTO_HYPER - 2;
      if (cur == -1) key = 27;
      else           key = 13;
    }

    switch (key) {
      'k', 'p', '-', '_', 129, -4:
        do {
          oldcur = cur;
          cur--;
          if (cur == count - 2) cur--;
          if (cur < 0) cur = 0; ! cur = count - 1;
          if (j <= 3) {
            delta = delta - (oldcur - cur);
            redibujar = 1;
          }
        } until ((_m.&ZIPI_item-->cur) ~= ZIPI_Separador);
        break;
      'j', 'n', '=', '+', 130, -5:
        do {
          oldcur = cur;
          cur++;
          if (cur == count - 2) cur++;
          if (cur > count - 1) cur = count - 1; ! cur = 0;
          if (j >= altura - 1) {
            delta = delta + (cur - oldcur);
            redibujar = 1;
          }
        } until ((_m.&ZIPI_item-->cur) ~= ZIPI_Separador);
        break;
      'q', 'Q', 27, 131, 10, 8, -2, keycode_Escape:
        rfalse;
 
      132, 13, 'n', ' ', -3, -6:
    .Aceptar;
        if (cur == count - 1) rfalse;
        if (cur == count - 2) break;
        target = _m.&ZIPI_item-->cur;
        if (target ofclass ZIPI_Menu)          return RunMenu(target);
        else if (target ofclass ZIPI_Pista)    ZIPI_RunPista(target);
        else if (target provides ZIPI_cambiar) target.ZIPI_cambiar();
        else                                   return target.ZIPI_ejecutar();
        redibujar = 1;
        break;
    }
    ! Busca la tecla entre el vector
    for (k = 0 : k < 31 : k++) {
      if (key == (teclas_opciones-->k) && k < tec) { 
        cur = numero_opciones->k;
        key = 132;
        jump Aceptar;
      }
    }
  }
  rfalse;
];


Object Menu_Apagar
  class ZIPI_Otro
  with
    ZIPI_titulo "Apagar",
    ZIPI_ejecutar [; return 'apaga'; ];


Object Menu_Coger
  class ZIPI_Otro
  with
    ZIPI_titulo "Coger",
    ZIPI_ejecutar [; return 'coge'; ];


Object Menu_Dejar
  class ZIPI_Otro
  with
    ZIPI_titulo "Dejar",
    ZIPI_ejecutar [; return 'deja'; ];


Object Menu_Encender
  class ZIPI_Otro
  with
    ZIPI_titulo "Encender",
    ZIPI_ejecutar [; return 'enciende'; ];

    
Object Menu_Examinar
  class ZIPI_Otro
  with
    ZIPI_titulo "Examinar",
    ZIPI_ejecutar [; return 'ex'; ];


!===============================================================================
! (9) Otras Rutinas Reemplazadas; Rutinas Propias del Juego
!-------------------------------------------------------------------------------


[ ApagarGraficos t;
  hayGraficos = false;
  closeGraphicWindow();
  if (t) print (s_emph) "[Gráficos desactivados.]^";
];


[ BanderaFin df;
  deadflag = df;
  ControlTimer.DesactivarTick();
  Damusix.PararTodo();
];


[ CerrarVentanaMapa;
  glk_window_close(gg_mapawin, 0);
  closeAllWindows();
  clearMainWindow();
  if (hayGraficos) EncenderGraficos();
  #ifdef ControlTimer;
  ControlTimer.ReanudarTick();
  #endif;
  <<Look>>;
];


[ ComoHablar;
  print_ret "[Para hablar con un personaje, usa la forma ~",
            (s_input) "PERSONAJE, lo que sea", "~. Por ejemplo: ~",
            (s_input) "JASON, QUÉ OPINAS DE MADRE", "~.]";
];


! Igualmente, esta versión no muestra puntos cardinales, sino lugares, al
! indicar hacia dónde va un PNJ móvil:
[ DirDada i
  l par;
  par = true;
  switch (i) {
    n_obj:   par = false; ! print "hacia el norte";
    s_obj:   par = false; ! print "hacia el sur";
    e_obj:   par = false; ! print "hacia el este";
    w_obj:   par = false; ! print "hacia el oeste";
    ne_obj:  par = false; ! print "hacia el noreste";
    nw_obj:  par = false; ! print "hacia el noroeste";
    se_obj:  par = false; ! print "hacia el sureste";
    sw_obj:  par = false; ! print "hacia el suroeste";
    u_obj:   par = false; ! print "hacia arriba";
    d_obj:   par = false; ! print "hacia abajo";
    in_obj:  par = false; ! print "al interior";
    out_obj: par = false; ! print "afuera";
    default: print "hacia ", (the) i;
  }
  l = LugarReal();
    
  if (par) print " (";
  if (~~(i == in_obj or out_obj)) print "hacia ";
  l.(i.door_dir).mostrar_nombre();
  if (par) print ")";
];


[ EncenderGraficos t;
  hayGraficos = true;
  openGraphicWindow(altoVentanaGrafica);
  clearGraphicWindow();
  MostrarImagenLocalidad();
  if (t) {
    glk_set_style(style_Emphasized);
    print "[Gráficos activados (tamaño ";
    switch (altoVentanaGrafica) {
      GRAFICOS_PEQUENOS: print "pequeño";
      GRAFICOS_MEDIANOS: print "mediano";
      GRAFICOS_GRANDES:  print "grande";
      default:           print altoVentanaGrafica, " px";
    }
    print ").]^";
    style roman;
  }
];


! Esta versión de ExaminarFalsoSub convierte la acción en Entrar o
! Examinar dependiendo de si el objeto de destino es una localidad o no.
! Además tiene en cuenta si el objeto lleva asociado un menú de acciones y
! dispara la que corresponda:
[ ExaminarFalsoSub
  pm pl;
  ! Esta propiedad se establece en ExaminarFalso.EF_UnknownVerb(x):
  noun = ExaminarFalso.objetoVerboDesconocido;
  ! Si es el nombre de la localidad actual, hacemos un MIRAR:
  if (noun == location) {
    ImprimirPrompt();
    print (s_input) "mira^";
    <<Look>>;
  }
  PronounNotice(noun);
  ! ExaminarFalso.palabraMenu puede ser:
  ! > 0, lo que significa que el jugador ha escogido una opción en el menú
  !      de acciones del objeto
  ! = 0, lo que significa que el jugador ha tecleado el nombre del objeto
  ! < 0, lo que significa que el jugador ha pulsado un hyperlink que no es
  !      un objeto, sino simple texto; se usa sobre todo para los decorados
  pm = ExaminarFalso.palabraMenu;
  ExaminarFalso.palabraMenu = 0;
  if (pm > 0) {      ! Si se ha escogido una opción en el menú de acciones...
    pl = noun.input_link;
    ImprimirPrompt();
    glk_set_style(style_Input);
    print (address) pm, " ", (string) pl, "^";
    glk_set_style(style_Normal);
    switch (pm) {
          'coge': <<Take noun>>;
          'deja': <<Drop noun>>;
      'enciende': <<SwitchOn noun>>;
         'apaga': <<SwitchOff noun>>;
            'ex': <<Examine noun>>;
    }
    print "*** Aquí no se debería llegar ***";
    rfalse;
  }
  ! El jugador ha tecleado el nombre del objeto y éste no tiene asociado un menú
  ! de acciones, o bien ha pulsado sobre un hyperlink que no es un objeto: 
  if (noun ofclass Lugar) {
    if (noun provides input_link) {
      ImprimirPrompt();
      print (s_input) "ve ", (s_input) noun.input_link, "^";
    }
    <<Enter noun>>;
  } else {
    ! Si pm < 0, quiere decir que el jugador ha pulsado sobre una palabra que
    ! no es un objeto, sino una simple cadena de texto:
    if (noun provides input_link || pm < 0) {
      if (ExaminarFalso.mostrarExaminar) {
        ExaminarFalso.mostrarExaminar = false;
        ImprimirPrompt();
        if (noun provides input_link) {
          print (s_input) "ex ", (s_input) noun.input_link, "^";
        } else {
          print (s_input) "ex ", (s_input) -pm, "^";
        }
      }
    }
    <<Examine noun>>;
  }
];


[ IniciarGraficosSonidos;
  if (glk_gestalt(gestalt_AlphaAventuras, 0) == 0) {
    print "^Lo sentimos, pero este juego necesita un intérprete
            propio y no funcionará con ningún otro intérprete Glulx
            estándar.^";
    KeyDelay();
    quit;
  }

  if (~~testGraphics()) {
    print "^Lo sentimos, pero este juego necesita un intérprete Glulx
            con capacidades gráficas.^^";
    RecomiendaGargoyle();
  }

  if (Damusix.TestAudio() == 0) {
    print "^Lo sentimos, pero este juego necesita un intérprete Glulx
            que pueda reproducir sonido.^^";
    RecomiendaGargoyle();
  }

  if (glk_gestalt(gestalt_Timer,0) == 0) {
    print "^Lo sentimos, pero este juego necesita un intérprete Glulx
            que tenga soporte para eventos temporizados.^^";
    RecomiendaGargoyle();
  }

  ! Inicialización sonora
  IniciarSonidos();

  ! Inicialización gráfica
  initializeSGW(altoVentanaGrafica);
];


[ IniciarSonidos;
  Damusix.VolumenCanal(CANAL_FONDO,     VOLUMEN_FONDO);
  Damusix.VolumenCanal(CANAL_TV_SALON,  VOLUMEN_TV_SALON);
  Damusix.VolumenCanal(CANAL_TV_CUARTO, VOLUMEN_TV_CUARTO);
  Damusix.VolumenCanal(CANAL_TELEFONO,  VOLUMEN_TELEFONO);
];


[ Introduccion;
  clearMainWindow();
  viewImageCenter(Oscuridad_jpg);
  
  InicioPrologo();
];


[ ImprimirPrompt;
  new_line;
  if (player ~= selfobj) {
    glk_set_style(style_User1);
    print (string) player.short_name;
    glk_set_style(style_Normal);
    print " ";
  }
  print (s_input) "> ";
];


#ifndef LugarReal;
[ LugarReal;
  if (location == thedark) return real_location;
  else                     return location;
];
#endif;


[ MostrarImagenAuxiliar img;
!  if (gg_objwin ~= 0) glk_window_close(gg_objwin, 0); 
!  gg_objwin = glk_window_open(gg_bigwin,
!                              (winmethod_Above + winmethod_Proportional),
!                              100, wintype_Graphics, GG_OBJWIN_ROCK);
!  drawImageSGW(gg_objwin, img, curr_pic_pos, BORDEWIN, BORDEWIN);
  viewImageCenter(img);
];


[ MostrarImagenLocalidad loc;
  if (~~loc) loc = location;
  if (loc provides sgw_img) viewImageCenter(loc.sgw_img);
];


[ MostrarImagenGradualmente imagen veces retardo
  i;
  for (i = 0 : i < veces : i++) {
    viewImageCenter(imagen, true);
    WaitDelay(retardo);
  }  
];


[ link obj msg;
  if (obj ofclass String) {
    glk_set_hyperlink(-obj);  ! Hyperlinks negativos son cadenas
    if (msg ~= 0) print (string) msg;
    else          print (string) obj;
    glk_set_hyperlink(0);
  } else {
    glk_set_hyperlink(obj);   ! Hyperlinks positivos son objetos
    if (msg ~= 0)                      print (string) msg;    
    else if (obj provides nombre_link) print (string) obj.nombre_link;
    else                               print (string) obj.input_link;
    glk_set_hyperlink(0);
  }
];


[ OcultarImagenAuxiliar;
!  if (gg_objwin ~= 0) glk_window_close(gg_objwin, 0);
!  gg_objwin = 0;
  MostrarImagenLocalidad();
];


[ RecomiendaGargoyle;
  print "~El círculo~ ha sido diseñada
         para funcionar con el intérprete Gargoyle, que puedes
         descargar de la siguiente dirección:^^",
         (s_pref) "http://code.google.com/p/garglk/downloads^";
  KeyDelay();
  quit;
];


!===============================================================================
! (10) Verbos y Gramaticas Propias del Juego
!-------------------------------------------------------------------------------


Verb meta 'ayuda'
  *                 -> Ayuda;

Extend 'cambia' first
  * 'canal'/'emisora'                -> CambiarCanal
  * 'el' 'canal'                     -> CambiarCanal
  * 'la' 'emisora'                   -> CambiarCanal
  * 'de' 'canal'/'emisora'           -> CambiarCanal
  * 'canal'/'emisora' 'en' noun      -> CambiarCanal
  * 'el' 'canal'   'en' noun         -> CambiarCanal
  * 'la' 'emisora'  'en' noun        -> CambiarCanal
  * 'de' 'canal'/'emisora' 'en' noun -> CambiarCanal;

Verb 'chilla' = 'grita';

Verb meta 'configuracion'
  *                           -> Configuracion;

Verb meta 'creditos'
  *                 -> Creditos;

Verb 'cuelga'
  * noun            -> Colgar;

VerboIrregular "colgar" with imperativo 'cuelga';

Verb 'cuentale' = 'cuenta';

Verb 'descuelga'
  * noun            -> Descolgar;

VerboIrregular "descolgar" with imperativo 'descuelga';

Verb 'desenchufa'
  * noun            -> Desenchufar;

VerboIrregular "desenchufar" with imperativo 'desenchufa';

Extend 'di' first
  * 'a' creature             -> Answer;

Extend only 'enchufa' replace
  * noun            -> Enchufar;

Verb meta 'graficos'
  *                           -> Graficos
  * 'on'/'encendido'/'si'     -> EncenderGraficos
  * 'off'/'apagado'/'no'/'nx' -> ApagarGraficos
  * 'pequenos'                -> GraficosPequenos
  * 'medianos'                -> GraficosMedianos
  * 'grandes'                 -> GraficosGrandes;

Extend only 'grita' replace
  *                 -> Gritar
  * 'a//' creature  -> Gritar;

Extend 'habla' first
  * 'con' creature topic     -> Tell
  * 'con' creature           -> Tell
  * 'a' creature             -> Tell;

Verb 'hola'
  *                 -> Saludar;

Verb 'llama'
  *                 -> Llamar
  * 'a//' noun      -> Llamar
  * 'por' noun      -> LlamarPor;

Verb meta 'musica'
  *                                   -> Musica
  * 'fondo' 'on'/'encendida'/'si'     -> EncenderMusica
  * 'fondo' 'off'/'apagada'/'no'/'nx' -> ApagarMusica
  * 'on'/'encendida'/'si'             -> EncenderMusica
  * 'off'/'apagada'/'no'/ 'nx'        -> ApagarMusica;

Verb meta 'pistas'
  *                 -> Pistas
  * 'no' / 'nx'     -> PistasNo;

Verb 'preguntale' = 'pregunta';

Extend only 'sal' 'salte' 'salirse' 'salirte'
  * noun            -> SalirA
  * 'a//' noun      -> SalirA;

Extend 'sal'
  * 'por' noun      -> SalirPor;

Extend 'saluda' first
  *                 -> Saludar;

Verb 'sigue'
  * creature               -> Seguir
  * creature 'aqui'        -> Seguir
  * 'a//' creature         -> Seguir
  * 'a//' creature 'aqui'  -> Seguir;

Verb meta 'sonido' 'sonidos'
  *                                   -> Sonido
  * 'on'/'encendido'/'si'             -> EncenderSonido
  * 'off'/'apagado'/'no'/'nx'         -> ApagarSonido
  * 'fondo'                           -> Musica
  * 'fondo' 'on'/'encendido'/'si'     -> EncenderMusica
  * 'fondo' 'off'/'apagado'/'no'/'nx' -> ApagarMusica;

Verb 'vamonos' 'vayamonos'
  *                  -> Venir
  * 'de' 'aqui'      -> Venir;

Verb 'vamos'
  *                  -> Venir;

Verb 'ven'
  *                  -> Venir
  * 'aqui'           -> Venir
  * 'conmigo'        -> Venir;

Verb meta 'verbo.nulo'
  *                  -> VerboNulo;
  
#ifdef DEBUG;
Verb meta 't'
  *                    -> TestPasoAPaso;

Verb meta 'tt'
  *                    -> TestContinuar;
#endif;


!===============================================================================
! (11) Rutinas de Acciones Propias del Juego
!-------------------------------------------------------------------------------


[ AnswerSub;
  ComoHablar();
];


[ ApagarGraficosSub;
  ApagarGraficos(true);
];

  
[ ApagarMusicaSub;
  haySonidoFondo = false;
  Damusix.VolumenCanal(CANAL_FONDO, 0);
  print (s_emph) "[Desactivado el sonido de fondo.]^";
];


[ ApagarSonidoSub;
  haySonido = false;
  Damusix.DesactivarAudio();
  print (s_emph) "[Desactivados todos los efectos sonoros.]^";
];


[ AyudaSub;
  print "Prueba a pedir ayuda a alguien. Si necesitas pistas más elaboradas,
         puedes usar el sistema de pistas interactivas tecleando el comando ",
         (s_input) "PISTAS", ".^";
];


[ CambiarCanalSub
  tv;
  if (noun ~= nothing)                     tv = noun;
  else if (tv_cuarto_katie in LugarReal()) tv = tv_cuarto_katie;
  else if (tv_salon_katie in LugarReal())  tv = tv_salon_katie;
  else "No veo ningún televisor aquí.";
  
  if (tv hasnt on) "El televisor está apagado.";
  
  "Cambias repetidamente de canal, pero sólo encuentras estática y ruido."; 
];


[ ColgarSub;
  "No tiene sentido colgar eso.";
];


[ ConfiguracionSub
  fondo v m;
  ControlTimer.PausarTick();
  fondo = Damusix.SonandoDeFondoCanal(CANAL_FONDO);
  glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
                             winmethod_Above + winmethod_Proportional,
                             100, 0);
  
  ZIPI_RunMenu(ZIPI_Configuracion, true);
  
  v = Damusix.QueVolumenCanal(CANAL_FONDO);
  if (LugarReal() provides sgw_mus) {
    m = LugarReal().sgw_mus;
    if (fondo && haySonidoFondo && v ~= 0 && ~~(Damusix.SonandoDeFondo(m))) {
      Damusix.AsignarCanal(m, CANAL_FONDO, v, SONIDO_REPETIR);
      Damusix.TocarCanal(CANAL_FONDO);
    }
  }
  glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
                             winmethod_Above + winmethod_Fixed,
                             1, 0);
  glk_set_window(gg_mainwin);
  if (hayGraficos) EncenderGraficos();
  else             ApagarGraficos();
  ControlTimer.ReanudarTick();
];


[ ConsultSub;
  <<Examine noun>>;
];


[ CreditosSub;
  viewImageCenter(Logo_Alpha_Aventuras_jpg);
  print (s_head) "^@<<EL CÍRCULO@>>", " --- (c) 2012 Alpha Aventuras^^";
  print (s_bold) "-- PROGRAMACIÓN Y DISEÑO:^";
  print "    Ricardo Pérez López^^";
  print (s_bold) "-- GRÁFICOS:^";
  print "    Manuel Millán Ruiz^^";
  print (s_bold) "-- TEXTOS:^";
  print "    Ricardo Pérez López^^";
  print (s_bold) "-- MAPEADO Y DOCUMENTACIÓN:^";
  print "    Ricardo Pérez López^";
  print "    Antonio Matiola Ortiz^^";
  print (s_bold) "-- PRUEBAS:^";
  print "    Ricardo Pérez López^";
  print "    Manuel Millán Ruiz^^";
  KeyDelay();
  print "Desarrollado usando el lenguaje Inform, de Graham Nelson,
         con ayuda de las siguientes librerías:^^";
  print "- INFSP6 (fix), de Sarganar et al.^";
  print "- Adaptación de SGW+DMX, de Eliuk Blau^";
  print "- Damusix, de Eliuk Blau^";
  print "- PNJactor_NG y PNJacciones_NG (adaptaciones de los originales de Zak
           y Carlos)^";
!  print "- Rastros_NG (adaptación de Rastros, de Mel Hython)^";
  print "- Moviles_NG (adaptación de Moviles, de Mel Hython)^";
  print "- PNJpuertas_NG (Adaptación de PnjPuertas, de Jaevius)^";
  print "- Decir, de Zak^";
  print "- Etemas, de Zak^";
  print "- Decorado_NG (adaptación de Decorado, de Zak y Mel Hython)^";
!  print "- Teletipo (adaptación de Escr, de Baltasarq)^";
  print "- Adaptación de Barra, de Presi^";
  print "- Adaptación de ZIPI, de Zak^";
  print "- Timer, de Sothoth";
  KeyDelay();
  print "^^Basado en la novela @<<Ringu@>> de Koji Suzuki y el film
         @<<The Ring@>> (c) 2002 Dreamworks SKG.";
  print "^^Nuestro agradecimiento a todos los integrantes del CAAD que nos han
         ayudado, directa o indirectamente, en el desarrollo de esta aventura.^^
         (c) 2012 Alpha Aventuras^^
         Este programa es software libre, publicado bajo la licencia GNU GPL v3.
         El texto completo de la licencia se encuentra en la siguiente
         dirección:^^";
  print (s_pref) "http://www.gnu.org/licenses/gpl.txt^";
  print "^El código fuente del programa está disponible en Github:^^";
  print (s_pref) "https://github.com/ricpelo/elcirculo^";
  KeyDelay();
  print "^Visítanos en:^^";
  print (s_pref) "http://www.alpha-aventuras.es^
        http://wiki.caad.es/Alpha_Aventuras^
        http://www.facebook.com/alphaaventuras^";
  KeyDelay();
  MostrarImagenLocalidad();
];


[ DescolgarSub;
  "No tiene sentido descolgar eso.";
];


[ DesenchufarSub;
  if (~~(noun provides enchufado)) {
    print_ret (The) noun, " no puede desenchufarse.";
  }
  if (~~(noun.enchufado)) {
    print_ret (The) noun, " ya está desenchufado.";
  }
  noun.enchufado = false;
  print "Desenchufas ", (the) noun, ".";
  if (noun has on) {
    give noun ~on;
    " Al hacerlo, se apaga.";
  }
];


[ EncenderGraficosSub;
  EncenderGraficos(true);
];


[ EncenderMusicaSub i;
  haySonidoFondo = true;
  Damusix.VolumenCanal(CANAL_FONDO, VOLUMEN_FONDO);

  if (~~i) {
    print (s_emph) "[Activado el sonido de fondo.]^";
  }
];


[ EncenderSonidoSub;
  haySonido = true;
  Damusix.ActivarAudio();
  print (s_emph) "[Activados todos los efectos sonoros.]^";
];


[ EnchufarSub;
  if (~~(noun provides enchufado)) {
    print_ret (The) noun, " no puede enchufarse.";
  }
  if (noun.enchufado) {
    print_ret (The) noun, " ya está enchufado.";
  }
  noun.enchufado = true;
  "Enchufas ", (the) noun, ".";
];


[ GraficosGrandesSub;
  altoVentanaGrafica = GRAFICOS_GRANDES;
  EncenderGraficosSub();
];


[ GraficosMedianosSub;
  altoVentanaGrafica = GRAFICOS_MEDIANOS;
  EncenderGraficosSub();
];


[ GraficosPequenosSub;
  altoVentanaGrafica = GRAFICOS_PEQUENOS;
  EncenderGraficosSub();
];


[ GraficosSub;
  print (s_emph) "[Por favor, usa la forma ~", (s_input) "GRAFICOS SI",
        (s_emph) "~ o ~", (s_input) "GRAFICOS NO", (s_emph) "~ para activar o
        desactivar, respectivamente, el uso de gráficos. También puedes
        cambiar el tamaño de la ventana gráfica usando ~",
        (s_input) "GRAFICOS PEQUEÑOS", (s_emph) "~, ~",
        (s_input) "GRAFICOS MEDIANOS", (s_emph) "~ o ~",
        (s_input) "GRAFICOS GRANDES", (s_emph) "~.]^";
];


[ GritarSub;
!  pagina_contenidos.update(1);
!  diario_llave.update();
!  diario_ticket.update();  
!  diario_amigos.update();
!  midiario.update(p2, 1);
  "Emites un sonoro grito, pero nadie responde.";
];


[ LlamarPorSub;
  "Con eso no puedes llamar a ningún sitio.";
];


[ LlamarSub;
  "¿Llamar a qué o a quién?";
];


[ MusicaSub;
  print (s_emph) "[Por favor, usa la forma ~", (s_input) "SONIDO FONDO SI",
        (s_emph) "~ o ~", (s_input) "SONIDO FONDO NO", (s_emph) "~ para activar
        o desactivar, respectivamente, el sonido de fondo.]^";
];


[ PistasNoSub;
  switch (hayPistas) {
    2:       print (s_emph) "[Las pistas ya han sido desactivadas.]^";
    default: hayPistas = 2;
             print (s_emph) "[PISTAS desactivadas.]^";
  }
];


[ PistasSub
  v tlf tv fondo;
  switch (hayPistas) {
    0: hayPistas = 1;
       print (s_emph) "[Advertencia: Es sabido que la tentación de la ayuda es
             a veces tan fuerte que se suelen obtener pistas prematuramente.
             Por tanto, en cualquier momento durante el juego puedes poner ",
             (s_input) "PISTAS NO", (s_emph) ", y eso te impedirá obtener ayuda
             en la sesión de juego actual. Si sigues queriendo una pista, pon ",
             (s_input) "PISTAS", (s_emph) " otra vez.]^";
    1: ControlTimer.PausarTick();
       if (hayGraficos) {
         ApagarGraficos(true);
         hayGraficos = true;
       }
       StatusLineHeight(26);
       tlf = Damusix.SonandoDeFondoCanal(CANAL_TELEFONO);
       Damusix.PararCanal(CANAL_TELEFONO);
       tv = Damusix.SonandoDeFondoCanal(CANAL_TV_SALON);
       Damusix.PararCanal(CANAL_TV_SALON);
       fondo = Damusix.SonandoDeFondoCanal(CANAL_FONDO);
       v = Damusix.QueVolumenCanal(CANAL_FONDO);
       Damusix.AsignarCanal(Darkwalk_ogg, CANAL_FONDO, v,
                            SONIDO_REPETIR);
       Damusix.TocarCanal(CANAL_FONDO);
       
       ZIPI_Empezar();
       
       if (tlf) Damusix.TocarCanal(CANAL_TELEFONO);
       if (tv)  Damusix.TocarCanal(CANAL_TV_SALON);
       if (fondo && LugarReal() provides sgw_mus) {
         v = Damusix.QueVolumenCanal(CANAL_FONDO);
         Damusix.AsignarCanal(LugarReal().sgw_mus, CANAL_FONDO, v,
                              SONIDO_REPETIR);
         Damusix.TocarCanal(CANAL_FONDO);
       } else {
         Damusix.PararCanal(CANAL_FONDO);
       }
       StatusLineHeight(1);
       glk_set_window(gg_mainwin);
       if (hayGraficos) EncenderGraficos();
       clearTextWindow();
       ControlTimer.ReanudarTick();
       <<Look>>;
    2: print (s_emph) "[Las pistas han sido desactivadas.]^";
  }
];


! Para poder poner "SALIR AL PASILLO", que sería lo mismo que "ENTRA EN EL
! PASILLO".
[ SalirASub;
  print_ret (The) noun, " no es algo a donde puedas salir.";
];


[ SalirPorSub;
  if (noun ofclass Lugar) <<Exit>>;
  else                    <<Enter noun>>;
];


[ SaludarSub;
!  glk_window_stylehint_set(gg_mainwin, style_Normal,
!                           stylehint_TextColor, $ff0000);
  "Saludas cordialmente.";
];


[ SearchSub;
  <<Examine noun>>;
];


[ SeguirSub;
  "Decide por ti mism", (o) player, " a dónde deseas ir.";
];


[ SonidoSub;
  print (s_emph) "[Por favor, usa la forma ~", (s_input) "SONIDO SI",
        (s_emph) "~ o ~", (s_input) "SONIDO NO",
        (s_emph) "~ para activar o desactivar, respectivamente,
                  todos los efectos sonoros.]^";
];


[ TellSub;
  ComoHablar();
];


[ VenirSub;
  <<Seguir player>>;
];


[ VerboNuloSub;
  rfalse;
];


#ifdef DEBUG;
[ TestPasoAPasoSub;
  test_machine.run_once();
];


[ TestContinuarSub;
  test_machine.run();
];
#endif;


!===============================================================================
! (12) Partes de la aventura (en archivos separados)
!-------------------------------------------------------------------------------


Include "diario.inf";      ! Diario de tareas
Include "prologo.inf";     ! Prólogo
Include "historia.inf";    ! Primer capítulo


! Fin elcirculo.inf
