!% -~S
!% -G
!% +language_name=Spanish
!% $MAX_STATIC_DATA=25000
!% $MAX_PROP_TABLE_SIZE=63840
!% $MAX_VERBS=200
!% $MAX_ZCODE_SIZE=45000
!% $MAX_VERBSPACE=4500

!
! EL CÍRCULO
!
! Copyright (c) 2012 Ricardo Pérez López (Alpha Aventuras)
!

! This program is free software: you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.


!===============================================================================
! (1) Constantes; Variables Globales; Replaces; Propertys; Incluir Parser.h
!-------------------------------------------------------------------------------


! ====================================================================
! CONSTANTES
! ====================================================================


Constant Story "@<<EL CÍRCULO@>>";
Constant Headline "^(c) 2012 Alpha Aventuras^^
                  Teclea CRÉDITOS si quieres saber más acerca de la aventura, o
                  AYUDA cuando estés bloqueado.^";
Release 1;

! Queremos usar el comando 'Salidas'
Constant ADMITIR_COMANDO_SALIDAS;
! No queremos usar los comandos 'Lugares' y 'Objetos'
Constant NO_PLACES;
! No queremos usar puntuación
Constant NO_SCORE;
! Queremos que se muestren las deducciones del parser
!Constant IMPRIMIR_DEDUCCIONES;
! Hay curiosidades al final del juego
!Constant AMUSING_PROVIDED;

! Altura (en px.) de la ventana de logo en el menú principal:
Constant ALTURA_LOGO_MENU = 450;

! Ancho de la ventana de acciones:
Constant ANCHO_ACCIONES  = 25;

! Canales y volúmenes para los sonidos:
Constant CANAL_FONDO     = 9; Constant VOLUMEN_FONDO     = 50;
Constant CANAL_TV_SALON  = 0; Constant VOLUMEN_TV_SALON  = 100;
Constant CANAL_TV_CUARTO = 1; Constant VOLUMEN_TV_CUARTO = 50;
Constant CANAL_TELEFONO  = 2; Constant VOLUMEN_TELEFONO  = 100;

! El color de fondo de la ventana gráfica es negro:
Constant CLR_GG_PERSBACK = CLR_GG_BLACK;

! Color de los hyperlinks al empezar la aventura:
Constant COLOR_HYPERLINK = $a1d0fc;

! No queremos marcos en las cajas hechas con el comando box:
Constant GBOXQUOTE_NOFRAME;

! La roca de la ventana de menús de acciones:
Constant GG_MENUWIN_ROCK = 213;

! La roca de la ventana de conversaciones con personajes:
Constant GG_CONVERSAWIN_ROCK = 214;

! Alturas de los gráficos:
Constant GRAFICOS_MINUSCULOS = 200;
Constant GRAFICOS_PEQUENOS   = 250;
Constant GRAFICOS_MEDIANOS   = 350;
Constant GRAFICOS_GRANDES    = 450;

!Constantes de gtalk.h:
!Constant GT_SELECT       = "Selecciona una opción ";
!Constant GT_WOULDLIKE    = "^¿Qué vas a decir?^";
Constant GT_NOQUIP       = "^No se te ocurre nada más que decir.^";
Constant GT_NOSAY        = "^Prefieres no decir nada.^";
Constant GT_OPTIONPREFIX = "[";
Constant GT_OPTIONSUFFIX = "] ";
Constant GT_ZEROEXIT     = "No decir nada.";
![ GT_ZEROEXIT; ! La hacemos rutina en lugar de constante
!  print "(";
!  glk($0086, 8); ! set input style
!  glk($100, 48);
!  print "0";
!  glk($100, 0); 
!  glk($0086, 0); ! set input style
!  print " para salir) ";
!];

Constant INICIAL_MONOSIZE = 170; 
Constant INICIAL_PROPSIZE = 200;
Constant INICIAL_LEADING  = 25;
Constant INICIAL_BASELINE = 17;

! Las posibles distribuciones de ventanas en la aventura:
Constant LAYOUT_MENU_PRINCIPAL = 0; ! Distribución en el menú principal
Constant LAYOUT_JUEGO = 1;          ! Distribución durante el juego

Constant MAPA_COLOR_BORDE = COLOR_HYPERLINK;

! Tamaños para arrays relacionados con el menú de acciones:
Constant MAXIMO_OPCIONES = 100;         ! Número máximo de opciones en el array
Constant MAXIMO_TECLAS_OPCIONES = 30;   ! Número de teclas de acceso directo

! Número máximo de cadenas DIFERENTES que se han impreso:
Constant PS_TAB_SIZE = 1000;

! Vamos a usar Damusix junto con SGW+DMX
Constant SGW_CON_DAMUSIX;
Constant SONIDO_REPETIR = -1;

! Constantes para los gestores de timer:
Constant TIMER_TICK = 1000;
Constant TIMER_DURACION_BECCA = 5;
Constant TIMER_DURACION_IMAGEN_PERSONAJE = 4;
Constant TIMER_DURACION_TLF_KATIE = 6;


! ====================================================================
! VARIABLES GLOBALES
! ====================================================================


! El array de opciones en el menú de acciones:
Array opcionesMenu --> MAXIMO_OPCIONES;

! Números de opción asociados con una tecla de acceso rápido:
Array numeroOpciones -> MAXIMO_TECLAS_OPCIONES;

! Teclas de acceso rápido en el menú de acciones:
Array teclasOpciones -> '1' '2' '3' '4' '5' '6' '7' '8' '9' 'A'
                        'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'L' 'M'
                        'O' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z';

! Alto de la ventana gráfica:
Global altoVentanaGrafica = GRAFICOS_MEDIANOS;

! Interruptor para indicar si hay que dibujar o no la línea de estado
! (ver rutina Inicialise):
Global dibujarEstado = false;

! Se pone a true y false en la rutina PermitirEmpujarDir, y luego se consulta en
! MensajesLibreria:
Global estoyEmpujando = false;

! La ventana de menús de acciones:
Global gg_menuwin = 0;

! La ventana de conversación con personajes:
Global gg_conversawin = 0;

! Hay gráficos o no:
Global hayGraficos = true;

! Interruptor de pistas:
Global hayPistas = 0;

! Hay sonidos:
Global haySonido = true;
Global haySonidoFondo = true;

! Hay eventos en tiempo real:
Global hayTiempoReal = true;

! Hay efecto de teletipo:
!Global hayTeletipo = false;

! La distribución de ventanas actual. Empezamos con la distribución
! del menú principal, y cuando empezamos el juego (en IniciarAventura())
! cambiamos a la distribución LAYOUT_JUEGO. Es necesario saber en qué
! layout estamos para poder restaurar correctamente las ventanas ante
! un UNDO/RESTART/RESTORE:
Global layoutPantalla = LAYOUT_MENU_PRINCIPAL;

! Si se ha activado el listado automático de salidas:
Global mostrarSalidas = true;

! La imagen que representa la oscuridad:
Global SGW_IMAGEN_OSCURIDAD = Oscuridad_jpg;

! Lista que se usa en PistasSub() para apagar y encender correctamente
! los sonidos que estén sonando al entrar en las pistas:
Array sonidosSonando -> DAMUSIX_NCANALMAX;


! ====================================================================
! REPLACES
! ====================================================================


! La pregunta del final del juego, pero con menús:
Replace AfterGameOver;

! Ajustamos esta rutina para que SGW+DMX no actualice sola el gráfico de la
! localidad actual cuando se está mostrando el gráfico de un personaje:
Replace AfterPrompt;

! Con el siguiente Replace conseguimos que el objeto empujado hacia una
! dirección aparezca en la descripción de la localidad de destino del "empuje":
Replace AllowPushDir;

! En este juego no se habla, ni se responde, ni se dice:
Replace AnswerSub;
Replace DecirSub;
Replace TellSub;

! Para usar el comando box con Glulx:
Replace Box__Routine;

! Nuestra versión de CerrarVentanaMapa es prácticamente idéntica a la de
! Mapeador.h, con la única diferencia de que sólo llama a EncenderGraficos()
! cuando hayGraficos es true:
Replace CerrarVentanaMapa;

! En este juego no se usa el Consultar (CONSULTA, LEE, BUSCA EN x SOBRE y...):
Replace ConsultSub;

! Igualmente, esta versión no muestra puntos cardinales, sino lugares, al
! indicar hacia dónde va un PNJ móvil:
Replace DirDada;

! Nuestra versión de esta rutina sólo redibuja la línea de estado cuando
! la variable global dibujarEstado está a true:
Replace DrawStatusLine;

! Sustituimos la rutina EncenderGraficos que aparece en Mapeador:
Replace EncenderGraficos;

! Reemplazo de los puntos de entrada de Glulx:
Replace HandleGlkEvent;
Replace InitGlkWindow;

! Lo pide TestMachine_NG.h:
Replace KeyboardPrimitive;

! Lo pide Timer.h:
Replace KeyDelay;

! Nuestra versión de LanguageDirection no muestra los puntos cardinales y
! muestra entre paréntesis el destino de la dirección:
Replace LanguageDirection;

Replace ListenSub;
Replace Locale;

! Usamos el ParseNoun de IntNombre_NG:
Replace ParseNoun;

! Nuestra versión elimina también los signos de admiración e interrogación:
Replace QuitarAcentos;

! Cambia la función random() (ver random.h):
Replace random;

! En este juego no se usa el BuscarEn (MIRA EN, BUSCA EN/DENTRO/DE/SOBRE,
! REGISTRA...):
Replace SearchSub;

! La línea de estado se crea sin bordes:
Replace StatusLineHeight;

! Para usar el menú de acciones:
Replace YesOrNo;

! Ponemos nuestra propias versiones de estas rutinas para nuestros menús:
Replace ZIPI_PintaTitulo;
Replace ZIPI_RunMenu;
Replace ZIPI_RunOtro;
Replace ZIPI_tecla;


Include "Parser";


!===============================================================================
! (2) Puntos de Entrada para Glk [solo en Glulx]:
!     -  HandleGlkEvent(), IdentifyGlkObject(), InitGlkWindow()
!-------------------------------------------------------------------------------


[ HandleGlkEvent ev context buffer
  obj long r;
  switch (ev-->0) {
!    evtype_MouseInput:
!      glk_request_mouse_event(ev-->1); ! ev-->1 es la ventana
!      if (context == 0) return 1;      ! line input request
!      glk($00D3, gg_mainwin);          ! glk_cancel_char_event
!      buffer-->0 = 0;
!      return 2;

    evtype_Hyperlink:
      glk_request_hyperlink_event(ev-->1);  ! ev-->1 es la ventana
      if (context == 1) return 1;  ! character input request, no se hace nada
      obj = ev-->2;                ! ev-->2 es el número de hyperlink

      if (ev-->1 == gg_menuwin) {  ! Ventana del menú de acciones
        glk_cancel_line_event(gg_mainwin, gg_event);
        if (obj hasnt general) {    ! Si no hay que continuar escribiendo
          glk_set_style(style_Input);
          PrintAnything(obj.ZIPI_ejecutar());
          new_line;
          glk_set_style(style_Normal);
        }
        ! Los casos de save y restore hay que tratarlos aparte, porque tienden
        ! a repetir el input del jugador en pantalla, no sé por qué:
        if (obj == Menu_Save or Menu_Restore) {
          if (obj == Menu_Save) SaveSub();
          else                  RestoreSub();
          buffer-->0 = 0;
          return 2; ! Se simula la pulsación de Intro con input vacío
        }
        long = PrintAnyToArray(buffer + WORDSIZE,
                               INPUT_BUFFER_LEN - WORDSIZE,
                               obj.ZIPI_ejecutar());
        buffer-->0 = long;
        if (obj has general) {
          glk_request_line_event(gg_mainwin, buffer + WORDSIZE,
                                 INPUT_BUFFER_LEN - WORDSIZE, buffer-->0);
          return 1; ! Seguimos escribiendo
        } else {
          return 2; ! No seguimos escribiendo: Intro
        }
      }

      if (ev-->1 == gg_mainwin or gg_statuswin) {  ! Principal o de estado
        glk_cancel_line_event(gg_mainwin, gg_event);
        if (gg_event-->2 == 0) {          ! Si no hay nada escrito
          if (obj ofclass Object) {       ! Si es un objeto (no una cadena)
!            if (obj provides ZIPI_item) { ! Si el objeto tiene menú
            ! ¿Es punto cardinal? ¿Es localidad adyacente? Mostrar la orden
            if (obj in Compass || ConexionLocalidad(obj)) {
              glk_set_style(style_Input);
              print "ve "; PrintInputLink(obj); new_line;
              glk_set_style(style_Normal);
              long = PrintAnyToArray(buffer + WORDSIZE,
                                     INPUT_BUFFER_LEN - WORDSIZE,
                                     InputLink(obj));
              buffer-->0 = long;
              return 2;
            } else if (obj == location) { ! Si es el nombre de la localidad
              print (s_input) "mira ", "^";
              long = PrintAnyToArray(buffer + WORDSIZE,
                                     INPUT_BUFFER_LEN - WORDSIZE, "m");
              buffer-->0 = long;
              return 2;
            } else { ! Es objeto, no punto cardinal ni lugar actual o adyacente
              r = MenuAcciones.MostrarAcciones(obj);
              if (r) { ! Si se ha escogido una opción en el menú:
                glk_cancel_line_event(gg_mainwin, gg_event);
                if (r hasnt general) {    ! Si no hay que continuar escribiendo
                  glk_set_style(style_Input);
                  print (address) r.ZIPI_ejecutar(), " "; PrintInputLink(obj);
                  new_line;
                  glk_set_style(style_Normal);
                }
                long = PrintAnyToArray(buffer + WORDSIZE,
                                       INPUT_BUFFER_LEN - WORDSIZE,
                                       r.ZIPI_ejecutar());       ! El verbo
                long = long + PrintAnyToArray(buffer + WORDSIZE + long,
                                              INPUT_BUFFER_LEN - WORDSIZE,
                                              " ");              ! Un espacio
                long = long + PrintAnyToArray(buffer + WORDSIZE + long,
                                              INPUT_BUFFER_LEN - WORDSIZE,
                                              InputLink(obj));   ! El objeto
                long = long + PrintAnyToArray(buffer + WORDSIZE + long,
                                              INPUT_BUFFER_LEN - WORDSIZE,
                                              " ");              ! Un espacio
                if (r provides ZIPI_secundario) {   ! Si hay que completar...
                  long = long + PrintAnyToArray(buffer + WORDSIZE + long,
                                                INPUT_BUFFER_LEN - WORDSIZE,
                                                r.ZIPI_secundario());
                  long = long + PrintAnyToArray(buffer + WORDSIZE + long,
                                                INPUT_BUFFER_LEN - WORDSIZE,
                                                " ");                                          
                }
                buffer-->0 = long;
                if (r has general) {
                  glk_request_line_event(gg_mainwin, buffer + WORDSIZE,
                                         INPUT_BUFFER_LEN - WORDSIZE,
                                         buffer-->0);
                  return 1; ! Seguimos escribiendo
                } else {
                  return 2; ! No seguimos escribiendo: Intro
                }
              } else { ! Si no se ha escogido ninguna opción del menú
                buffer-->0 = 0;
                return 2; ! Se simula la pulsación de Intro con input vacío
              }
            }
          } ! if (obj ofclass Object)
        } ! if (gg_event-->2 == 0)
        ! Si llegamos hasta aquí, puede ser por una de estas causas (o varias):
        ! - El jugador ya había tecleado algo (el input no era vacío)
        ! - El hyperlink pulsado no era un objeto, sino una cadena
        long = gg_event-->2;
        long = PrintAnyToArray(buffer + WORDSIZE + long,
                               INPUT_BUFFER_LEN - WORDSIZE, InputLink(obj));
        buffer-->0 = long + gg_event-->2;
        ! Si ya había algo escrito, se entiende que el jugador quiere completar
        ! la entrada que estaba escribiendo, por lo que retornamos 1. Si no
        ! había nada escrito, retornamos 2 para simular la pulsación de Intro:
        if (gg_event-->2 > 0) {
          ! Añadimos un espacio en blanco al final:
          long = PrintAnyToArray(buffer + WORDSIZE + buffer-->0,
                               INPUT_BUFFER_LEN - WORDSIZE, " ");
          buffer-->0 = buffer-->0 + long;
          glk_request_line_event(gg_mainwin, buffer + WORDSIZE,
                                 INPUT_BUFFER_LEN - WORDSIZE, buffer-->0);
          return 1;  ! Retornamos 1 para que el jugador pueda seguir tecleando 
        } else {
          glk_set_style(style_Input);
          Tokenise__(buffer, parse);
          ! Si en alguna parte hay una coma, se entiende que se está hablando
          ! con un personaje o dándole una orden, por lo que no mostramos ve
          ! ni ex:
          for (r = WORDSIZE : r < parse-->0 + WORDSIZE : r++) {
            if (parse-->r == ',//') jump Imprimir;
          }
          ! Si la primera palabra del buffer es un verbo, no mostramos ve ni ex:
          if (LanguageIsVerb(buffer, parse, 1)) jump Imprimir;  
          if (obj ofclass Lugar) print "ve ";
          else                   print "ex ";
        .Imprimir;
          ImprimeTodoElBuffer(buffer);
          glk_set_style(style_Normal);
          new_line;
          return 2;  ! Retornamos 2 para que simule la pulsación de Intro
        }
      } ! if (ev-->1 == gg_mainwin or gg_statuswin)
  }
  SGW_HandleGlk(ev);
  ControlTimer.CT_HandleGlkEvent(ev, context, buffer);
  Mapa_HandleGlkEvent(ev, context, buffer);
  midiario.Diary_HandleGlkEvent(ev, context, buffer);
];


[ IdentifyGlkObject fase tipo ref rock;
  MenuAcciones.Menu_IdentifyGlkObject(fase, tipo, ref, rock);
  SGW_IdentifyGlk(fase, tipo, ref, rock);
  Damusix.IdentificarSonidos(fase);
  Mapa_IdentifyGlkObject(fase, tipo, ref, rock);
  Conversa_IdentifyGlkObject(fase, tipo, ref, rock);
  if (fase == 2) {
    ControlTimer.ReactivarTick();
    ZIPI_Configuracion.restaurar_valores();
    ZIPI_Mostrar_Hyperlinks.restaurar_valores();
  }
];


[ InitGlkWindow winrock;
  switch (winrock) {
    GG_MAINWIN_ROCK, GG_STATUSWIN_ROCK, GG_MENUWIN_ROCK, GG_CONVERSAWIN_ROCK:
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Weight, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Normal,
                        stylehint_Justification, stylehint_just_LeftRight);

      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Input,
                        stylehint_Weight, 1);

      ! Esta será mi negrita:
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_User1,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_BackColor, $0000ff);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextBuffer, style_User2,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_TextColor, $0000ff);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Alert,
                        stylehint_Weight, 1);
 
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Proportional, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextBuffer, style_Emphasized,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_TextColor, $82c1fb);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Preformatted,
                        stylehint_Weight, 0);

      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_Header,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Subheader,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextBuffer, style_Subheader,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_SubHeader,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextBuffer, style_SubHeader,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextBuffer, style_Note,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextBuffer, style_Note,
                        stylehint_BackColor, $000000);

      glk_stylehint_set(wintype_TextBuffer, style_BlockQuote,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextBuffer, style_BlockQuote,
                        stylehint_BackColor, $ffffff);


      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Weight, 0);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Normal,
                        stylehint_Justification, stylehint_just_LeftRight);
         
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Input,
                        stylehint_Weight, 1);
 
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_User1,
                        stylehint_Weight, 1);
  
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_BackColor, $0000ff);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_User2,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_TextColor, $0000ff);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextGrid, style_Alert,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Oblique, 1);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Weight, 1);
      glk_stylehint_set(wintype_TextGrid, style_Emphasized,
                        stylehint_Justification, stylehint_just_LeftRight);

      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_TextColor, $82c1fb);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_Proportional, 0);
      glk_stylehint_set(wintype_TextGrid, style_Preformatted,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_Header,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Subheader,
                        stylehint_TextColor, $a1d0fc);
      glk_stylehint_set(wintype_TextGrid, style_Subheader,
                        stylehint_BackColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_SubHeader,
                        stylehint_Size, 0);
      glk_stylehint_set(wintype_TextGrid, style_SubHeader,
                        stylehint_Weight, 1);

      glk_stylehint_set(wintype_TextGrid, style_Note,
                        stylehint_TextColor, $ffffff);
      glk_stylehint_set(wintype_TextGrid, style_Note,
                        stylehint_BackColor, $000000);

      glk_stylehint_set(wintype_TextGrid, style_BlockQuote,
                        stylehint_TextColor, $000000);
      glk_stylehint_set(wintype_TextGrid, style_BlockQuote,
                        stylehint_BackColor, $ffffff);
  }

  rfalse; ! si te olvidas esta linea, el juego no funcionará bien
];


! El IdentifyGlkObject de la ventana de conversaciones con personajes:
[ Conversa_IdentifyGlkObject fase tipo ref rock;
  if (fase == 0) { ! Poner cero en todos nuestros objetos glk
    gg_conversawin = 0;
    return;
  }       
  if (fase == 1) { ! Reiniciar correctamente las variables glk
    switch (tipo) {
      0: ! es una ventana
         switch (rock) {
           GG_CONVERSAWIN_ROCK: gg_conversawin = ref;
         }
      1: ! es un flujo
         ! pero no hay flujos en este ejemplo
      2: ! es una referencia a fichero
         ! pero no hay ficheros en este ejemplo
    }
    return;
  }       
  if (fase == 2) { ! Actualizar nuestras ventanas
    return;
  }
];


!===============================================================================
! (3) Modificar Mensajes de la Libreria; Otros Includes; Incluir VerbLib.h
!-------------------------------------------------------------------------------


!Include "Rastros_NG";


[ quieres_ x;
  if (player provides persona) {
    switch (player.persona) {
      PRIMERA_PERSONA,
      PRIMERA_PERSONA_SINGULAR: print "quiero";
      SEGUNDA_PERSONA,
      SEGUNDA_PERSONA_SINGULAR: print "quieres";
      TERCERA_PERSONA,
      TERCERA_PERSONA_SINGULAR: print "quiere";
      PRIMERA_PERSONA_PLURAL:   print "queremos";
      SEGUNDA_PERSONA_PLURAL:   print "queréis";
      TERCERA_PERSONA_PLURAL:   print "quieren";
      default:                  print "quieres";
    }
  } else print "quieres";
  print (string) x;
];


Object LibraryMessages
  with
    mostrar_nombre [ l;
      l = LugarReal().(lm_o.door_dir);
      if (l == nothing) print (the) lm_o;
      else              l.mostrar_nombre();
    ],
    before [;
      Look:
        switch (lm_n) {
!          5, 6: new_line;
!                if (lm_o ~= location) {
!                  if (lm_o has supporter) print "Sobre ";
!                  else                    print "En ";
!                  print (the) lm_o;
!                  print " ", (puedes_) " ver ";
!                } else print "", (_Puedes_) " ver ";
!
!                if (n == 5) print "también ";
!                WriteListFrom(child(lm_o),
!                              ENGLISH_BIT + WORKFLAG_BIT + RECURSE_BIT +
!                              TERSE_BIT + CONCEAL_BIT); ! Quitamos PARTINV_BIT
!                if (lm_o ~= location) ".";
!                ".";

          7: print "No observ", (as_) " nada digno de mención al mirar hacia ";
             self.mostrar_nombre();
             ".";
        }

      Prompt:
        new_line;
        ImprimirPrompt();
        rtrue;

      Go:
        switch (lm_n) {
          2: if (estoyEmpujando)
               "^No ", (puedes_) " seguir empujando porque no hay salida
               hacia ", (the) noun, ".";
             if (noun == in_obj)
               "No v", (eo_) " ningún sitio en el que ", (pueda_) " entrar.";
             "No ", (puedes_) " ir por ahí, porque no hay salida hacia ",
              (the) noun, ".";
          5: if (estoyEmpujando)
               "^No ", (puedes_) " empujar nada a través ", (del) noun, ".";
             "No ", (puedes_) " pasar a través ", (del) noun, ".";
        }
        
      Take:
        if (lm_n == 1) {
          print "Reco";
          if (player.persona == PRIMERA_PERSONA_SINGULAR) print "j";
          else                                            print "g";
          print (es_) " ";
          if (noun has moved) print (the) noun;
          else                print (a) noun;
          ".";
        }

      Drop:
        if (lm_n == 4) "Dej", (as_) " ", (the) lm_o, ".";

      Remove:
        if (lm_n == 3) {
          if (verb_word == 'quita') {
            "Quit", (as_) " ", (the) lm_o, " ", (del) second, ".";
          } else {
            "Sac", (as_) " ",  (the) lm_o, " ", (del) second, ".";
          }
        }

      GetOff:
        print "Pero si no est", (oy_) " en ";
        if (lm_o ofclass Lugar) lm_o.mostrar_nombre();
        else                    print (the) lm_o;
        "...";

      Exit:
        if (lm_n == 1) {
          "Si ", (quieres_) " moverte, indica hacia dónde quieres ir.";
        }

      Miscellany:
        switch (lm_n) {
           4: print " ¡Enhorabuena! Has acabado la aventura ";
              rtrue;
          10: rtrue;
          13: ! Reactivamos timer en caso de UNDO:
!              ControlTimer.ReactivarTick();
              "[Retrocediendo al turno anterior.]";
          17: switch (random(4)) {
                1: "Está muy oscuro y no puedes ver nada.";
                2: "Todo está demasiado oscuro y no aprecias nada con
                    claridad.";
                3: "La oscuridad te impide ver dónde te encuentras.";
                4: "Te mueves a tientas a través de una oscuridad que te impide
                    ver nada.";
              }
          19: "Has tenido días mejores...";
          30: switch (random(3)) {
                1: "No encuentro eso que dices.";
                2: "No veo nada parecido por aquí.";
                3: "Parece que no hay nada de eso.";
              };
          27: "Las palabras se te agolpan en los labios.";
          38: switch (random(5)) {
                1: "¿Qué quieres decir con eso?";
                2: "Lo siento, no te entiendo.";
                3: "Intenta ser un poco más preciso.";
                4: "No comprendo eso que dices.";
                5: "¿Qué intentas decir?";
              }
          39: ! Cuando el jugador intenta llevar a cabo una acción usando una
              ! palabra que está en la lista de nombres de la localidad actual:
              switch (action_to_be) {
                ##Examine:  PrintOrRun(location, description);
                ##Enter:    "Ya estás aquí.";
                ##SalirPor: <<Exit>>; ! SALIR DEL PASILLO estando en el pasillo
                default:    "Debes ser más específico.";
              }
              rtrue;
        }
    ];


! Hay que definirla antes de incluir Moviles_NG:
Class Lugar
!  class LugarConRastro
  with
    sgw_mus 0,
    sgw_img Oscuridad_jpg,
    sgw_vol VOLUMEN_FONDO,
    describe [;
      PrintOrRun(self, description);
      if (mostrarSalidas) {
        new_line;
        glk_set_style(style_Emphasized);
        <Salidas>;
        glk_set_style(style_Normal);
        rtrue;
      }
    ],
    mostrar_nombre [;
      if (self has visited && self provides nombre_si_visitado) {
        PrintOrRun(self, nombre_si_visitado, 1); rfalse;
      }
      if (self hasnt visited && self provides nombre_no_visitado) {
        PrintOrRun(self, nombre_no_visitado, 1); rfalse;
      }
      if (self provides nombre_direccion) PrintOrRun(self, nombre_direccion, 1);
      else                                print (name) self;
    ],
    number,
    dibujado false,                   ! Necesario para Mapeador.h
    before [
      l r;
      l = LugarReal();

      ! Cuando se usa "EXAMINA EL PASILLO":
      Examine:
        if (noun ofclass Lugar) {
          r = ConexionLocalidad(noun);
          if (r) <<Examine r>>;
        }

      ! Cuando se usa "VE AL PASILLO":
      Enter, SalirA:
        if (noun ofclass Lugar) {
          r = ConexionLocalidad(noun);
          if (r) <<Go r>>;
        }
        
      GetOff:
        if (noun == LugarReal()) <<Exit>>;
        rfalse;
    ],
    after [;
      Go:
        ! Si se está mostrando la imagen de un personaje, quitarla antes:
        timer_imagen_personaje.ocultar_imagen();
        SGW_MarcoDeTrabajo(1);
        ! Actualizar el volumen de los sonidos:
!        objectloop (o in self) if (o ofclass Sonido) o.cambiar_volumen();
    ],
  has
    scenery light;
    

#ifdef DEBUG;
[ WaitDelay delay;
  return KeyDelay(delay);
];
#endif;


Include "elcirculo.bli";    ! Los recursos multimedia de la aventura
Include "SGW+DMX_NG";       ! Entre Parser y VerbLib
Include "BetaTest";         ! Modo betatesting

Include "VerbLib";

Include "Barra";            ! Barra de estado personalizable
Include "Contenedor";       ! Contenedores
Include "Decorado_NG";      ! Objetos de decorado
Include "Diary";
Include "EscenarioAbrible"; ! Escenario que se puede abrir y cerrar
Include "Etemas";           ! Los temas de conversación
!Include "EventList_NG";     ! Listas de mensajes
!Include "ExaminarFalso";    ! Poder examinar objetos sólo con su nombre
Include "GlulxBox";         ! Usar el comando box con Glulx - gracias a Eliuk
Include "Gtalk_NG";         ! Conversaciones
Include "IntNombre_NG";     ! Poder usar adjetivos como en InformATE
Include "Moviles_NG";       ! La librería Moviles retocada por mí
Include "Pistas";           ! Las pistas creadas con ZIPI
Include "PNJpuertas_NG";    ! La librería PnjPuertas retocada por mí (muy poco)
Include "PNJactor_NG";      ! Librerías que hacen que un PNJ pueda coger y dejar
Include "PNJacciones_NG";   ! Poner detrás de Moviles, PNJpuertas y PNJactor
Include "Prand_NG";         ! Listas de mensajes
!Include "Teletipo";         ! Teletipo para sacar mensajes letra a letra
Include "Timer";            ! Mi librería de eventos temporizados


!===============================================================================
! (4) Rutinas Initialise() e IniciarAventura()
!-------------------------------------------------------------------------------


[ Initialise r v;
  IniciarGraficosSonidos();
  openGraphicWindow(ALTURA_LOGO_MENU);
  clearGraphicWindow();
  ExtenderVentanaEstado();
  clearMainWindow();
  viewImageCenter(Logo_Circulo_Con_Letras_jpg);
  v = Damusix.QueVolumenCanal(CANAL_FONDO);
  Damusix.AsignarCanal(Darkwalk_ogg, CANAL_FONDO, v, SONIDO_REPETIR);
  Damusix.Tocar(Darkwalk_ogg);
  do {
    r = ZIPI_RunMenu(ZIPI_Menu_Principal, 2);
  } until (r ~= 3);
  if (r ~= 2) quit;
  clearTextWindow();
  closeAllWindows();
  glk_window_close(gg_statuswin, 0);
  MenuAcciones.AbrirVentana();
  gg_statuswin = glk_window_open(glk_window_get_parent(gg_mainwin),
                                 winmethod_Above + winmethod_Fixed +
                                 winmethod_NoBorder,
                                 1, wintype_TextGrid, GG_STATUSWIN_ROCK);
  if (hayGraficos) EncenderGraficos();
  ! Los eventos hay que iniciarlos aquí, y no en IniciarAventura
  ! (no sé por qué, pero si lo pones en IniciarAventura, no funciona):
  ! glk_request_mouse_event(gg_bigwin);
  glk_request_hyperlink_event(gg_mainwin);
  glk_request_hyperlink_event(gg_statuswin);
  glk_request_hyperlink_event(gg_menuwin);
];


[ IniciarAventura logo;

  ! Cambiamos el layout de la pantalla de LAYOUT_MENU_PRINCIPAL a LAYOUT_JUEGO:
  layoutPantalla = LAYOUT_JUEGO;

!  location = thedark;
!  dibujarEstado = false;

  ! Esto es para que el juego dé siempre la descripción de la habitación, aunque
  ! ya la hayamos visitado
  lookmode = 2;

  ! Inventario en una sola frase:
  inventory_style = ENGLISH_BIT + RECURSE_BIT + FULLINV_BIT;

  ! Parseado estricto (de la librería IntNombre):
  parseado_estricto = 1;

  ! Nombre de la oscuridad
  thedark.short_name = "Oscuridad";
  
  ! Localización donde comienza el jugador
  location = cuarto_katie;

!  AsignarPersona(PRIMERA_PERSONA + PERSONA_SINGULAR);
!  give player female;

!  clearTextWindow();

  if (logo) {
    clearTextWindow();
    clearGraphicWindow();
!    DibujaLogoAlien();
  }

  timer_telefono_katie.AsignarGestor(1);
  timer_becca.AsignarGestor(2);
  ControlTimer.ActivarTick(TIMER_TICK);

  PNJ_Ruta(becca, MOVIMIENTO_PERSEGUIR, katie);

  ChangePlayer(katie);

  IniciarMoviles();
  IniciarPuertas();
!  IniciarRastros();

  Damusix.PararCanal(CANAL_FONDO);
  Damusix.LiberarCanal(DarkWalk_ogg);
  Damusix.VolumenCanal(CANAL_FONDO, VOLUMEN_FONDO);
  sonido_telefono_katie.sonar();
  KeyDelay();
  openGraphicWindow(altoVentanaGrafica);
];


!===============================================================================
! (5) Rutinas de la Libreria Implementadas, Reemplazadas o Ampliadas
!-------------------------------------------------------------------------------


! La pregunta del final del luego, ahora usando el menú de acciones:
[ AfterGameOver
  i;

  .RRQPL;

    L__M(##Miscellany,5);

  .RRQL;

    #Ifdef TARGET_ZCODE;
    #IfV3; read buffer parse; #Endif; ! V3
    temp_global=0;
    #IfV5; read buffer parse DrawStatusLine; #Endif; ! V5
    #Ifnot; ! TARGET_GLULX
    #ifdef DEATH_MENTION_UNDO;
    Menu_AfterGameOver.&ZIPI_item-->2 = Menu_Undo;
    #ifnot;
    Menu_AfterGameOver.&ZIPI_item-->2 = 0;
    #endif;
    if (TASKS_PROVIDED == 0) {
      Menu_AfterGameOver.&ZIPI_item-->3 = Menu_Score;
    } else {
      Menu_AfterGameOver.&ZIPI_item-->3 = 0;
    }
    if (deadflag == 2 && AMUSING_PROVIDED == 0) {
      Menu_AfterGameOver.&ZIPI_item-->4 = Menu_Amusing;
    } else {
      Menu_AfterGameOver.&ZIPI_item-->4 = 0;
    }
    i = MenuAcciones.MostrarAcciones(Menu_AfterGameOver, true);
    i = i.ZIPI_ejecutar();
    #Endif; ! TARGET_
    if (i == QUIT1__WD or QUIT2__WD) {
        #Ifdef TARGET_ZCODE;
        quit;
        #Ifnot; ! TARGET_GLULX
        quit;
        #Endif; ! TARGET_
    }
    if (i == RESTART__WD) {
        #Ifdef TARGET_ZCODE;
        @restart;
        #Ifnot; ! TARGET_GLULX
        @restart;
        #Endif; ! TARGET_
    }
    if (i == RESTORE__WD) {
        RestoreSub();
        jump RRQPL;
    }
    if (i == FULLSCORE1__WD or FULLSCORE2__WD && TASKS_PROVIDED==0) {
        new_line; FullScoreSub();
        jump RRQPL;
    }
    if (deadflag == 2 && i == AMUSING__WD && AMUSING_PROVIDED==0) {
        new_line; Amusing();
        jump RRQPL;
    }
    #IfV5;
    if (i == UNDO1__WD or UNDO2__WD or UNDO3__WD) {
        if (undo_flag == 0) {
            L__M(##Miscellany, 6);
            jump RRQPL;
        }
        if (undo_flag == 1) jump UndoFailed2;
        #Ifdef TARGET_ZCODE;
        @restore_undo i;
        #Ifnot; ! TARGET_GLULX
        @restoreundo i;
        i = (~~i);
        #Endif; ! TARGET_
        if (i == 0) {
          .UndoFailed2;
            L__M(##Miscellany, 7);
        }
        jump RRQPL;
    }
    #Endif; ! V5
    L__M(##Miscellany, 8);
    jump RRQL;
];


[ AfterPrompt;
  ! Pasándole el parámetro 3 en lugar de 1, lo que hacemos es pedirle que
  ! actualice la música pero no los gráficos:
  if (timer_imagen_personaje.mostrandose()) SGW_MarcoDeTrabajo(3);
  else                                      SGW_MarcoDeTrabajo(1);
];


! Modificado para que al empujar un objeto a una localidad se muestre
! más información:
[ AllowPushDir
  i tmp;
  if (parent(second) ~= compass) return L__M(##PushDir, 2, noun);
  if (second == u_obj or d_obj)  return L__M(##PushDir, 3, noun);
  AfterRoutines(); i = noun; move i to player;
  tmp = location;                                     ! (c) Alpha
  estoyEmpujando = true;                              ! (c) Alpha
  <Go second>;
  estoyEmpujando = false;                             ! (c) Alpha
  if (location == thedark) move i to real_location;
  else                     move i to location;
  if (tmp ~= location && location ~= thedark)
    PrintOrRun(i, describe);                          ! (c) Alpha
];


[ Amusing;
  rfalse;
];


[ DrawStatusLine;
  if (dibujarEstado) {
    barra_estado.dibujar();
  }
];


[ InScope actor
  l;

  l = LugarReal();

  ! Así podemos examinar la localidad actual simplemente tecleando su nombre:
  if (action_to_be == ##ExaminarFalso) PlaceInScope(l);

  ! Así podemos usar "VE AL SALON" y "EXAMINA EL SALON" en lugar de
  ! "VE AL SUR" y "EXAMINA EL SUR" (ver también la clase Lugar): 
  if (l provides n_to)   PlaceInScope(l.n_to);
  if (l provides s_to)   PlaceInScope(l.s_to);
  if (l provides e_to)   PlaceInScope(l.e_to);
  if (l provides w_to)   PlaceInScope(l.w_to);
  if (l provides ne_to)  PlaceInScope(l.ne_to);
  if (l provides nw_to)  PlaceInScope(l.nw_to);
  if (l provides se_to)  PlaceInScope(l.se_to);
  if (l provides sw_to)  PlaceInScope(l.sw_to);
  if (l provides u_to)   PlaceInScope(l.u_to);
  if (l provides d_to)   PlaceInScope(l.d_to);
  if (l provides in_to)  PlaceInScope(l.in_to);
  if (l provides out_to) PlaceInScope(l.out_to);

  ! Así le podemos pedir a Becca que coja el teléfono aunque el teléfono no
  ! esté presente:
  if (actor == becca && LugarReal() ~= cocina_katie) {
    PlaceInScope(telefono_katie);
  }
  
  rfalse;
];


! Esta versión no muestra los puntos cardinales y representa las direcciones
! como los nombres de los lugares a los que se llega por esa dirección:
[ LanguageDirection d
  l par;
  par = true;
  switch (d) {
    n_to:    par = false; ! print "al norte";
    s_to:    par = false; ! print "al sur";
    e_to:    par = false; ! print "al este";
    w_to:    par = false; ! print "al oeste";
    ne_to:   par = false; ! print "al nordeste";
    nw_to:   par = false; ! print "al noroeste";
    se_to:   par = false; ! print "al sudeste";
    sw_to:   par = false; ! print "al suroeste";
    u_to:    glk_set_hyperlink(u_obj);   print "arriba"; glk_set_hyperlink(0);
    d_to:    glk_set_hyperlink(d_obj);   print "abajo";  glk_set_hyperlink(0);
    in_to:   glk_set_hyperlink(in_obj);  print "dentro"; glk_set_hyperlink(0);
    out_to:  glk_set_hyperlink(out_obj); print "fuera";  glk_set_hyperlink(0);
    default: return RunTimeError(9, d);
  }
  l = LugarReal();
  print " ";
  if (par) print "(";
  glk_set_hyperlink(l.d);
  l.d.mostrar_nombre();
  glk_set_hyperlink(0);
  if (par) print ")";
];


! Modificado para que ?, !, ¿, ¡ se separen de las palabras al parsear:
[ QuitarAcentos buf pars x i word at len;
  Tokenise__(buf, pars);
  for (x = 1: x <= tokenCount(pars): x++) { ! para cada token
    word = tokenDict(pars,x); ! dictionary value of token 1,2,3...
    at   = tokenPos(pars,x);  ! position in buffer of token 1,2,3...
    len  = WordLength(x);     ! length in chars of token 1,2,3...

    if (word == 0) { ! no comprendida
      for (i = at: i < at + len: i++)
        switch (buf->i) {
          'á': buf->i = 'a';
          'é': buf->i = 'e';
          'ë': buf->i = 'e';
          'í': buf->i = 'i';
          'ó': buf->i = 'o';
          'ú': buf->i = 'u';
          'ü': buf->i = 'u';
          'ñ': buf->i = 'n';
          '?': buf->i = ' ';
          '¿': buf->i = ' ';
          '!': buf->i = ' ';
          '¡': buf->i = ' ' ;
        }
      Tokenise__(buf, pars);
    }
  }
];


! Modificado para que no ponga un borde debajo de la línea de estado:
[ StatusLineHeight hgt parwin;
  if (gg_statuswin == 0) return;
!  if (hgt == gg_statuswin_cursize) return;
  parwin = glk($0029, gg_statuswin); ! window_get_parent
  glk($0026, parwin, $112, hgt, 0); ! window_set_arrangement
  gg_statuswin_cursize = hgt;
];


! Para el Examinar Falso:
[ UnknownVerb;
  verb_wordnum = 0;
  return 'no.verb';
];


! La pregunta de "sí o no" usa ahora el menú de acciones:
[ YesOrNo
  r;
  r = MenuAcciones.MostrarAcciones(Menu_YesOrNo, true);
  MenuAcciones.MostrarImportantes();
  r = r.ZIPI_ejecutar() == 1;
  if (~~r) new_line;
  return r;
];


!===============================================================================
! (6) Incluir SpanishG.h; Otros Includes
!-------------------------------------------------------------------------------


Include "SpanishG";

Include "random";          ! Cambia la función random()
Include "Decir";           ! Para poder usar DECIR ... A ...
Include "Mapeador";
Include "TestMachine_NG";  ! El comprobador automático (c) Alien soft
Include "Sonidos_NG";


!===============================================================================
! (7) Clases del Juego
!-------------------------------------------------------------------------------


Class Destino
  with
    nombre_destino 0,
    before [;
      Go:
        coche_rachel.volver = location;
    ];


Class Personaje
  class Movil
  with
    imagen 0,
    dice_rand [ _vararg_count
      a;
      self.dice_inicio();
      @call prand _vararg_count a;
      self.dice_fin();
      return a;
    ],
    dice_once [ _vararg_count
      a;
      self.dice_inicio();
      @call prandonce _vararg_count a;
      self.dice_fin();
      return a;
    ],
    dice_last [ _vararg_count
      a;
      self.dice_inicio();
      @call prandlast _vararg_count a;
      self.dice_fin();
      return a;
    ],
    dice_seq [ _vararg_count
      a;
      self.dice_inicio();
      @call prandseq _vararg_count a;
      self.dice_fin();
      return a;
    ],
    dice [ _vararg_count
      msg nl hablado;
      self.dice_inicio();
      for ( : _vararg_count > 0: _vararg_count--) {
        @copy sp msg;
        if (msg ofclass String) {
          if (hablado) {          
            switch (self.dice_retardo) {
              -1:
               0: KeyDelay();
               default: WaitDelay(self.dice_retardo);
            }
          }
          print (string) msg;
          hablado = true;
        } else {
          nl = msg;
        }
      }
      self.dice_fin(nl);
      rtrue;
    ],
    dice_retardo -1,
    dice_inicio [;
      print "^---";
      glk_set_style(style_User1);
      if (self == player) print "Tú: ";
      else                print (string) self.short_name, ": ";
      glk_set_style(style_Normal);
      print "@<<";
    ],
    dice_fin [ nl;
      print "@>>";
      if (~~nl) new_line;
    ],
    marcha [ dir;
      print "^", (The) self, " ";
      if (dir == in_obj)       print "entra en ";
      else if (dir == out_obj) print "sale por ";
      else                     print "se marcha ";
      print (DirDada) dir, ".^";
    ],
    llega [ dir;
      print "^", (The) self, " ";
      if (self.tipo_de_movimiento == MOVIMIENTO_PERSEGUIR) {
        if (self.perseguido == player) {
          print "te sigue";
        } else {
          print "sigue ", (al) self.perseguido;
        }
      } else {
        print "llega";
      }
      if (dir ~= NULL) {
        print " desde ";
        LugarReal().(dir.door_dir).mostrar_nombre();
        print ".^";
      }
    ],
    mostrar_imagen [;
      if (self.imagen == 0) rfalse;
      ! Ocultamos antes la imagen en caso de que ya estuviera:
      timer_imagen_personaje.ocultar_imagen();
      MostrarImagenAuxiliar(self.imagen);
      timer_imagen_personaje.AgregarGestorAlFinal();
      give timer_imagen_personaje general;
    ],
    after [;
      Examine:
        self.mostrar_imagen();
    ],
    orders [;
      NotUnderstood, Tell, Answer:
        if (actor ~= player) <<Ask actor>>;
    ],
    ! Nosotros usaremos Qselect en lugar de select, para que funcione con el
    ! testeador automático:
    Qselect [ q
      old_pie;
      old_pie = parse_input_externo;
      if (parse_input_externo == -1) parse_input_externo = 1;
      self.select(q);
      glk_set_window(gg_mainwin);
      glk_window_noscroll(gg_mainwin);
      glk_window_close(gg_conversawin, 0);
      gg_conversawin = 0;
!      glk_set_config(config_WPaddingY, 0);
      parse_input_externo = old_pie;
    ],
  has
    animate proper;

    
!Class Sonido
!  with
!    emision 0,     ! El sonido a emitir
!    fuente 0,      ! El objeto del que parte el sonido
!    propagacion 3, ! El nº de localidades desde el que se puede oir el sonido
!    volumen_principal 100, ! Volumen del sonido cuando el objeto está ahí
!    volumen [
!      d r;
!      if (self.fuente == 0) return 0;
!      if (ScopeCeiling(self.fuente) == LugarReal()) {
!        return self.volumen_principal;
!      }
!      move testigo to ScopeCeiling(player);
!      PNJ_Ruta(testigo, MOVIMIENTO_PERSEGUIR, self.fuente);
!      d = testigo.longitud_precamino;
!      PNJ_Ruta(testigo, MOVIMIENTO_NINGUNO);
!      remove testigo;
!      r = self.volumen_principal -
!          (self.volumen_principal / self.propagacion * d);
!      if (r < 0) r = 0;
!      return r;
!    ],
!    cambiar_volumen [;
!      Damusix.VolumenCanal(self.canal, self.volumen());
!    ],
!    sonando [;
!      return Damusix.SonandoDeFondoCanal(self.canal);
!    ],
!    tocar_sonido [ snd;
!      if (snd ~= 0) self.emision = snd;
!      #ifdef DEBUG;
!      if (self.emision == 0) {
!        "*** ERROR: Se intenta tocar un sonido sin definirlo antes ***"; 
!      }
!      #endif;
!      if (self.emision ~= 0) {
!        Damusix.AsignarCanal(self.emision, self.canal, self.volumen(),
!                             SONIDO_REPETIR);
!        Damusix.TocarCanal(self.canal);
!      }
!    ],
!    parar_sonido [;
!      Damusix.PararCanal(self.canal);
!    ],
!    sonar [ snd;
!      self.tocar_sonido(snd);
!    ],
!    parar [;
!      self.parar_sonido();
!    ],    
!    quitar [;
!      self.parar();
!      remove self;
!      give self absent;
!    ],
!  has
!    concealed;


!===============================================================================
! (8) Objetos del Juego
!-------------------------------------------------------------------------------


! ====================================================================
! OBJETOS DE SOPORTE
! ====================================================================


Object barra_estado
  class objeto_barra_estado
  with
    modo BE_COMPUESTO,
    disposicion
      1  1 true BE_LOCALIDAD
      68 1 true BE_TURNOS,
    lineas_inv
      BE_INV_TOTAL;


! Lugar necesario para que no haya errores al compilar si no hay localidades
! definidas con nombre_si_visitado, nombre_no_visitado y nombre_dirección:
Object
  class Lugar
  with
    nombre_si_visitado NULL,
    nombre_no_visitado NULL,
    nombre_direccion   NULL;


Object testigo
  class Movil;


Object timer_imagen_personaje
  class GestorTimer
  with
    duracion TIMER_DURACION_IMAGEN_PERSONAJE,
    mostrandose [;
      return self has general;
    ],
    ocultar_imagen [;
      if (self.mostrandose()) self.evento();
    ],
    evento [;
      OcultarImagenAuxiliar();
      give self ~general;
      self.EliminarGestor();
      MostrarImagenLocalidad();
    ];


! ====================================================================
! MENÚS ZIPI
! ====================================================================


[ ZIPI_PintaTitulo titulo anchura altura
  j;
  ZIPI_clrscr();
  #ifdef TARGET_ZCODE;
  @split_window 1;
  #endif;
  ZIPI_setwindow();
  ZIPI_setcursor(1 + anchura, 1 + altura);
  ZIPI_bold();
  j = ZIPI_getwidth();
  if (j == 0) j = 80;
  ZIPI_spaces(j);
  ZIPI_setcursor(2 + anchura, 1 + altura);
  PrintOrRunVar(titulo, 1);
  ZIPI_roman();
];


[ ZIPI_RunMenu _m top
  i j count cur key dest r tec anchura altura;

  cur = 0;
  count = _m.#ZIPI_item / WORDSIZE; count = count + 2;

  for (::) {
    glk_window_get_size(gg_statuswin, gg_arguments, gg_arguments + WORDSIZE);
    anchura = gg_arguments-->0 / 4;
    if (top == 2) altura = 0;
    else          altura  = (gg_arguments-->1 / 2) - (count / 2);

    ZIPI_PintaTitulo(_m.ZIPI_titulo, anchura, altura);

    for (i = 0, tec = 0 : i < count - 2 : i++) {
      j = i + 3 + altura;
      ZIPI_setcursor(5 + anchura, j);
      if ((_m.&ZIPI_item-->i) ~= ZIPI_Separador) {
        glk_set_hyperlink(teclasOpciones->tec);
        print "[";
        glk_set_style(style_Header);
        print (char) teclasOpciones->tec;
        glk_set_style(style_Normal);
        print "] ";
        numeroOpciones->tec = i;
        tec++;
        PrintOrRun(_m.&ZIPI_item-->i, ZIPI_titulo);
        glk_set_hyperlink(0);
      }
    }

    j = i + 4 + altura;
    ZIPI_setcursor(5 + anchura, j);
    glk_set_hyperlink('Q');
    if (top) print (s_head) "[Q] Salir";
    else     print (s_head) "[Q] Volver";
    glk_set_hyperlink(0);
    j = cur + 3 + altura;
    ZIPI_setcursor(2 + anchura, j);
    print (s_emph) ">";
    ZIPI_setcursor(2 + anchura, j);

    key = ZIPI_tecla(gg_statuswin);

    print " ";

    switch (key) {
      'k', 'p', '-', '_', 129, -4:
        do {
          cur--;
          if (cur == count - 2) cur--;
          if (cur < 0) cur = count - 1;
        } until ((_m.&ZIPI_item-->cur) ~= ZIPI_Separador);

        'j', 'n', '=', '+', 130, -5:
        do {
          cur++;
          if (cur == count - 2) cur++;
          if (cur >= count) cur = 0;
        } until ((_m.&ZIPI_item-->cur) ~= ZIPI_Separador);

      'q', 'Q', 27, 131, 10, 8, -2, keycode_Escape:
        rfalse;
 
      132, 13, 'n', ' ', -3, -6:
    .Aceptar;
        if (cur == count - 1) rfalse;
        if (cur == count - 2) break;
        dest = _m.&ZIPI_item-->cur;
        if (dest ofclass ZIPI_Menu)          ZIPI_RunMenu(dest);
        else if (dest ofclass ZIPI_Pista)    ZIPI_RunPista(dest);
        else if (dest provides ZIPI_cambiar) dest.ZIPI_cambiar();
        else {
          glk_request_mouse_event(gg_statuswin);
          r = ZIPI_RunOtro(dest);
          glk_cancel_mouse_event(gg_statuswin);
          if (dest == ZIPI_Restaurar) return 3;
          if (r == 2) return r;
        }
    }

    ! Busca la tecla entre el vector
    for (i = 0 : i < MAXIMO_TECLAS_OPCIONES : i++) {
      if (key == (teclasOpciones->i) && i < tec) {
        cur = numeroOpciones->i;
        key = 132;
        jump Aceptar;
      }
    }
  }
  rfalse;
];


[ ZIPI_RunOtro _o
  r gr;
  gr = gg_bigwin ~= 0;
  if (gr) closeGraphicWindow();
  ZIPI_PintaTitulo(_o.ZIPI_titulo);
  print "^";
  r = _o.ZIPI_ejecutar();
  if (~~r) ZIPI_Espera();
  if (gr) {
    openGraphicWindow(ALTURA_LOGO_MENU);
    clearGraphicWindow();
    viewImageCenter(Logo_Circulo_Con_Letras_jpg);
  }
  return r;
];


[ ZIPI_tecla win sw
  key done ix gi;

  ! Comienzo del hackeo (c) Alpha
  if (parse_input_externo > 0) {
    glk_set_window(gg_mainwin);
    gi = test_machine.get_input();
    if (win) glk_set_window(win);
    if (gi ~= 0) {
      if (parse_input_externo == 2) parse_input_externo = -1; ! Para gtalk
      return buffer->WORDSIZE;
    }
  }
  if (parse_input_externo == -1) parse_input_externo = 0;
  ! Fin del hackeo (c) Alpha

  if (win) {
    glk_request_hyperlink_event(win);
    if (~~sw) glk_request_mouse_event(win);
  }

  glk_request_char_event(gg_mainwin);

  while (~~done) {
    glk_select(gg_event);
    ix = HandleGlkEvent(gg_event, 1, gg_arguments);
    if (ix == 2) {
      key = gg_arguments-->0;
      done = true;
    } else if (ix >= 0) {
      switch (gg_event-->0) {
        2, 8: ! evtype_CharInput, evtype_Hyperlink
              key = gg_event-->2;
              done = true;
           4: ! evtype_MouseInput
              key = 0; ! Devuelve la tecla 0, para no interferir
              done = true;
        5, 6: ! evtype_Arrange, evtype_Redraw
              DrawStatusLine();     ! Redibujamos la línea de estado
              if (win) glk_set_window(win);  ! Volvemos a la ventana anterior
              ! Cuando se redimensiona habiendo un menú de acciones, se
              ! devuelve la tecla 0, lo que hará que se redibuje la ventana:
              key = 0;
              done = true;
      }
    }
  }

  glk_cancel_char_event(gg_mainwin);

  if (win) {
    glk_request_hyperlink_event(win);
    if (~~sw) glk_request_mouse_event(win);
  }

  return key;
];


Object ZIPI_Accesibilidad
  class ZIPI_Menu
  with
    ZIPI_titulo "Opciones de accesibilidad",
    ZIPI_item
      ZIPI_Tiempo_Real
      ZIPI_Mostrar_Hyperlinks;

      
Object ZIPI_Aumentar_Texto
  class ZIPI_Otro
  with
    ZIPI_titulo "Aumentar tamaño del texto",
    ZIPI_cambiar [;
      glk_incr_fontsize();
      ZIPI_Configuracion.guardar_valores();
      RefrescarVentanasTexto();
      ! Esto sólo se ve en el menú principal, porque durante el juego
      ! el menú de configuración ocupa toda la pantalla, y luego
      ! restauramos el gráfico de la localidad actual:
      viewImageCenter(Logo_Circulo_Con_Letras_jpg);
    ];


Object ZIPI_Configuracion
  class ZIPI_Menu
  with
    ZIPI_titulo "Opciones de gráficos y sonido",
    monosize INICIAL_MONOSIZE,
    propsize INICIAL_PROPSIZE,
    leading  INICIAL_LEADING,
    baseline INICIAL_BASELINE,
    guardar_valores [;
      self.monosize = glk_get_config(config_MonoSize);
      self.propsize = glk_get_config(config_PropSize);
      self.leading  = glk_get_config(config_Leading);
      self.baseline = glk_get_config(config_Baseline);
    ],
    restaurar_valores [;
      glk_set_config(config_MonoSize, self.monosize);
      glk_set_config(config_PropSize, self.propsize);
      glk_set_config(config_Leading,  self.leading);
      glk_set_config(config_Baseline, self.baseline);
      RefrescarVentanasTexto();
    ],
    ZIPI_item
      ZIPI_Graficos
      ZIPI_Tamano_Graficos
      ZIPI_Sonido
      ZIPI_Sonido_Fondo
      ZIPI_Separador
      ZIPI_Aumentar_Texto
      ZIPI_Disminuir_Texto
      ZIPI_Separador
      ZIPI_Accesibilidad;


Object ZIPI_Disminuir_Texto
  class ZIPI_Otro
  with
    ZIPI_titulo "Disminuir tamaño del texto",
    ZIPI_cambiar [;
      glk_decr_fontsize();
      ZIPI_Configuracion.guardar_valores();
      RefrescarVentanasTexto();
      ! Esto sólo se ve en el menú principal, porque durante el juego
      ! el menú de configuración ocupa toda la pantalla, y luego
      ! restauramos el gráfico de la localidad actual:
      viewImageCenter(Logo_Circulo_Con_Letras_jpg);
    ];


Object ZIPI_Graficos
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      if (hayGraficos) "Gráficos: SÍ (recomendado)";
      else             "Gráficos: NO";
    ],
    ZIPI_cambiar [;
      hayGraficos = ~~hayGraficos;
    ];


Object ZIPI_Jugar_Con_Intro
  class ZIPI_Otro
  with
    ZIPI_titulo "Comenzar la aventura con introducción",
    ZIPI_ejecutar [;
      StatusLineHeight(1);
      glk_window_clear(gg_statuswin);
      glk_set_window(gg_mainwin);
      clearTextWindow();
      if (hayGraficos) EncenderGraficos();
      else             ApagarGraficos();
      Introduccion();
      IniciarAventura();
      dibujarEstado = true;
      return 2;
    ];

    
Object ZIPI_Jugar_Sin_Intro
  class ZIPI_Otro
  with
    ZIPI_titulo "Comenzar la aventura saltando la introducción",
    ZIPI_ejecutar [;
      StatusLineHeight(1);
      glk_window_clear(gg_statuswin);
      glk_set_window(gg_mainwin);
      clearTextWindow();
      if (hayGraficos) EncenderGraficos();
      else             ApagarGraficos();
      IniciarAventura(true);
      dibujarEstado = true;
      return 2;
    ];


Object ZIPI_Menu_Principal
  class ZIPI_Menu
  with
    ZIPI_titulo "EL CÍRCULO - (c) Alpha Aventuras 2012",
    ZIPI_item
      ZIPI_Jugar_Con_Intro
      ZIPI_Jugar_Sin_Intro
      ZIPI_Restaurar_Partida
      ZIPI_Configuracion
      ZIPI_Separador
      ZIPI_Menu1;


Object ZIPI_Mostrar_Hyperlinks
  class ZIPI_Otro
  with
    mostrarLink true,
    colorLink COLOR_HYPERLINK,
    ZIPI_titulo [;
      if (self.mostrarLink) "Mostrar hipervínculos: SÍ (recomendado)";
      else                  "Mostrar hipervínculos: NO";
    ],
    restaurar_valores [
      c;
      if (self.mostrarLink) {
        glk_set_config(config_LinkColor, self.colorLink);
      } else {
        self.colorLink = glk_get_config(config_LinkColor);
        c = glk_window_stylehint_get(gg_mainwin, style_Normal,
                                     stylehint_TextColor);
        glk_set_config(config_LinkColor, c);
      }
    ],
    ZIPI_cambiar [;
      self.mostrarLink = ~~(self.mostrarLink);
      self.restaurar_valores();
    ];


Object ZIPI_Restaurar_Partida
  class ZIPI_Otro
  with
    ZIPI_titulo "Restaurar una partida guardada",
    ZIPI_ejecutar [ res fref;
      StatusLineHeight(1);
      clearTextWindow();
      glk_set_window(gg_mainwin);
      fref = glk($0062, $01, $02, 0); ! fileref_create_by_prompt
      if (fref == 0) jump RFailed;
      gg_savestr = glk($0042, fref, $02, GG_SAVESTR_ROCK); ! stream_open_file
      glk($0063, fref); ! fileref_destroy
      if (gg_savestr == 0) jump RFailed;

      @restore gg_savestr res;

      glk($0044, gg_savestr, 0); ! stream_close
      gg_savestr = 0;

    .RFailed;
      glk_set_window(gg_statuswin);
      ExtenderVentanaEstado();
      print "^Error: no se ha podido cargar la partida.";
      rfalse;
    ];
      

Object ZIPI_Salir
  class ZIPI_Otro
  with
    ZIPI_titulo "Salir",
    ZIPI_ejecutar [; quit; ];


Object ZIPI_Sonido
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      if (haySonido) "Sonido global: SÍ (recomendado)";
      else           "Sonido global: NO";
    ],
    ZIPI_cambiar [;
      haySonido = ~~haySonido;
      if (haySonido) Damusix.ActivarAudio();
      else           Damusix.DesactivarAudio();
    ];


Object ZIPI_Sonido_Fondo
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      if (haySonidoFondo) "Sonido de fondo: SÍ (recomendado)";
      else                "Sonido de fondo: NO";
    ],
    ZIPI_cambiar [;
      haySonidoFondo = ~~haySonidoFondo;
      if (haySonidoFondo) Damusix.VolumenCanal(CANAL_FONDO, VOLUMEN_FONDO);
      else                Damusix.VolumenCanal(CANAL_FONDO, 0);
    ];


Object ZIPI_Tamano_Graficos
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      switch (altoVentanaGrafica) {
        GRAFICOS_MINUSCULOS: "Tamaño de gráficos: ",
                             GRAFICOS_MINUSCULOS, " px. (MINÚSCULOS)";
        GRAFICOS_PEQUENOS:   "Tamaño de gráficos: ",
                             GRAFICOS_PEQUENOS, " px. (PEQUEÑOS)";
        GRAFICOS_MEDIANOS:   "Tamaño de gráficos: ",
                             GRAFICOS_MEDIANOS, " px. (MEDIANOS, recomendado)";
        GRAFICOS_GRANDES:    "Tamaño de gráficos: ",
                             GRAFICOS_GRANDES,  " px. (GRANDES)";
        default:             "Tamaño de gráficos: ",
                             altoVentanaGrafica, " px.";          
      }
    ],
    ZIPI_cambiar [;
      if (altoVentanaGrafica < GRAFICOS_GRANDES)
        altoVentanaGrafica = altoVentanaGrafica + 50;
      else
        altoVentanaGrafica = GRAFICOS_MINUSCULOS;
    ];


Object ZIPI_Tiempo_Real
  class ZIPI_Otro
  with
    ZIPI_titulo [;
      if (hayTiempoReal) "Tiempo real: SÍ (recomendado)";
      else               "Tiempo real: NO";
    ],
    ZIPI_restaurar [;
      if (hayTiempoReal) ControlTimer.ActivarTick(TIMER_TICK);
      else               ControlTimer.DesactivarTick();
    ],
    ZIPI_cambiar [;
      hayTiempoReal = ~~hayTiempoReal;
!      self.ZIPI_restaurar();
    ];


! ====================================================================
! MENÚS DE ACCIONES
! ====================================================================


Object MenuAcciones
  with
    acciones_comunes Menu_Examinar Menu_Coger Menu_Dejar Menu_Abrir
                     Menu_Cerrar Menu_AbrirCon Menu_CerrarCon
                     Menu_Encender Menu_Apagar,
    ! El IdentifyGlkObject de la ventana de menús de acciones:
    Menu_IdentifyGlkObject [ fase tipo ref rock;
      if (fase == 0) { ! Poner cero en todos nuestros objetos glk
        gg_menuwin = 0;
        return;
      }
      if (fase == 1) { ! Reiniciar correctamente las variables glk
        switch (tipo) {
          0: ! es una ventana
             switch (rock) {
               GG_MENUWIN_ROCK: gg_menuwin = ref;
             }
          1: ! es un flujo
             ! pero no hay flujos en este ejemplo
          2: ! es una referencia a fichero
             ! pero no hay ficheros en este ejemplo
        }
        return;
      }
      if (fase == 2) { ! Actualizar nuestras ventanas
        if (layoutPantalla == LAYOUT_MENU_PRINCIPAL) {
          if (gg_menuwin) {
            MenuAcciones.CerrarVentana();
          }
        } else { ! layoutPantalla == LAYOUT_JUEGO
          MenuAcciones.AbrirVentana();
        }
        return;
      }
    ],
    ! Se encarga de mostrar el menú de acciones correctamente, desactivando
    ! previamente los timers y preparando las ventanas antes y después.
    ! Si top == true, no se muestra la opción de "[Q] Salir":
    MostrarAcciones [ obj top
      r;
!      if (obj provides ZIPI_item) {
        ControlTimer.PausarTick();
        glk_cancel_line_event(gg_mainwin, gg_event);
        glk_set_window(gg_menuwin);
        glk_cancel_hyperlink_event(gg_mainwin);    ! Durante el menú, desactiva
        glk_cancel_hyperlink_event(gg_statuswin);  ! enlaces de otras ventanas
        r = self.RunMenu(obj, top);
        self.MostrarImportantes();
        glk_set_window(gg_mainwin);
        glk_request_hyperlink_event(gg_mainwin);   ! Se vuelven a activar los
        glk_request_hyperlink_event(gg_statuswin); ! enlaces de otras ventanas
        glk_request_hyperlink_event(gg_menuwin);   ! incluyendo la de menú
        ControlTimer.ReanudarTick();
!      }
      return r;
    ],
    MostrarImportantes [ menu
      i o;
      glk_set_window(gg_menuwin);
      glk_window_clear(gg_menuwin);
      glk_request_hyperlink_event(gg_menuwin);
      new_line;
      if (menu == 0) menu = Menu_Importantes;
      for (i = 0 : i < menu.#ZIPI_item / WORDSIZE : i++) {
        o = menu.&ZIPI_item-->i;
        if (o ~= ZIPI_Separador) {
          print " - ";
          glk_set_hyperlink(o);
          print (string) o.ZIPI_titulo;
          glk_set_hyperlink(0);
        }
        new_line;
      }
      glk_set_window(gg_mainwin);
    ],
    AbrirVentana [;
      if (gg_menuwin) glk_window_close(gg_menuwin, 0);
      gg_menuwin = glk_window_open(gg_mainwin,
                                   winmethod_Right + winmethod_Fixed,
                                   ANCHO_ACCIONES, wintype_TextGrid,
                                   GG_MENUWIN_ROCK);
      self.MostrarImportantes();
    ],
    CerrarVentana [;
      glk_window_close(gg_menuwin, 0);
      gg_menuwin = 0;
    ],
    ! Muestra el menú de acciones de un objeto:
    RunMenu [ _m top
      menu size i j count opc cur key dest tec altura anchura delta oldcur;

      ! Si el objeto tiene menú propio, usamos ése. En caso contrario, usamos
      ! el menú de acciones comunes:
      if (_m provides ZIPI_item) {
        menu = _m.&ZIPI_item;
        size = _m.#ZIPI_item / WORDSIZE;
      } else {
        menu = self.&acciones_comunes;
        size = self.#acciones_comunes / WORDSIZE;
      }

      for (i = count = 0 : i < size : i++) {
        opc = menu-->i;
        if (opc == 0 or ZIPI_Separador) continue;
        if (opc provides ZIPI_condicion && (~~(opc.ZIPI_condicion(_m)))) {
          continue;
        }
        if (count < MAXIMO_OPCIONES) {
          opcionesMenu-->count = opc;
          count++;
        #ifdef DEBUG;
        } else {
          print "*** ERROR: Superado número máximo de opciones del menú ***";
        #endif;
        }
      }

      ! Si sólo hay una opción, y es la de examinar, directamente examinamos:
      if (count == 1 && menu-->0 == Menu_Examinar) return menu-->0;

      if (~~top) {
        opcionesMenu-->count++ = ZIPI_Separador;
        opcionesMenu-->count++ = ZIPI_Ninguna;
      }

      cur = 0;

      for (::) {
        glk_window_get_size(gg_menuwin, gg_arguments, gg_arguments + WORDSIZE);
        anchura = gg_arguments-->0;
        altura  = gg_arguments-->1;

        glk_window_clear(gg_menuwin);
        if (_m provides ZIPI_titulo) {
          glk_set_style(style_Input);
          print " ", (string) _m.ZIPI_titulo, "^";
          glk_set_style(style_Normal);
        } else {
          glk_set_style(style_Input);
          print " "; PrintInputLink(_m); print ":^";
          glk_set_style(style_Normal);
        }

        if (delta > 0) {
          glk($002B, gg_menuwin, anchura - 1, 1);
          print "@@94";
        }

        for (i = 0 + delta, tec = 0 + delta : i < count : i++) {
          j = i + 3 - delta;
          if (j >= altura) break;
          glk($002B, gg_menuwin, 3, j - 1);
          opc = opcionesMenu-->i;
          if (opc ~= ZIPI_Separador) {
            if (opc == ZIPI_Ninguna) {
              glk_set_hyperlink('Q');
              print "[", (s_head) "Q", "] ";
            } else {
              glk_set_hyperlink(teclasOpciones->tec);
              print "[";
              glk_set_style(style_Header);
              if (tec < MAXIMO_TECLAS_OPCIONES) {
                print (char) teclasOpciones->tec;
                numeroOpciones->tec = i;
                tec++;
              } else {
                print " ";
              }
              glk_set_style(style_Normal);
              print "] ";
            }
            PrintOrRun(opc, ZIPI_titulo);
            glk_set_hyperlink(0);
          }
        }

        j = i + 4 - delta;

        if (j > altura) {
          glk($002B, gg_menuwin, anchura - 1, altura - 1);
          print "v";
        }

        j = cur + 3 - delta;
        glk($002B, gg_menuwin, 1, j - 1);
        print (s_emph) ">";
        glk($002B, gg_menuwin, 1, j - 1);

        key = ZIPI_tecla(gg_menuwin, true);

        if (key >= 'a' && key <= 'z') key = key - 32;  ! Pasamos a mayúsculas

        print " ";

        switch (key) {
          'k', 'p', '-', '_', 129, -4:
            do {
              oldcur = cur;
              cur--;
              if (cur < 0) cur = 0;
              if (j <= 3) delta = delta - (oldcur - cur);
            } until (opcionesMenu-->cur ~= ZIPI_Separador);

          'j', 'n', '=', '+', 130, -5:
            do {
              oldcur = cur;
              cur++;
              if (cur > count - 1) cur = count - 1;
              if (j >= altura - 1) delta = delta + (cur - oldcur);
            } until (opcionesMenu-->cur ~= ZIPI_Separador);

          'q', 'Q', 27, 131, 10, 8, -2, keycode_Escape:
            if (~~top) rfalse;

          132, 13, 'n', ' ', -3, -6:
        .Aceptar;
            dest = opcionesMenu-->cur;
            if (dest ofclass ZIPI_Menu) {
              return MenuAcciones.RunMenu(dest, top);
            } else if (dest == ZIPI_Ninguna) {
              rfalse;
            } else if (dest ofclass ZIPI_Pista) {
              ZIPI_RunPista(dest);
            } else if (dest provides ZIPI_cambiar) {
              dest.ZIPI_cambiar();
            } else {
              return dest;
            }
        }

        ! Busca la tecla en el vector:
        for (i = 0 : i < MAXIMO_TECLAS_OPCIONES : i++) {
          if (key == (teclasOpciones->i) && i < tec) {
            cur = numeroOpciones->i;
            key = 132;
            jump Aceptar;
          }
        }
      }

      rfalse;
    ];


Object Menu_Abrir
  class ZIPI_Otro
  with
    ZIPI_titulo "Abrir",
    ZIPI_ejecutar [; return 'abre'; ],
    ZIPI_condicion [ obj;
      return obj has openable && obj hasnt open;
    ];


Object Menu_AbrirCon
  class ZIPI_Otro
  with
    ZIPI_titulo "Abrir con...",
    ZIPI_secundario [; return 'con'; ],
    ZIPI_ejecutar [; return 'abre'; ],
    ZIPI_condicion [ obj;
      return obj has openable && obj hasnt open;
    ],
  has
    general; ! Esto indica que el jugador puede seguir escribiendo el input


Object Menu_Apagar
  class ZIPI_Otro
  with
    ZIPI_titulo "Apagar",
    ZIPI_ejecutar [; return 'apaga'; ],
    ZIPI_condicion [ obj;
      return obj has switchable && obj has on;
    ];


Object Menu_Cerrar
  class ZIPI_Otro
  with
    ZIPI_titulo "Cerrar",
    ZIPI_ejecutar [; return 'cierra'; ],
    ZIPI_condicion [ obj;
      return obj has openable && obj has open;
    ];


Object Menu_CerrarCon
  class ZIPI_Otro
  with
    ZIPI_titulo "Cerrar con...",
    ZIPI_secundario [; return 'con'; ],
    ZIPI_ejecutar [; return 'cierra'; ],
    ZIPI_condicion [ obj;
      return obj has openable && obj has open;
    ],
  has
    general; ! Esto indica que el jugador puede seguir escribiendo el input


Object Menu_Coger
  class ZIPI_Otro
  with
    ZIPI_titulo "Coger",
    ZIPI_ejecutar [; return 'coge'; ],
    ZIPI_condicion [ obj;
      return (~~IndirectlyContains(player, obj)) && (~~(obj ofclass Personaje));
    ];


Object Menu_Dejar
  class ZIPI_Otro
  with
    ZIPI_titulo "Dejar",
    ZIPI_ejecutar [; return 'deja'; ],
    ZIPI_condicion [ obj;
      return IndirectlyContains(player, obj);
    ];


Object Menu_Encender
  class ZIPI_Otro
  with
    ZIPI_titulo "Encender",
    ZIPI_ejecutar [; return 'enciende'; ],
    ZIPI_condicion [ obj;
      return obj has switchable && obj hasnt on;
    ];

    
Object Menu_Examinar
  class ZIPI_Otro
  with
    ZIPI_titulo "Examinar",
    ZIPI_ejecutar [; return 'ex'; ];


Object ZIPI_Ninguna
  class ZIPI_Otro
  with
    ZIPI_titulo "Ninguna acción";


Object Menu_YesOrNo
  class ZIPI_Menu
  with
    ZIPI_titulo "¿Sí o no?",
    ZIPI_item
      Menu_Yes
      Menu_No;


Object Menu_Yes
  class ZIPI_Otro
  with
    ZIPI_titulo "Sí",
    ZIPI_ejecutar [; return 1; ];


Object Menu_No
  class ZIPI_Otro
  with
    ZIPI_titulo "No",
    ZIPI_ejecutar [; return 0; ];


Object Menu_AfterGameOver
  class ZIPI_Menu
  with
    ZIPI_titulo "Opciones:",
    ZIPI_item
      Menu_Restart
      Menu_Restore
      Menu_Undo
      Menu_Score
      Menu_Amusing
      Menu_Quit;


Object Menu_Restart
  class ZIPI_Otro
  with
    ZIPI_titulo "Reiniciar",
    ZIPI_ejecutar [; return RESTART__WD; ];


Object Menu_Restore
  class ZIPI_Otro
  with
    ZIPI_titulo "Recuperar",
    ZIPI_ejecutar [; return RESTORE__WD; ];


Object Menu_Save
  class ZIPI_Otro
  with
    ZIPI_titulo "Guardar",
    ZIPI_ejecutar [; return "guardar"; ];


Object Menu_Undo
  class ZIPI_Otro
  with
    ZIPI_titulo "Anular",
    ZIPI_ejecutar [; return UNDO1__WD; ];


Object Menu_Score
  class ZIPI_Otro
  with
    ZIPI_titulo "Puntuación",
    ZIPI_condicion [; return TASKS_PROVIDED == 0; ],
    ZIPI_ejecutar [; return FULLSCORE1__WD; ];


Object Menu_Amusing
  class ZIPI_Otro
  with
    ZIPI_titulo "Curiosidades",
    ZIPI_ejecutar [; return AMUSING__WD; ];    


Object Menu_Quit
  class ZIPI_Otro
  with
    ZIPI_titulo "Terminar",
    ZIPI_ejecutar [; return QUIT1__WD; ];


Object Menu_Importantes
  class ZIPI_Menu
  with
    ZIPI_titulo "Principal",
    ZIPI_item
      Menu_Ayuda
      Menu_Inventario
      Menu_Mapa
      Menu_Configuracion
      ZIPI_Separador
      Menu_Save
      Menu_Restore
      ZIPI_Separador
      Menu_Restart
      Menu_Quit;


Object Menu_Ayuda
  class ZIPI_Otro
  with
    ZIPI_titulo "Ayuda",
    ZIPI_ejecutar [; return "ayuda"; ];

    
Object Menu_Inventario
  class ZIPI_Otro
  with
    ZIPI_titulo "Inventario",
    ZIPI_ejecutar [; return "i"; ];


Object Menu_Mapa
  class ZIPI_Otro
  with
    ZIPI_titulo "Mapa",
    ZIPI_ejecutar [; return "mapa"; ];


Object Menu_Configuracion
  class ZIPI_Otro
  with
    ZIPI_titulo "Configuración",
    ZIPI_ejecutar [; return "configuracion"; ];


!===============================================================================
! (9) Otras Rutinas Reemplazadas; Rutinas Propias del Juego
!-------------------------------------------------------------------------------


[ ApagarGraficos t;
  hayGraficos = false;
  closeGraphicWindow();
  if (t) print (s_emph) "[Gráficos desactivados.]^";
];


[ BanderaFin df;
  deadflag = df;
  ControlTimer.DesactivarTick();
  Damusix.PararTodo();
];


[ CerrarVentanaMapa;
  glk_window_close(gg_mapawin, 0);
  gg_mapawin = 0;
  MenuAcciones.AbrirVentana();
  if (hayGraficos) EncenderGraficos();
  else             ApagarGraficos();
  ControlTimer.ReanudarTick();
  glk_window_noscroll(gg_mainwin);
];


[ ComoHablar;
  print_ret "[Para hablar con un personaje, usa la forma ~",
            (s_input) "PERSONAJE, lo que sea", "~. Por ejemplo: ~",
            (s_input) "JASON, QUÉ OPINAS DE MADRE", "~.]";
];


! Si dest es una localidad adyacente a la actual, devuelve la dirección en la
! que se encuentra:
[ ConexionLocalidad dest
  l o;
  l = LugarReal();
  objectloop (o in Compass) {
    if (dest == l.(o.door_dir)) return o;
  }
  rfalse;
];


! Igualmente, esta versión no muestra puntos cardinales, sino lugares, al
! indicar hacia dónde va un PNJ móvil:
[ DirDada i
  l par;
  par = true;
  switch (i) {
    n_obj:   par = false; ! print "hacia el norte";
    s_obj:   par = false; ! print "hacia el sur";
    e_obj:   par = false; ! print "hacia el este";
    w_obj:   par = false; ! print "hacia el oeste";
    ne_obj:  par = false; ! print "hacia el noreste";
    nw_obj:  par = false; ! print "hacia el noroeste";
    se_obj:  par = false; ! print "hacia el sureste";
    sw_obj:  par = false; ! print "hacia el suroeste";
    u_obj:   par = false; ! print "hacia arriba";
    d_obj:   par = false; ! print "hacia abajo";
    in_obj:  par = false; ! print "al interior";
    out_obj: par = false; ! print "afuera";
    default: print "hacia ", (the) i;
  }
  l = LugarReal();
    
  if (par) print " (";
  if (~~(i == in_obj or out_obj)) print "hacia ";
  l.(i.door_dir).mostrar_nombre();
  if (par) print ")";
];


[ EncenderGraficos t;
  hayGraficos = true;
  openGraphicWindow(altoVentanaGrafica);
  clearGraphicWindow();
  MostrarImagenLocalidad();
  if (t) {
    glk_set_style(style_Emphasized);
    print "[Gráficos activados (tamaño ";
    switch (altoVentanaGrafica) {
      GRAFICOS_PEQUENOS: print "pequeño";
      GRAFICOS_MEDIANOS: print "mediano";
      GRAFICOS_GRANDES:  print "grande";
      default:           print altoVentanaGrafica, " px";
    }
    print ").]^";
    style roman;
  }
];


! Esta versión de ExaminarFalsoSub convierte la acción en Entrar o
! Examinar dependiendo de si el objeto de destino es una localidad o no:
[ ExaminarFalsoSub;
  ! Si es el nombre de la localidad actual, la describimos:
  if (noun == location) { PrintOrRun(noun, description); rtrue; }
  if (noun ofclass Lugar) <<Enter noun>>;
  else                    <<Examine noun>>;
];


[ ExtenderVentanaEstado por;
  if (por == 0) por = 100;
  glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
                             winmethod_Above + winmethod_Proportional +
                             winmethod_NoBorder, por, 0);
];


[ IniciarGraficosSonidos;
  if (glk_gestalt(gestalt_AlphaAventuras, 0) == 0) {
    print "^Lo sentimos, pero este juego necesita un intérprete
            propio y no funcionará con ningún otro intérprete Glulx
            estándar.^";
    KeyDelay();
    quit;
  }

  if (~~testGraphics()) {
    print "^Lo sentimos, pero este juego necesita un intérprete Glulx
            con capacidades gráficas.^^";
    RecomiendaGargoyle();
  }

  if (Damusix.TestAudio() == 0) {
    print "^Lo sentimos, pero este juego necesita un intérprete Glulx
            que pueda reproducir sonido.^^";
    RecomiendaGargoyle();
  }

  if (glk_gestalt(gestalt_Timer,0) == 0) {
    print "^Lo sentimos, pero este juego necesita un intérprete Glulx
            que tenga soporte para eventos temporizados.^^";
    RecomiendaGargoyle();
  }

  ! Inicialización sonora
  IniciarSonidos();

  ! Inicialización gráfica
  initializeSGW(altoVentanaGrafica);
];


[ IniciarSonidos;
  Damusix.VolumenCanal(CANAL_FONDO,     VOLUMEN_FONDO);
  Damusix.VolumenCanal(CANAL_TV_SALON,  VOLUMEN_TV_SALON);
  Damusix.VolumenCanal(CANAL_TV_CUARTO, VOLUMEN_TV_CUARTO);
  Damusix.VolumenCanal(CANAL_TELEFONO,  VOLUMEN_TELEFONO);
];


[ Introduccion;
  clearMainWindow();
  viewImageCenter(Oscuridad_jpg);
  InicioPrologo();
];


[ ImprimirPrompt;
  if (player ~= selfobj) {
    glk_set_style(style_User1);
    print (string) player.short_name;
    glk_set_style(style_Normal);
    print " ";
  }
  print (s_input) "> ";
];


[ InputLink obj;
  if (obj ofclass String)      return obj;
  if (obj ofclass Routine)     return obj();
  if (obj provides input_link) return obj.input_link;
  if (obj provides name)       return obj.&name-->0;
  if (obj provides name_m)     return obj.&name_m-->0;
  if (obj provides name_f)     return obj.&name_f-->0;
  if (obj provides name_mp)    return obj.&name_mp-->0;
  if (obj provides name_fp)    return obj.&name_fp-->0;
];


[ link obj msg;
  glk_set_hyperlink(obj);
  if (msg ~= 0) print (string) msg;
  else if (~~(obj ofclass Object))   print (string) obj;
  else if (obj provides nombre_link) print (string) obj.nombre_link;
  else                               PrintInputLink(obj);
  glk_set_hyperlink(0);
];


[ link_i obj msg;
  glk_set_style(style_Input);
  link(obj, msg);
  glk_set_style(style_Normal);
];


#ifndef LugarReal;
[ LugarReal;
  if (location == thedark) return real_location;
  else                     return location;
];
#endif;


[ MostrarImagenAuxiliar img;
!  if (gg_objwin ~= 0) glk_window_close(gg_objwin, 0); 
!  gg_objwin = glk_window_open(gg_bigwin,
!                              (winmethod_Above + winmethod_Proportional),
!                              100, wintype_Graphics, GG_OBJWIN_ROCK);
!  drawImageSGW(gg_objwin, img, curr_pic_pos, BORDEWIN, BORDEWIN);
  viewImageCenter(img);
];


[ MostrarImagenLocalidad loc;
  if (~~loc) loc = location;
  if (loc provides sgw_img) viewImageCenter(loc.sgw_img);
];


[ MostrarImagenGradualmente imagen veces retardo
  i;
  for (i = 0 : i < veces : i++) {
    viewImageCenter(imagen, true);
    WaitDelay(retardo);
  }  
];


[ OcultarImagenAuxiliar;
!  if (gg_objwin ~= 0) glk_window_close(gg_objwin, 0);
!  gg_objwin = 0;
  MostrarImagenLocalidad();
];


[ PrintInputLink obj
  il;
  if (obj ofclass String)             print (string) obj;
  else if (obj ofclass Routine)       print (string) obj();
  else if (obj provides input_link) { il = obj.input_link;
                                      PrintAnything(il); }
  else if (obj provides name)         print (address) obj.&name-->0;
  else if (obj provides name_m)       print (address) obj.&name_m-->0;
  else if (obj provides name_f)       print (address) obj.&name_f-->0;
  else if (obj provides name_mp)      print (address) obj.&name_mp-->0;
  else if (obj provides name_fp)      print (address) obj.&name_fp-->0;
  else                                PrintAnything(obj);
];


[ RecomiendaGargoyle;
  print "~El círculo~ ha sido diseñada
         para funcionar con el intérprete Gargoyle, que puedes
         descargar de la siguiente dirección:^^",
         (s_pref) "http://code.google.com/p/garglk/downloads^";
  KeyDelay();
  quit;
];


[ RefrescarVentanasTexto;
  glk_window_get_arrangement(glk_window_get_parent(gg_statuswin),
                             gg_arguments, gg_arguments + WORDSIZE,
                             gg_arguments + 2 * WORDSIZE);
  glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
                             gg_arguments-->0, gg_arguments-->1,
                             gg_arguments-->2);
];


!===============================================================================
! (10) Verbos y Gramaticas Propias del Juego
!-------------------------------------------------------------------------------


Verb meta 'ayuda'
  *                 -> Ayuda;

Extend 'cambia' first
  * 'canal'/'emisora'                -> CambiarCanal
  * 'el' 'canal'                     -> CambiarCanal
  * 'la' 'emisora'                   -> CambiarCanal
  * 'de' 'canal'/'emisora'           -> CambiarCanal
  * 'canal'/'emisora' 'en' noun      -> CambiarCanal
  * 'el' 'canal'   'en' noun         -> CambiarCanal
  * 'la' 'emisora'  'en' noun        -> CambiarCanal
  * 'de' 'canal'/'emisora' 'en' noun -> CambiarCanal;

Verb 'chilla' = 'grita';

Verb meta 'configuracion'
  *                           -> Configuracion;

Verb meta 'creditos'
  *                 -> Creditos;

Verb 'cuelga'
  * noun            -> Colgar;

VerboIrregular "colgar" with imperativo 'cuelga';

Verb 'cuentale' = 'cuenta';

Verb 'descuelga'
  * noun            -> Descolgar;

VerboIrregular "descolgar" with imperativo 'descuelga';

Verb 'desenchufa'
  * noun            -> Desenchufar;

VerboIrregular "desenchufar" with imperativo 'desenchufa';

Extend 'di' first
  * 'a' creature             -> Answer;

Extend only 'enchufa' replace
  * noun            -> Enchufar;

Verb meta 'graficos'
  *                           -> Graficos
  * 'on'/'encendido'/'si'     -> EncenderGraficos
  * 'off'/'apagado'/'no'/'nx' -> ApagarGraficos
  * 'pequenos'                -> GraficosPequenos
  * 'medianos'                -> GraficosMedianos
  * 'grandes'                 -> GraficosGrandes;

Extend only 'grita' replace
  *                 -> Gritar
  * 'a//' creature  -> Gritar;

Extend 'habla' first
  * 'con' creature topic     -> Tell
  * 'con' creature           -> Tell
  * 'a' creature             -> Tell;

Verb 'hola'
  *                 -> Saludar;

Verb 'llama'
  *                 -> Llamar
  * 'a//' noun      -> Llamar
  * 'por' noun      -> LlamarPor;

Verb meta 'musica'
  *                                   -> Musica
  * 'fondo' 'on'/'encendida'/'si'     -> EncenderMusica
  * 'fondo' 'off'/'apagada'/'no'/'nx' -> ApagarMusica
  * 'on'/'encendida'/'si'             -> EncenderMusica
  * 'off'/'apagada'/'no'/ 'nx'        -> ApagarMusica;

Verb 'no.verb' * noun -> ExaminarFalso;

Verb meta 'pistas'
  *                 -> Pistas
  * 'no' / 'nx'     -> PistasNo;

Verb 'preguntale' = 'pregunta';

Extend only 'sal' 'salte' 'salirse' 'salirte'
  * noun            -> SalirA
  * 'a//' noun      -> SalirA;

Extend 'sal'
  * 'por' noun      -> SalirPor;

Extend 'saluda' first
  *                 -> Saludar;

Verb 'sigue'
  * creature               -> Seguir
  * creature 'aqui'        -> Seguir
  * 'a//' creature         -> Seguir
  * 'a//' creature 'aqui'  -> Seguir;

Verb meta 'sonido' 'sonidos'
  *                                   -> Sonido
  * 'on'/'encendido'/'si'             -> EncenderSonido
  * 'off'/'apagado'/'no'/'nx'         -> ApagarSonido
  * 'fondo'                           -> Musica
  * 'fondo' 'on'/'encendido'/'si'     -> EncenderMusica
  * 'fondo' 'off'/'apagado'/'no'/'nx' -> ApagarMusica;

Verb 'vamonos' 'vayamonos'
  *                  -> Venir
  * 'de' 'aqui'      -> Venir;

Verb 'vamos'
  *                  -> Venir;

Verb 'ven'
  *                  -> Venir
  * 'aqui'           -> Venir
  * 'conmigo'        -> Venir;

Verb meta 'verbo.nulo'
  *                  -> VerboNulo;
  
#ifdef DEBUG;
Verb meta 't'
  *                    -> TestPasoAPaso;

Verb meta 'tt'
  *                    -> TestContinuar;
#endif;


!===============================================================================
! (11) Rutinas de Acciones Propias del Juego
!-------------------------------------------------------------------------------


[ AnswerSub;
  ComoHablar();
];


[ ApagarGraficosSub;
  ApagarGraficos(true);
];

  
[ ApagarMusicaSub;
  haySonidoFondo = false;
  Damusix.VolumenCanal(CANAL_FONDO, 0);
  print (s_emph) "[Desactivado el sonido de fondo.]^";
];


[ ApagarSonidoSub;
  haySonido = false;
  Damusix.DesactivarAudio();
  print (s_emph) "[Desactivados todos los efectos sonoros.]^";
];


[ AyudaSub;
  print "Prueba a pedir ayuda a alguien. Si necesitas pistas más elaboradas,
         puedes usar el sistema de pistas interactivas tecleando el comando ",
         (link_i) "PISTAS", ".^";
];


[ CambiarCanalSub
  tv;
  if (noun ~= nothing)                     tv = noun;
  else if (tv_cuarto_katie in LugarReal()) tv = tv_cuarto_katie;
  else if (tv_salon_katie in LugarReal())  tv = tv_salon_katie;
  else "No veo ningún televisor aquí.";
  
  if (tv hasnt on) "El televisor está apagado.";
  
  "Cambias repetidamente de canal, pero sólo encuentras estática y ruido."; 
];


[ ColgarSub;
  "No tiene sentido colgar eso.";
];


[ ConfiguracionSub
  fondo v m;
  ControlTimer.PausarTick();
  fondo = Damusix.SonandoDeFondoCanal(CANAL_FONDO);
  ExtenderVentanaEstado();
  
  ZIPI_RunMenu(ZIPI_Configuracion, true);
  
  v = Damusix.QueVolumenCanal(CANAL_FONDO);
  if (LugarReal() provides sgw_mus) {
    m = LugarReal().sgw_mus;
    if (fondo && haySonidoFondo && v ~= 0 && (~~(Damusix.SonandoDeFondo(m)))) {
      Damusix.AsignarCanal(m, CANAL_FONDO, v, SONIDO_REPETIR);
      Damusix.TocarCanal(CANAL_FONDO);
    }
  }
  StatusLineHeight(1);
  MenuAcciones.MostrarImportantes();
  glk_window_noscroll(gg_mainwin);
  if (hayGraficos) EncenderGraficos();
  else             ApagarGraficos();
  ControlTimer.ReanudarTick();
];


[ ConsultSub;
  <<Examine noun>>;
];


[ CreditosSub;
  viewImageCenter(Logo_Alpha_Aventuras_jpg);
  print (s_head) "^@<<EL CÍRCULO@>>", " --- (c) 2012 Alpha Aventuras^^";
  print (s_bold) "-- PROGRAMACIÓN Y DISEÑO:^";
  print "    Ricardo Pérez López^^";
  print (s_bold) "-- GRÁFICOS:^";
  print "    Manuel Millán Ruiz^^";
  print (s_bold) "-- TEXTOS:^";
  print "    Ricardo Pérez López^^";
  print (s_bold) "-- MAPEADO Y DOCUMENTACIÓN:^";
  print "    Ricardo Pérez López^";
  print "    Antonio Matiola Ortiz^^";
  print (s_bold) "-- PRUEBAS:^";
  print "    Ricardo Pérez López^";
  print "    Manuel Millán Ruiz^^";
  KeyDelay();
  print "Desarrollado usando el lenguaje Inform, de Graham Nelson,
         con ayuda de las siguientes librerías:^^";
  print "- INFSP6 (fix), de Sarganar et al.^";
  print "- Adaptación de SGW+DMX, de Eliuk Blau^";
  print "- Damusix, de Eliuk Blau^";
  print "- PNJactor_NG y PNJacciones_NG (adaptaciones de los originales de Zak
           y Carlos)^";
!  print "- Rastros_NG (adaptación de Rastros, de Mel Hython)^";
  print "- Moviles_NG (adaptación de Moviles, de Mel Hython)^";
  print "- PNJpuertas_NG (Adaptación de PnjPuertas, de Jaevius)^";
  print "- Decir, de Zak^";
  print "- Etemas, de Zak^";
  print "- Decorado_NG (adaptación de Decorado, de Zak y Mel Hython)^";
!  print "- Teletipo (adaptación de Escr, de Baltasarq)^";
  print "- Adaptación de Barra, de Presi^";
  print "- Adaptación de ZIPI, de Zak^";
  print "- Timer, de Sothoth";
  KeyDelay();
  print "^^Basado en la novela @<<Ringu@>> de Koji Suzuki y el film
         @<<The Ring@>> (c) 2002 Dreamworks SKG.";
  print "^^Nuestro agradecimiento a todos los integrantes del CAAD que nos han
         ayudado, directa o indirectamente, en el desarrollo de esta aventura.^^
         (c) 2012 Alpha Aventuras^^
         Este programa es software libre, publicado bajo la licencia GNU GPL v3.
         El texto completo de la licencia se encuentra en la siguiente
         dirección:^^";
  print (s_pref) "http://www.gnu.org/licenses/gpl.txt^";
  print "^El código fuente del programa está disponible en Github:^^";
  print (s_pref) "https://github.com/ricpelo/elcirculo^";
  KeyDelay();
  print "^Visítanos en:^^";
  print (s_pref) "http://www.alpha-aventuras.es^
        http://wiki.caad.es/Alpha_Aventuras^
        http://www.facebook.com/alphaaventuras^";
  KeyDelay();
  MostrarImagenLocalidad();
];


[ DescolgarSub;
  "No tiene sentido descolgar eso.";
];


[ DesenchufarSub;
  if (~~(noun provides enchufado)) {
    print_ret (The) noun, " no puede desenchufarse.";
  }
  if (~~(noun.enchufado)) {
    print_ret (The) noun, " ya está desenchufado.";
  }
  noun.enchufado = false;
  print "Desenchufas ", (the) noun, ".";
  if (noun has on) {
    give noun ~on;
    " Al hacerlo, se apaga.";
  }
];


[ EncenderGraficosSub;
  EncenderGraficos(true);
];


[ EncenderMusicaSub i;
  haySonidoFondo = true;
  Damusix.VolumenCanal(CANAL_FONDO, VOLUMEN_FONDO);

  if (~~i) {
    print (s_emph) "[Activado el sonido de fondo.]^";
  }
];


[ EncenderSonidoSub;
  haySonido = true;
  Damusix.ActivarAudio();
  print (s_emph) "[Activados todos los efectos sonoros.]^";
];


[ EnchufarSub;
  if (~~(noun provides enchufado)) {
    print_ret (The) noun, " no puede enchufarse.";
  }
  if (noun.enchufado) {
    print_ret (The) noun, " ya está enchufado.";
  }
  noun.enchufado = true;
  "Enchufas ", (the) noun, ".";
];


[ GraficosGrandesSub;
  altoVentanaGrafica = GRAFICOS_GRANDES;
  EncenderGraficosSub();
];


[ GraficosMedianosSub;
  altoVentanaGrafica = GRAFICOS_MEDIANOS;
  EncenderGraficosSub();
];


[ GraficosPequenosSub;
  altoVentanaGrafica = GRAFICOS_PEQUENOS;
  EncenderGraficosSub();
];


[ GraficosSub;
  print (s_emph) "[Por favor, usa la forma ~", (link_i) "GRAFICOS SI",
        (s_emph) "~ o ~", (link_i) "GRAFICOS NO", (s_emph) "~ para activar o
        desactivar, respectivamente, el uso de gráficos. También puedes
        cambiar el tamaño de la ventana gráfica usando ~",
        (link_i) "GRAFICOS PEQUEÑOS", (s_emph) "~, ~",
        (link_i) "GRAFICOS MEDIANOS", (s_emph) "~ o ~",
        (link_i) "GRAFICOS GRANDES", (s_emph) "~.]^";
];


[ GritarSub;
!  pagina_contenidos.update(1);
!  diario_llave.update();
!  diario_ticket.update();  
!  diario_amigos.update();
!  midiario.update(p2, 1);
  "Emites un sonoro grito, pero nadie responde.";
];


[ LlamarPorSub;
  "Con eso no puedes llamar a ningún sitio.";
];


[ LlamarSub;
  "¿Llamar a qué o a quién?";
];


[ MusicaSub;
  print (s_emph) "[Por favor, usa la forma ~", (link_i) "SONIDO FONDO SI",
        (s_emph) "~ o ~", (link_i) "SONIDO FONDO NO", (s_emph) "~ para activar
        o desactivar, respectivamente, el sonido de fondo.]^";
];


[ PistasNoSub;
  switch (hayPistas) {
    2:       print (s_emph) "[Las pistas ya han sido desactivadas.]^";
    default: hayPistas = 2;
             print (s_emph) "[PISTAS desactivadas.]^";
  }
];


[ PistasSub
  i;
  switch (hayPistas) {
    0: hayPistas = 1;

       print (s_emph) "[Advertencia: Es sabido que la tentación de la ayuda es
             a veces tan fuerte que se suelen obtener pistas prematuramente.
             Por tanto, en cualquier momento durante el juego puedes poner ",
             (link_i) "PISTAS NO", (s_emph) ", y eso te impedirá obtener ayuda
             en la sesión de juego actual. Si sigues queriendo una pista, pon ",
             (link_i) "PISTAS", (s_emph) " otra vez.]^";

    1: ControlTimer.PausarTick();
       if (hayGraficos) {
         ApagarGraficos();
         hayGraficos = true;
       }
       ExtenderVentanaEstado();

       for (i = 0 : i < DAMUSIX_NCANALMAX : i++) {
         sonidosSonando->i = Damusix.SonandoDeFondoCanal(i);
         Damusix.PararCanal(i);
       }

       Damusix.AsignarCanal(Darkwalk_ogg, CANAL_FONDO,
                            Damusix.QueVolumenCanal(CANAL_FONDO), 
                            SONIDO_REPETIR);
       Damusix.TocarCanal(CANAL_FONDO);
       
       ZIPI_Empezar();
       
       for (i = 0 : i < DAMUSIX_NCANALMAX : i++) {
         if ((i ~= CANAL_FONDO) && (sonidosSonando->i)) Damusix.TocarCanal(i);
       }

       if ((sonidosSonando->CANAL_FONDO) && (LugarReal() provides sgw_mus)) {
         Damusix.AsignarCanal(LugarReal().sgw_mus, CANAL_FONDO,
                              Damusix.QueVolumenCanal(CANAL_FONDO),
                              SONIDO_REPETIR);
         Damusix.TocarCanal(CANAL_FONDO);
       } else {
         Damusix.PararCanal(CANAL_FONDO);
       }

       StatusLineHeight(1);
       MenuAcciones.MostrarImportantes();
       if (hayGraficos) EncenderGraficos();
       ControlTimer.ReanudarTick();
       glk_window_noscroll(gg_mainwin);

    2: print (s_emph) "[Las pistas han sido desactivadas.]^";
  }
];


! Para poder poner "SALIR AL PASILLO", que sería lo mismo que "ENTRA EN EL
! PASILLO".
[ SalirASub;
  print_ret (The) noun, " no es algo a donde puedas salir.";
];


[ SalirPorSub;
  if (noun ofclass Lugar) <<Exit>>;
  else                    <<Enter noun>>;
];


[ SaludarSub;
!  i c;
!  glk_set_config(config_LinkColor,
!                 glk_window_stylehint_get(gg_mainwin, style_Normal,
!                                          stylehint_TextColor));
!  glk_window_get_arrangement(glk_window_get_parent(gg_statuswin),
!                             gg_arguments, gg_arguments + WORDSIZE,
!                             gg_arguments + 2 * WORDSIZE);
!  glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
!                             gg_arguments-->0, gg_arguments-->1,
!                             gg_arguments-->2);
!  for (i = 255 : i >= 0 : i = i - 15) {
!    c = i * 65536 + i * 256 + i;
!    glk_window_stylehint_set(gg_mainwin, style_Normal,
!                                         stylehint_TextColor, c);
!    glk_set_config(config_LinkColor, c);
!    glk_window_get_arrangement(glk_window_get_parent(gg_statuswin),
!                               gg_arguments, gg_arguments + WORDSIZE,
!                               gg_arguments + 2 * WORDSIZE);
!    glk_window_set_arrangement(glk_window_get_parent(gg_statuswin),
!                               gg_arguments-->0, gg_arguments-->1,
!                               gg_arguments-->2);
!    WaitDelay(1);
!  }
  "Saludas cordialmente.";
];


[ SearchSub;
  <<Examine noun>>;
];


[ SeguirSub;
  "Decide por ti mism", (o) player, " a dónde deseas ir.";
];


[ SonidoSub;
  print (s_emph) "[Por favor, usa la forma ~", (s_input) "SONIDO SI",
        (s_emph) "~ o ~", (s_input) "SONIDO NO",
        (s_emph) "~ para activar o desactivar, respectivamente,
                  todos los efectos sonoros.]^";
];


[ TellSub;
  ComoHablar();
];


[ VenirSub;
  <<Seguir player>>;
];


[ VerboNuloSub;
  rfalse;
];


#ifdef DEBUG;
[ TestPasoAPasoSub;
  test_machine.run_once();
];


[ TestContinuarSub;
  test_machine.run();
];
#endif;


!===============================================================================
! (12) Partes de la aventura (en archivos separados)
!-------------------------------------------------------------------------------


Include "diario.inf";      ! Diario de tareas
Include "prologo.inf";     ! Prólogo
Include "historia.inf";    ! Primer capítulo


! Fin elcirculo.inf
